/*  Prototype JavaScript framework, version 1.7.2
 *  (c) 2005-2010 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/

var Prototype = {

    Version: '1.7.2',

    Browser: (function(){
        var ua = navigator.userAgent;
        var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
        return {
            IE:             !!window.attachEvent && !isOpera,
            Opera:          isOpera,
            WebKit:         ua.indexOf('AppleWebKit/') > -1,
            Gecko:          ua.indexOf('Gecko') > -1 && ua.indexOf('KHTML') === -1,
            MobileSafari:   /Apple.*Mobile/.test(ua)
        }
    })(),

    BrowserFeatures: {
        XPath: !!document.evaluate,

        SelectorsAPI: !!document.querySelector,

        ElementExtensions: (function() {
            var constructor = window.Element || window.HTMLElement;
            return !!(constructor && constructor.prototype);
        })(),
        SpecificElementExtensions: (function() {
            if (typeof window.HTMLDivElement !== 'undefined')
                return true;

            var div = document.createElement('div'),
                form = document.createElement('form'),
                isSupported = false;

            if (div['__proto__'] && (div['__proto__'] !== form['__proto__'])) {
                isSupported = true;
            }

            div = form = null;

            return isSupported;
        })()
    },

    ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script\\s*>',
    JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,

    emptyFunction: function() { },

    K: function(x) { return x }
};

if (Prototype.Browser.MobileSafari)
    Prototype.BrowserFeatures.SpecificElementExtensions = false;
/* Based on Alex Arnell's inheritance implementation. */

var Class = (function() {

    var IS_DONTENUM_BUGGY = (function(){
        for (var p in { toString: 1 }) {
            if (p === 'toString') return false;
        }
        return true;
    })();

    function subclass() {};
    function create() {
        var parent = null, properties = $A(arguments);
        if (Object.isFunction(properties[0]))
            parent = properties.shift();

        function klass() {
            this.initialize.apply(this, arguments);
        }

        Object.extend(klass, Class.Methods);
        klass.superclass = parent;
        klass.subclasses = [];

        if (parent) {
            subclass.prototype = parent.prototype;
            klass.prototype = new subclass;
            parent.subclasses.push(klass);
        }

        for (var i = 0, length = properties.length; i < length; i++)
            klass.addMethods(properties[i]);

        if (!klass.prototype.initialize)
            klass.prototype.initialize = Prototype.emptyFunction;

        klass.prototype.constructor = klass;
        return klass;
    }

    function addMethods(source) {
        var ancestor   = this.superclass && this.superclass.prototype,
            properties = Object.keys(source);

        if (IS_DONTENUM_BUGGY) {
            if (source.toString != Object.prototype.toString)
                properties.push("toString");
            if (source.valueOf != Object.prototype.valueOf)
                properties.push("valueOf");
        }

        for (var i = 0, length = properties.length; i < length; i++) {
            var property = properties[i], value = source[property];
            if (ancestor && Object.isFunction(value) &&
                value.argumentNames()[0] == "$super") {
                var method = value;
                value = (function(m) {
                    return function() { return ancestor[m].apply(this, arguments); };
                })(property).wrap(method);

                value.valueOf = (function(method) {
                    return function() { return method.valueOf.call(method); };
                })(method);

                value.toString = (function(method) {
                    return function() { return method.toString.call(method); };
                })(method);
            }
            this.prototype[property] = value;
        }

        return this;
    }

    return {
        create: create,
        Methods: {
            addMethods: addMethods
        }
    };
})();
(function() {

    var _toString = Object.prototype.toString,
        _hasOwnProperty = Object.prototype.hasOwnProperty,
        NULL_TYPE = 'Null',
        UNDEFINED_TYPE = 'Undefined',
        BOOLEAN_TYPE = 'Boolean',
        NUMBER_TYPE = 'Number',
        STRING_TYPE = 'String',
        OBJECT_TYPE = 'Object',
        FUNCTION_CLASS = '[object Function]',
        BOOLEAN_CLASS = '[object Boolean]',
        NUMBER_CLASS = '[object Number]',
        STRING_CLASS = '[object String]',
        ARRAY_CLASS = '[object Array]',
        DATE_CLASS = '[object Date]',
        NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON &&
            typeof JSON.stringify === 'function' &&
            JSON.stringify(0) === '0' &&
            typeof JSON.stringify(Prototype.K) === 'undefined';



    var DONT_ENUMS = ['toString', 'toLocaleString', 'valueOf',
        'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

    var IS_DONTENUM_BUGGY = (function(){
        for (var p in { toString: 1 }) {
            if (p === 'toString') return false;
        }
        return true;
    })();

    function Type(o) {
        switch(o) {
            case null: return NULL_TYPE;
            case (void 0): return UNDEFINED_TYPE;
        }
        var type = typeof o;
        switch(type) {
            case 'boolean': return BOOLEAN_TYPE;
            case 'number':  return NUMBER_TYPE;
            case 'string':  return STRING_TYPE;
        }
        return OBJECT_TYPE;
    }

    function extend(destination, source) {
        for (var property in source)
            destination[property] = source[property];
        return destination;
    }

    function inspect(object) {
        try {
            if (isUndefined(object)) return 'undefined';
            if (object === null) return 'null';
            return object.inspect ? object.inspect() : String(object);
        } catch (e) {
            if (e instanceof RangeError) return '...';
            throw e;
        }
    }

    function toJSON(value) {
        return Str('', { '': value }, []);
    }

    function Str(key, holder, stack) {
        var value = holder[key];
        if (Type(value) === OBJECT_TYPE && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

        var _class = _toString.call(value);

        switch (_class) {
            case NUMBER_CLASS:
            case BOOLEAN_CLASS:
            case STRING_CLASS:
                value = value.valueOf();
        }

        switch (value) {
            case null: return 'null';
            case true: return 'true';
            case false: return 'false';
        }

        var type = typeof value;
        switch (type) {
            case 'string':
                return value.inspect(true);
            case 'number':
                return isFinite(value) ? String(value) : 'null';
            case 'object':

                for (var i = 0, length = stack.length; i < length; i++) {
                    if (stack[i] === value) {
                        throw new TypeError("Cyclic reference to '" + value + "' in object");
                    }
                }
                stack.push(value);

                var partial = [];
                if (_class === ARRAY_CLASS) {
                    for (var i = 0, length = value.length; i < length; i++) {
                        var str = Str(i, value, stack);
                        partial.push(typeof str === 'undefined' ? 'null' : str);
                    }
                    partial = '[' + partial.join(',') + ']';
                } else {
                    var keys = Object.keys(value);
                    for (var i = 0, length = keys.length; i < length; i++) {
                        var key = keys[i], str = Str(key, value, stack);
                        if (typeof str !== "undefined") {
                            partial.push(key.inspect(true)+ ':' + str);
                        }
                    }
                    partial = '{' + partial.join(',') + '}';
                }
                stack.pop();
                return partial;
        }
    }

    function stringify(object) {
        return JSON.stringify(object);
    }

    function toQueryString(object) {
        return $H(object).toQueryString();
    }

    function toHTML(object) {
        return object && object.toHTML ? object.toHTML() : String.interpret(object);
    }

    function keys(object) {
        if (Type(object) !== OBJECT_TYPE) { throw new TypeError(); }
        var results = [];
        for (var property in object) {
            if (_hasOwnProperty.call(object, property))
                results.push(property);
        }

        if (IS_DONTENUM_BUGGY) {
            for (var i = 0; property = DONT_ENUMS[i]; i++) {
                if (_hasOwnProperty.call(object, property))
                    results.push(property);
            }
        }

        return results;
    }

    function values(object) {
        var results = [];
        for (var property in object)
            results.push(object[property]);
        return results;
    }

    function clone(object) {
        return extend({ }, object);
    }

    function isElement(object) {
        return !!(object && object.nodeType == 1);
    }

    function isArray(object) {
        return _toString.call(object) === ARRAY_CLASS;
    }

    var hasNativeIsArray = (typeof Array.isArray == 'function')
        && Array.isArray([]) && !Array.isArray({});

    if (hasNativeIsArray) {
        isArray = Array.isArray;
    }

    function isHash(object) {
        return object instanceof Hash;
    }

    function isFunction(object) {
        return _toString.call(object) === FUNCTION_CLASS;
    }

    function isString(object) {
        return _toString.call(object) === STRING_CLASS;
    }

    function isNumber(object) {
        return _toString.call(object) === NUMBER_CLASS;
    }

    function isDate(object) {
        return _toString.call(object) === DATE_CLASS;
    }

    function isUndefined(object) {
        return typeof object === "undefined";
    }

    extend(Object, {
        extend:        extend,
        inspect:       inspect,
        toJSON:        NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
        toQueryString: toQueryString,
        toHTML:        toHTML,
        keys:          Object.keys || keys,
        values:        values,
        clone:         clone,
        isElement:     isElement,
        isArray:       isArray,
        isHash:        isHash,
        isFunction:    isFunction,
        isString:      isString,
        isNumber:      isNumber,
        isDate:        isDate,
        isUndefined:   isUndefined
    });
})();
Object.extend(Function.prototype, (function() {
    var slice = Array.prototype.slice;

    function update(array, args) {
        var arrayLength = array.length, length = args.length;
        while (length--) array[arrayLength + length] = args[length];
        return array;
    }

    function merge(array, args) {
        array = slice.call(array, 0);
        return update(array, args);
    }

    function argumentNames() {
        var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
            .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
            .replace(/\s+/g, '').split(',');
        return names.length == 1 && !names[0] ? [] : names;
    }


    function bind(context) {
        if (arguments.length < 2 && Object.isUndefined(arguments[0]))
            return this;

        if (!Object.isFunction(this))
            throw new TypeError("The object is not callable.");

        var nop = function() {};
        var __method = this, args = slice.call(arguments, 1);

        var bound = function() {
            var a = merge(args, arguments);
            var c = this instanceof bound ? this : context;
            return __method.apply(c, a);
        };

        nop.prototype   = this.prototype;
        bound.prototype = new nop();

        return bound;
    }

    function bindAsEventListener(context) {
        var __method = this, args = slice.call(arguments, 1);
        return function(event) {
            var a = update([event || window.event], args);
            return __method.apply(context, a);
        }
    }

    function curry() {
        if (!arguments.length) return this;
        var __method = this, args = slice.call(arguments, 0);
        return function() {
            var a = merge(args, arguments);
            return __method.apply(this, a);
        }
    }

    function delay(timeout) {
        var __method = this, args = slice.call(arguments, 1);
        timeout = timeout * 1000;
        return window.setTimeout(function() {
            return __method.apply(__method, args);
        }, timeout);
    }

    function defer() {
        var args = update([0.01], arguments);
        return this.delay.apply(this, args);
    }

    function wrap(wrapper) {
        var __method = this;
        return function() {
            var a = update([__method.bind(this)], arguments);
            return wrapper.apply(this, a);
        }
    }

    function methodize() {
        if (this._methodized) return this._methodized;
        var __method = this;
        return this._methodized = function() {
            var a = update([this], arguments);
            return __method.apply(null, a);
        };
    }

    var extensions = {
        argumentNames:       argumentNames,
        bindAsEventListener: bindAsEventListener,
        curry:               curry,
        delay:               delay,
        defer:               defer,
        wrap:                wrap,
        methodize:           methodize
    };

    if (!Function.prototype.bind)
        extensions.bind = bind;

    return extensions;
})());



(function(proto) {


    function toISOString() {
        return this.getUTCFullYear() + '-' +
            (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
            this.getUTCDate().toPaddedString(2) + 'T' +
            this.getUTCHours().toPaddedString(2) + ':' +
            this.getUTCMinutes().toPaddedString(2) + ':' +
            this.getUTCSeconds().toPaddedString(2) + 'Z';
    }


    function toJSON() {
        return this.toISOString();
    }

    if (!proto.toISOString) proto.toISOString = toISOString;
    if (!proto.toJSON) proto.toJSON = toJSON;

})(Date.prototype);


RegExp.prototype.match = RegExp.prototype.test;

RegExp.escape = function(str) {
    return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};
var PeriodicalExecuter = Class.create({
    initialize: function(callback, frequency) {
        this.callback = callback;
        this.frequency = frequency;
        this.currentlyExecuting = false;

        this.registerCallback();
    },

    registerCallback: function() {
        this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
    },

    execute: function() {
        this.callback(this);
    },

    stop: function() {
        if (!this.timer) return;
        clearInterval(this.timer);
        this.timer = null;
    },

    onTimerEvent: function() {
        if (!this.currentlyExecuting) {
            try {
                this.currentlyExecuting = true;
                this.execute();
                this.currentlyExecuting = false;
            } catch(e) {
                this.currentlyExecuting = false;
                throw e;
            }
        }
    }
});
Object.extend(String, {
    interpret: function(value) {
        return value == null ? '' : String(value);
    },
    specialChar: {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '\\': '\\\\'
    }
});

Object.extend(String.prototype, (function() {
    var NATIVE_JSON_PARSE_SUPPORT = window.JSON &&
        typeof JSON.parse === 'function' &&
        JSON.parse('{"test": true}').test;

    function prepareReplacement(replacement) {
        if (Object.isFunction(replacement)) return replacement;
        var template = new Template(replacement);
        return function(match) { return template.evaluate(match) };
    }

    function isNonEmptyRegExp(regexp) {
        return regexp.source && regexp.source !== '(?:)';
    }


    function gsub(pattern, replacement) {
        var result = '', source = this, match;
        replacement = prepareReplacement(replacement);

        if (Object.isString(pattern))
            pattern = RegExp.escape(pattern);

        if (!(pattern.length || isNonEmptyRegExp(pattern))) {
            replacement = replacement('');
            return replacement + source.split('').join(replacement) + replacement;
        }

        while (source.length > 0) {
            match = source.match(pattern)
            if (match && match[0].length > 0) {
                result += source.slice(0, match.index);
                result += String.interpret(replacement(match));
                source  = source.slice(match.index + match[0].length);
            } else {
                result += source, source = '';
            }
        }
        return result;
    }

    function sub(pattern, replacement, count) {
        replacement = prepareReplacement(replacement);
        count = Object.isUndefined(count) ? 1 : count;

        return this.gsub(pattern, function(match) {
            if (--count < 0) return match[0];
            return replacement(match);
        });
    }

    function scan(pattern, iterator) {
        this.gsub(pattern, iterator);
        return String(this);
    }

    function truncate(length, truncation) {
        length = length || 30;
        truncation = Object.isUndefined(truncation) ? '...' : truncation;
        return this.length > length ?
        this.slice(0, length - truncation.length) + truncation : String(this);
    }

    function strip() {
        return this.replace(/^\s+/, '').replace(/\s+$/, '');
    }

    function stripTags() {
        return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');
    }

    function stripScripts() {
        return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
    }

    function extractScripts() {
        var matchAll = new RegExp(Prototype.ScriptFragment, 'img'),
            matchOne = new RegExp(Prototype.ScriptFragment, 'im');
        return (this.match(matchAll) || []).map(function(scriptTag) {
            return (scriptTag.match(matchOne) || ['', ''])[1];
        });
    }

    function evalScripts() {
        return this.extractScripts().map(function(script) { return eval(script); });
    }

    function escapeHTML() {
        return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function unescapeHTML() {
        return this.stripTags().replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&');
    }


    function toQueryParams(separator) {
        var match = this.strip().match(/([^?#]*)(#.*)?$/);
        if (!match) return { };

        return match[1].split(separator || '&').inject({ }, function(hash, pair) {
            if ((pair = pair.split('='))[0]) {
                var key = decodeURIComponent(pair.shift()),
                    value = pair.length > 1 ? pair.join('=') : pair[0];

                if (value != undefined) {
                    value = value.gsub('+', ' ');
                    value = decodeURIComponent(value);
                }

                if (key in hash) {
                    if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
                    hash[key].push(value);
                }
                else hash[key] = value;
            }
            return hash;
        });
    }

    function toArray() {
        return this.split('');
    }

    function succ() {
        return this.slice(0, this.length - 1) +
            String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
    }

    function times(count) {
        return count < 1 ? '' : new Array(count + 1).join(this);
    }

    function camelize() {
        return this.replace(/-+(.)?/g, function(match, chr) {
            return chr ? chr.toUpperCase() : '';
        });
    }

    function capitalize() {
        return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
    }

    function underscore() {
        return this.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/-/g, '_')
            .toLowerCase();
    }

    function dasherize() {
        return this.replace(/_/g, '-');
    }

    function inspect(useDoubleQuotes) {
        var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
            if (character in String.specialChar) {
                return String.specialChar[character];
            }
            return '\\u00' + character.charCodeAt().toPaddedString(2, 16);
        });
        if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
        return "'" + escapedString.replace(/'/g, '\\\'') + "'";
    }

    function unfilterJSON(filter) {
        return this.replace(filter || Prototype.JSONFilter, '$1');
    }

    function isJSON() {
        var str = this;
        if (str.blank()) return false;
        str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
        str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
        str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
        return (/^[\],:{}\s]*$/).test(str);
    }

    function evalJSON(sanitize) {
        var json = this.unfilterJSON(),
            cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        if (cx.test(json)) {
            json = json.replace(cx, function (a) {
                return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }
        try {
            if (!sanitize || json.isJSON()) return eval('(' + json + ')');
        } catch (e) { }
        throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
    }

    function parseJSON() {
        var json = this.unfilterJSON();
        return JSON.parse(json);
    }

    function include(pattern) {
        return this.indexOf(pattern) > -1;
    }

    function startsWith(pattern, position) {
        position = Object.isNumber(position) ? position : 0;
        return this.lastIndexOf(pattern, position) === position;
    }

    function endsWith(pattern, position) {
        pattern = String(pattern);
        position = Object.isNumber(position) ? position : this.length;
        if (position < 0) position = 0;
        if (position > this.length) position = this.length;
        var d = position - pattern.length;
        return d >= 0 && this.indexOf(pattern, d) === d;
    }

    function empty() {
        return this == '';
    }

    function blank() {
        return /^\s*$/.test(this);
    }

    function interpolate(object, pattern) {
        return new Template(this, pattern).evaluate(object);
    }

    return {
        gsub:           gsub,
        sub:            sub,
        scan:           scan,
        truncate:       truncate,
        strip:          String.prototype.trim || strip,
        stripTags:      stripTags,
        stripScripts:   stripScripts,
        extractScripts: extractScripts,
        evalScripts:    evalScripts,
        escapeHTML:     escapeHTML,
        unescapeHTML:   unescapeHTML,
        toQueryParams:  toQueryParams,
        parseQuery:     toQueryParams,
        toArray:        toArray,
        succ:           succ,
        times:          times,
        camelize:       camelize,
        capitalize:     capitalize,
        underscore:     underscore,
        dasherize:      dasherize,
        inspect:        inspect,
        unfilterJSON:   unfilterJSON,
        isJSON:         isJSON,
        evalJSON:       NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
        include:        include,
        startsWith:     String.prototype.startsWith || startsWith,
        endsWith:       String.prototype.endsWith || endsWith,
        empty:          empty,
        blank:          blank,
        interpolate:    interpolate
    };
})());

var Template = Class.create({
    initialize: function(template, pattern) {
        this.template = template.toString();
        this.pattern = pattern || Template.Pattern;
    },

    evaluate: function(object) {
        if (object && Object.isFunction(object.toTemplateReplacements))
            object = object.toTemplateReplacements();

        return this.template.gsub(this.pattern, function(match) {
            if (object == null) return (match[1] + '');

            var before = match[1] || '';
            if (before == '\\') return match[2];

            var ctx = object, expr = match[3],
                pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;

            match = pattern.exec(expr);
            if (match == null) return before;

            while (match != null) {
                var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
                ctx = ctx[comp];
                if (null == ctx || '' == match[3]) break;
                expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
                match = pattern.exec(expr);
            }

            return before + String.interpret(ctx);
        });
    }
});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;

var $break = { };

var Enumerable = (function() {
    function each(iterator, context) {
        try {
            this._each(iterator, context);
        } catch (e) {
            if (e != $break) throw e;
        }
        return this;
    }

    function eachSlice(number, iterator, context) {
        var index = -number, slices = [], array = this.toArray();
        if (number < 1) return array;
        while ((index += number) < array.length)
            slices.push(array.slice(index, index+number));
        return slices.collect(iterator, context);
    }

    function all(iterator, context) {
        iterator = iterator || Prototype.K;
        var result = true;
        this.each(function(value, index) {
            result = result && !!iterator.call(context, value, index, this);
            if (!result) throw $break;
        }, this);
        return result;
    }

    function any(iterator, context) {
        iterator = iterator || Prototype.K;
        var result = false;
        this.each(function(value, index) {
            if (result = !!iterator.call(context, value, index, this))
                throw $break;
        }, this);
        return result;
    }

    function collect(iterator, context) {
        iterator = iterator || Prototype.K;
        var results = [];
        this.each(function(value, index) {
            results.push(iterator.call(context, value, index, this));
        }, this);
        return results;
    }

    function detect(iterator, context) {
        var result;
        this.each(function(value, index) {
            if (iterator.call(context, value, index, this)) {
                result = value;
                throw $break;
            }
        }, this);
        return result;
    }

    function findAll(iterator, context) {
        var results = [];
        this.each(function(value, index) {
            if (iterator.call(context, value, index, this))
                results.push(value);
        }, this);
        return results;
    }

    function grep(filter, iterator, context) {
        iterator = iterator || Prototype.K;
        var results = [];

        if (Object.isString(filter))
            filter = new RegExp(RegExp.escape(filter));

        this.each(function(value, index) {
            if (filter.match(value))
                results.push(iterator.call(context, value, index, this));
        }, this);
        return results;
    }

    function include(object) {
        if (Object.isFunction(this.indexOf) && this.indexOf(object) != -1)
            return true;

        var found = false;
        this.each(function(value) {
            if (value == object) {
                found = true;
                throw $break;
            }
        });
        return found;
    }

    function inGroupsOf(number, fillWith) {
        fillWith = Object.isUndefined(fillWith) ? null : fillWith;
        return this.eachSlice(number, function(slice) {
            while(slice.length < number) slice.push(fillWith);
            return slice;
        });
    }

    function inject(memo, iterator, context) {
        this.each(function(value, index) {
            memo = iterator.call(context, memo, value, index, this);
        }, this);
        return memo;
    }

    function invoke(method) {
        var args = $A(arguments).slice(1);
        return this.map(function(value) {
            return value[method].apply(value, args);
        });
    }

    function max(iterator, context) {
        iterator = iterator || Prototype.K;
        var result;
        this.each(function(value, index) {
            value = iterator.call(context, value, index, this);
            if (result == null || value >= result)
                result = value;
        }, this);
        return result;
    }

    function min(iterator, context) {
        iterator = iterator || Prototype.K;
        var result;
        this.each(function(value, index) {
            value = iterator.call(context, value, index, this);
            if (result == null || value < result)
                result = value;
        }, this);
        return result;
    }

    function partition(iterator, context) {
        iterator = iterator || Prototype.K;
        var trues = [], falses = [];
        this.each(function(value, index) {
            (iterator.call(context, value, index, this) ?
                trues : falses).push(value);
        }, this);
        return [trues, falses];
    }

    function pluck(property) {
        var results = [];
        this.each(function(value) {
            results.push(value[property]);
        });
        return results;
    }

    function reject(iterator, context) {
        var results = [];
        this.each(function(value, index) {
            if (!iterator.call(context, value, index, this))
                results.push(value);
        }, this);
        return results;
    }

    function sortBy(iterator, context) {
        return this.map(function(value, index) {
            return {
                value: value,
                criteria: iterator.call(context, value, index, this)
            };
        }, this).sort(function(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }).pluck('value');
    }

    function toArray() {
        return this.map();
    }

    function zip() {
        var iterator = Prototype.K, args = $A(arguments);
        if (Object.isFunction(args.last()))
            iterator = args.pop();

        var collections = [this].concat(args).map($A);
        return this.map(function(value, index) {
            return iterator(collections.pluck(index));
        });
    }

    function size() {
        return this.toArray().length;
    }

    function inspect() {
        return '#<Enumerable:' + this.toArray().inspect() + '>';
    }









    return {
        each:       each,
        eachSlice:  eachSlice,
        all:        all,
        every:      all,
        any:        any,
        some:       any,
        collect:    collect,
        map:        collect,
        detect:     detect,
        findAll:    findAll,
        select:     findAll,
        filter:     findAll,
        grep:       grep,
        include:    include,
        member:     include,
        inGroupsOf: inGroupsOf,
        inject:     inject,
        invoke:     invoke,
        max:        max,
        min:        min,
        partition:  partition,
        pluck:      pluck,
        reject:     reject,
        sortBy:     sortBy,
        toArray:    toArray,
        entries:    toArray,
        zip:        zip,
        size:       size,
        inspect:    inspect,
        find:       detect
    };
})();

function $A(iterable) {
    if (!iterable) return [];
    if ('toArray' in Object(iterable)) return iterable.toArray();
    var length = iterable.length || 0, results = new Array(length);
    while (length--) results[length] = iterable[length];
    return results;
}


function $w(string) {
    if (!Object.isString(string)) return [];
    string = string.strip();
    return string ? string.split(/\s+/) : [];
}

Array.from = $A;


(function() {
    var arrayProto = Array.prototype,
        slice = arrayProto.slice,
        _each = arrayProto.forEach; // use native browser JS 1.6 implementation if available

    function each(iterator, context) {
        for (var i = 0, length = this.length >>> 0; i < length; i++) {
            if (i in this) iterator.call(context, this[i], i, this);
        }
    }
    if (!_each) _each = each;

    function clear() {
        this.length = 0;
        return this;
    }

    function first() {
        return this[0];
    }

    function last() {
        return this[this.length - 1];
    }

    function compact() {
        return this.select(function(value) {
            return value != null;
        });
    }

    function flatten() {
        return this.inject([], function(array, value) {
            if (Object.isArray(value))
                return array.concat(value.flatten());
            array.push(value);
            return array;
        });
    }

    function without() {
        var values = slice.call(arguments, 0);
        return this.select(function(value) {
            return !values.include(value);
        });
    }

    function reverse(inline) {
        return (inline === false ? this.toArray() : this)._reverse();
    }

    function uniq(sorted) {
        return this.inject([], function(array, value, index) {
            if (0 == index || (sorted ? array.last() != value : !array.include(value)))
                array.push(value);
            return array;
        });
    }

    function intersect(array) {
        return this.uniq().findAll(function(item) {
            return array.indexOf(item) !== -1;
        });
    }


    function clone() {
        return slice.call(this, 0);
    }

    function size() {
        return this.length;
    }

    function inspect() {
        return '[' + this.map(Object.inspect).join(', ') + ']';
    }

    function indexOf(item, i) {
        if (this == null) throw new TypeError();

        var array = Object(this), length = array.length >>> 0;
        if (length === 0) return -1;

        i = Number(i);
        if (isNaN(i)) {
            i = 0;
        } else if (i !== 0 && isFinite(i)) {
            i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i));
        }

        if (i > length) return -1;

        var k = i >= 0 ? i : Math.max(length - Math.abs(i), 0);
        for (; k < length; k++)
            if (k in array && array[k] === item) return k;
        return -1;
    }


    function lastIndexOf(item, i) {
        if (this == null) throw new TypeError();

        var array = Object(this), length = array.length >>> 0;
        if (length === 0) return -1;

        if (!Object.isUndefined(i)) {
            i = Number(i);
            if (isNaN(i)) {
                i = 0;
            } else if (i !== 0 && isFinite(i)) {
                i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i));
            }
        } else {
            i = length;
        }

        var k = i >= 0 ? Math.min(i, length - 1) :
        length - Math.abs(i);

        for (; k >= 0; k--)
            if (k in array && array[k] === item) return k;
        return -1;
    }

    function concat(_) {
        var array = [], items = slice.call(arguments, 0), item, n = 0;
        items.unshift(this);
        for (var i = 0, length = items.length; i < length; i++) {
            item = items[i];
            if (Object.isArray(item) && !('callee' in item)) {
                for (var j = 0, arrayLength = item.length; j < arrayLength; j++) {
                    if (j in item) array[n] = item[j];
                    n++;
                }
            } else {
                array[n++] = item;
            }
        }
        array.length = n;
        return array;
    }


    function wrapNative(method) {
        return function() {
            if (arguments.length === 0) {
                return method.call(this, Prototype.K);
            } else if (arguments[0] === undefined) {
                var args = slice.call(arguments, 1);
                args.unshift(Prototype.K);
                return method.apply(this, args);
            } else {
                return method.apply(this, arguments);
            }
        };
    }


    function map(iterator) {
        if (this == null) throw new TypeError();
        iterator = iterator || Prototype.K;

        var object = Object(this);
        var results = [], context = arguments[1], n = 0;

        for (var i = 0, length = object.length >>> 0; i < length; i++) {
            if (i in object) {
                results[n] = iterator.call(context, object[i], i, object);
            }
            n++;
        }
        results.length = n;
        return results;
    }

    if (arrayProto.map) {
        map = wrapNative(Array.prototype.map);
    }

    function filter(iterator) {
        if (this == null || !Object.isFunction(iterator))
            throw new TypeError();

        var object = Object(this);
        var results = [], context = arguments[1], value;

        for (var i = 0, length = object.length >>> 0; i < length; i++) {
            if (i in object) {
                value = object[i];
                if (iterator.call(context, value, i, object)) {
                    results.push(value);
                }
            }
        }
        return results;
    }

    if (arrayProto.filter) {
        filter = Array.prototype.filter;
    }

    function some(iterator) {
        if (this == null) throw new TypeError();
        iterator = iterator || Prototype.K;
        var context = arguments[1];

        var object = Object(this);
        for (var i = 0, length = object.length >>> 0; i < length; i++) {
            if (i in object && iterator.call(context, object[i], i, object)) {
                return true;
            }
        }

        return false;
    }

    if (arrayProto.some) {
        var some = wrapNative(Array.prototype.some);
    }


    function every(iterator) {
        if (this == null) throw new TypeError();
        iterator = iterator || Prototype.K;
        var context = arguments[1];

        var object = Object(this);
        for (var i = 0, length = object.length >>> 0; i < length; i++) {
            if (i in object && !iterator.call(context, object[i], i, object)) {
                return false;
            }
        }

        return true;
    }

    if (arrayProto.every) {
        var every = wrapNative(Array.prototype.every);
    }

    var _reduce = arrayProto.reduce;
    function inject(memo, iterator) {
        iterator = iterator || Prototype.K;
        var context = arguments[2];
        return _reduce.call(this, iterator.bind(context), memo);
    }

    if (!arrayProto.reduce) {
        var inject = Enumerable.inject;
    }

    Object.extend(arrayProto, Enumerable);

    if (!arrayProto._reverse)
        arrayProto._reverse = arrayProto.reverse;

    Object.extend(arrayProto, {
        _each:     _each,

        map:       map,
        collect:   map,
        select:    filter,
        filter:    filter,
        findAll:   filter,
        some:      some,
        any:       some,
        every:     every,
        all:       every,
        inject:    inject,

        clear:     clear,
        first:     first,
        last:      last,
        compact:   compact,
        flatten:   flatten,
        without:   without,
        reverse:   reverse,
        uniq:      uniq,
        intersect: intersect,
        clone:     clone,
        toArray:   clone,
        size:      size,
        inspect:   inspect
    });

    var CONCAT_ARGUMENTS_BUGGY = (function() {
        return [].concat(arguments)[0][0] !== 1;
    })(1,2);

    if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;

    if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
    if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
})();
function $H(object) {
    return new Hash(object);
};

var Hash = Class.create(Enumerable, (function() {
    function initialize(object) {
        this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
    }


    function _each(iterator, context) {
        var i = 0;
        for (var key in this._object) {
            var value = this._object[key], pair = [key, value];
            pair.key = key;
            pair.value = value;
            iterator.call(context, pair, i);
            i++;
        }
    }

    function set(key, value) {
        return this._object[key] = value;
    }

    function get(key) {
        if (this._object[key] !== Object.prototype[key])
            return this._object[key];
    }

    function unset(key) {
        var value = this._object[key];
        delete this._object[key];
        return value;
    }

    function toObject() {
        return Object.clone(this._object);
    }



    function keys() {
        return this.pluck('key');
    }

    function values() {
        return this.pluck('value');
    }

    function index(value) {
        var match = this.detect(function(pair) {
            return pair.value === value;
        });
        return match && match.key;
    }

    function merge(object) {
        return this.clone().update(object);
    }

    function update(object) {
        return new Hash(object).inject(this, function(result, pair) {
            result.set(pair.key, pair.value);
            return result;
        });
    }

    function toQueryPair(key, value) {
        if (Object.isUndefined(value)) return key;

        value = String.interpret(value);

        value = value.gsub(/(\r)?\n/, '\r\n');
        value = encodeURIComponent(value);
        value = value.gsub(/%20/, '+');
        return key + '=' + value;
    }

    function toQueryString() {
        return this.inject([], function(results, pair) {
            var key = encodeURIComponent(pair.key), values = pair.value;

            if (values && typeof values == 'object') {
                if (Object.isArray(values)) {
                    var queryValues = [];
                    for (var i = 0, len = values.length, value; i < len; i++) {
                        value = values[i];
                        queryValues.push(toQueryPair(key, value));
                    }
                    return results.concat(queryValues);
                }
            } else results.push(toQueryPair(key, values));
            return results;
        }).join('&');
    }

    function inspect() {
        return '#<Hash:{' + this.map(function(pair) {
                return pair.map(Object.inspect).join(': ');
            }).join(', ') + '}>';
    }

    function clone() {
        return new Hash(this);
    }

    return {
        initialize:             initialize,
        _each:                  _each,
        set:                    set,
        get:                    get,
        unset:                  unset,
        toObject:               toObject,
        toTemplateReplacements: toObject,
        keys:                   keys,
        values:                 values,
        index:                  index,
        merge:                  merge,
        update:                 update,
        toQueryString:          toQueryString,
        inspect:                inspect,
        toJSON:                 toObject,
        clone:                  clone
    };
})());

Hash.from = $H;
Object.extend(Number.prototype, (function() {
    function toColorPart() {
        return this.toPaddedString(2, 16);
    }

    function succ() {
        return this + 1;
    }

    function times(iterator, context) {
        $R(0, this, true).each(iterator, context);
        return this;
    }

    function toPaddedString(length, radix) {
        var string = this.toString(radix || 10);
        return '0'.times(length - string.length) + string;
    }

    function abs() {
        return Math.abs(this);
    }

    function round() {
        return Math.round(this);
    }

    function ceil() {
        return Math.ceil(this);
    }

    function floor() {
        return Math.floor(this);
    }

    return {
        toColorPart:    toColorPart,
        succ:           succ,
        times:          times,
        toPaddedString: toPaddedString,
        abs:            abs,
        round:          round,
        ceil:           ceil,
        floor:          floor
    };
})());

function $R(start, end, exclusive) {
    return new ObjectRange(start, end, exclusive);
}

var ObjectRange = Class.create(Enumerable, (function() {
    function initialize(start, end, exclusive) {
        this.start = start;
        this.end = end;
        this.exclusive = exclusive;
    }

    function _each(iterator, context) {
        var value = this.start, i;
        for (i = 0; this.include(value); i++) {
            iterator.call(context, value, i);
            value = value.succ();
        }
    }

    function include(value) {
        if (value < this.start)
            return false;
        if (this.exclusive)
            return value < this.end;
        return value <= this.end;
    }

    return {
        initialize: initialize,
        _each:      _each,
        include:    include
    };
})());



var Abstract = { };


var Try = {
    these: function() {
        var returnValue;

        for (var i = 0, length = arguments.length; i < length; i++) {
            var lambda = arguments[i];
            try {
                returnValue = lambda();
                break;
            } catch (e) { }
        }

        return returnValue;
    }
};

var Ajax = {
    getTransport: function() {
        return Try.these(
                function() {return new XMLHttpRequest()},
                function() {return new ActiveXObject('Msxml2.XMLHTTP')},
                function() {return new ActiveXObject('Microsoft.XMLHTTP')}
            ) || false;
    },

    activeRequestCount: 0
};

Ajax.Responders = {
    responders: [],

    _each: function(iterator, context) {
        this.responders._each(iterator, context);
    },

    register: function(responder) {
        if (!this.include(responder))
            this.responders.push(responder);
    },

    unregister: function(responder) {
        this.responders = this.responders.without(responder);
    },

    dispatch: function(callback, request, transport, json) {
        this.each(function(responder) {
            if (Object.isFunction(responder[callback])) {
                try {
                    responder[callback].apply(responder, [request, transport, json]);
                } catch (e) { }
            }
        });
    }
};

Object.extend(Ajax.Responders, Enumerable);

Ajax.Responders.register({
    onCreate:   function() { Ajax.activeRequestCount++ },
    onComplete: function() { Ajax.activeRequestCount-- }
});
Ajax.Base = Class.create({
    initialize: function(options) {
        this.options = {
            method:       'post',
            asynchronous: true,
            contentType:  'application/x-www-form-urlencoded',
            encoding:     'UTF-8',
            parameters:   '',
            evalJSON:     true,
            evalJS:       true
        };
        Object.extend(this.options, options || { });

        this.options.method = this.options.method.toLowerCase();

        if (Object.isHash(this.options.parameters))
            this.options.parameters = this.options.parameters.toObject();
    }
});
Ajax.Request = Class.create(Ajax.Base, {
    _complete: false,

    initialize: function($super, url, options) {
        $super(options);
        this.transport = Ajax.getTransport();
        this.request(url);
    },

    request: function(url) {
        this.url = url;
        this.method = this.options.method;
        var params = Object.isString(this.options.parameters) ?
            this.options.parameters :
            Object.toQueryString(this.options.parameters);

        if (!['get', 'post'].include(this.method)) {
            params += (params ? '&' : '') + "_method=" + this.method;
            this.method = 'post';
        }

        if (params && this.method === 'get') {
            this.url += (this.url.include('?') ? '&' : '?') + params;
        }

        this.parameters = params.toQueryParams();

        try {
            var response = new Ajax.Response(this);
            if (this.options.onCreate) this.options.onCreate(response);
            Ajax.Responders.dispatch('onCreate', this, response);

            this.transport.open(this.method.toUpperCase(), this.url,
                this.options.asynchronous);

            if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);

            this.transport.onreadystatechange = this.onStateChange.bind(this);
            this.setRequestHeaders();

            this.body = this.method == 'post' ? (this.options.postBody || params) : null;
            this.transport.send(this.body);

            /* Force Firefox to handle ready state 4 for synchronous requests */
            if (!this.options.asynchronous && this.transport.overrideMimeType)
                this.onStateChange();

        }
        catch (e) {
            this.dispatchException(e);
        }
    },

    onStateChange: function() {
        var readyState = this.transport.readyState;
        if (readyState > 1 && !((readyState == 4) && this._complete))
            this.respondToReadyState(this.transport.readyState);
    },

    setRequestHeaders: function() {
        var headers = {
            'X-Requested-With': 'XMLHttpRequest',
            'X-Prototype-Version': Prototype.Version,
            'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
        };

        if (this.method == 'post') {
            headers['Content-type'] = this.options.contentType +
                (this.options.encoding ? '; charset=' + this.options.encoding : '');

            /* Force "Connection: close" for older Mozilla browsers to work
             * around a bug where XMLHttpRequest sends an incorrect
             * Content-length header. See Mozilla Bugzilla #246651.
             */
            if (this.transport.overrideMimeType &&
                (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
                headers['Connection'] = 'close';
        }

        if (typeof this.options.requestHeaders == 'object') {
            var extras = this.options.requestHeaders;

            if (Object.isFunction(extras.push))
                for (var i = 0, length = extras.length; i < length; i += 2)
                    headers[extras[i]] = extras[i+1];
            else
                $H(extras).each(function(pair) { headers[pair.key] = pair.value });
        }

        for (var name in headers)
            if (headers[name] != null)
                this.transport.setRequestHeader(name, headers[name]);
    },

    success: function() {
        var status = this.getStatus();
        return !status || (status >= 200 && status < 300) || status == 304;
    },

    getStatus: function() {
        try {
            if (this.transport.status === 1223) return 204;
            return this.transport.status || 0;
        } catch (e) { return 0 }
    },

    respondToReadyState: function(readyState) {
        var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);

        if (state == 'Complete') {
            try {
                this._complete = true;
                (this.options['on' + response.status]
                || this.options['on' + (this.success() ? 'Success' : 'Failure')]
                || Prototype.emptyFunction)(response, response.headerJSON);
            } catch (e) {
                this.dispatchException(e);
            }

            var contentType = response.getHeader('Content-type');
            if (this.options.evalJS == 'force'
                || (this.options.evalJS && this.isSameOrigin() && contentType
                && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
                this.evalResponse();
        }

        try {
            (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
            Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
        } catch (e) {
            this.dispatchException(e);
        }

        if (state == 'Complete') {
            this.transport.onreadystatechange = Prototype.emptyFunction;
        }
    },

    isSameOrigin: function() {
        var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
        return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
                protocol: location.protocol,
                domain: document.domain,
                port: location.port ? ':' + location.port : ''
            }));
    },

    getHeader: function(name) {
        try {
            return this.transport.getResponseHeader(name) || null;
        } catch (e) { return null; }
    },

    evalResponse: function() {
        try {
            return eval((this.transport.responseText || '').unfilterJSON());
        } catch (e) {
            this.dispatchException(e);
        }
    },

    dispatchException: function(exception) {
        (this.options.onException || Prototype.emptyFunction)(this, exception);
        Ajax.Responders.dispatch('onException', this, exception);
    }
});

Ajax.Request.Events =
    ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];








Ajax.Response = Class.create({
    initialize: function(request){
        this.request = request;
        var transport  = this.transport  = request.transport,
            readyState = this.readyState = transport.readyState;

        if ((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
            this.status       = this.getStatus();
            this.statusText   = this.getStatusText();
            this.responseText = String.interpret(transport.responseText);
            this.headerJSON   = this._getHeaderJSON();
        }

        if (readyState == 4) {
            var xml = transport.responseXML;
            this.responseXML  = Object.isUndefined(xml) ? null : xml;
            this.responseJSON = this._getResponseJSON();
        }
    },

    status:      0,

    statusText: '',

    getStatus: Ajax.Request.prototype.getStatus,

    getStatusText: function() {
        try {
            return this.transport.statusText || '';
        } catch (e) { return '' }
    },

    getHeader: Ajax.Request.prototype.getHeader,

    getAllHeaders: function() {
        try {
            return this.getAllResponseHeaders();
        } catch (e) { return null }
    },

    getResponseHeader: function(name) {
        return this.transport.getResponseHeader(name);
    },

    getAllResponseHeaders: function() {
        return this.transport.getAllResponseHeaders();
    },

    _getHeaderJSON: function() {
        var json = this.getHeader('X-JSON');
        if (!json) return null;

        try {
            json = decodeURIComponent(escape(json));
        } catch(e) {
        }

        try {
            return json.evalJSON(this.request.options.sanitizeJSON ||
                !this.request.isSameOrigin());
        } catch (e) {
            this.request.dispatchException(e);
        }
    },

    _getResponseJSON: function() {
        var options = this.request.options;
        if (!options.evalJSON || (options.evalJSON != 'force' &&
            !(this.getHeader('Content-type') || '').include('application/json')) ||
            this.responseText.blank())
            return null;
        try {
            return this.responseText.evalJSON(options.sanitizeJSON ||
                !this.request.isSameOrigin());
        } catch (e) {
            this.request.dispatchException(e);
        }
    }
});

Ajax.Updater = Class.create(Ajax.Request, {
    initialize: function($super, container, url, options) {
        this.container = {
            success: (container.success || container),
            failure: (container.failure || (container.success ? null : container))
        };

        options = Object.clone(options);
        var onComplete = options.onComplete;
        options.onComplete = (function(response, json) {
            this.updateContent(response.responseText);
            if (Object.isFunction(onComplete)) onComplete(response, json);
        }).bind(this);

        $super(url, options);
    },

    updateContent: function(responseText) {
        var receiver = this.container[this.success() ? 'success' : 'failure'],
            options = this.options;

        if (!options.evalScripts) responseText = responseText.stripScripts();

        if (receiver = $(receiver)) {
            if (options.insertion) {
                if (Object.isString(options.insertion)) {
                    var insertion = { }; insertion[options.insertion] = responseText;
                    receiver.insert(insertion);
                }
                else options.insertion(receiver, responseText);
            }
            else receiver.update(responseText);
        }
    }
});

Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
    initialize: function($super, container, url, options) {
        $super(options);
        this.onComplete = this.options.onComplete;

        this.frequency = (this.options.frequency || 2);
        this.decay = (this.options.decay || 1);

        this.updater = { };
        this.container = container;
        this.url = url;

        this.start();
    },

    start: function() {
        this.options.onComplete = this.updateComplete.bind(this);
        this.onTimerEvent();
    },

    stop: function() {
        this.updater.options.onComplete = undefined;
        clearTimeout(this.timer);
        (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
    },

    updateComplete: function(response) {
        if (this.options.decay) {
            this.decay = (response.responseText == this.lastText ?
            this.decay * this.options.decay : 1);

            this.lastText = response.responseText;
        }
        this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
    },

    onTimerEvent: function() {
        this.updater = new Ajax.Updater(this.container, this.url, this.options);
    }
});

(function(GLOBAL) {

    var UNDEFINED;
    var SLICE = Array.prototype.slice;

    var DIV = document.createElement('div');


    function $(element) {
        if (arguments.length > 1) {
            for (var i = 0, elements = [], length = arguments.length; i < length; i++)
                elements.push($(arguments[i]));
            return elements;
        }

        if (Object.isString(element))
            element = document.getElementById(element);
        return Element.extend(element);
    }

    GLOBAL.$ = $;


    if (!GLOBAL.Node) GLOBAL.Node = {};

    if (!GLOBAL.Node.ELEMENT_NODE) {
        Object.extend(GLOBAL.Node, {
            ELEMENT_NODE:                1,
            ATTRIBUTE_NODE:              2,
            TEXT_NODE:                   3,
            CDATA_SECTION_NODE:          4,
            ENTITY_REFERENCE_NODE:       5,
            ENTITY_NODE:                 6,
            PROCESSING_INSTRUCTION_NODE: 7,
            COMMENT_NODE:                8,
            DOCUMENT_NODE:               9,
            DOCUMENT_TYPE_NODE:         10,
            DOCUMENT_FRAGMENT_NODE:     11,
            NOTATION_NODE:              12
        });
    }

    var ELEMENT_CACHE = {};

    function shouldUseCreationCache(tagName, attributes) {
        if (tagName === 'select') return false;
        if ('type' in attributes) return false;
        return true;
    }

    var HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = (function(){
        try {
            var el = document.createElement('<input name="x">');
            return el.tagName.toLowerCase() === 'input' && el.name === 'x';
        }
        catch(err) {
            return false;
        }
    })();


    var oldElement = GLOBAL.Element;
    function Element(tagName, attributes) {
        attributes = attributes || {};
        tagName = tagName.toLowerCase();

        if (HAS_EXTENDED_CREATE_ELEMENT_SYNTAX && attributes.name) {
            tagName = '<' + tagName + ' name="' + attributes.name + '">';
            delete attributes.name;
            return Element.writeAttribute(document.createElement(tagName), attributes);
        }

        if (!ELEMENT_CACHE[tagName])
            ELEMENT_CACHE[tagName] = Element.extend(document.createElement(tagName));

        var node = shouldUseCreationCache(tagName, attributes) ?
            ELEMENT_CACHE[tagName].cloneNode(false) : document.createElement(tagName);

        return Element.writeAttribute(node, attributes);
    }

    GLOBAL.Element = Element;

    Object.extend(GLOBAL.Element, oldElement || {});
    if (oldElement) GLOBAL.Element.prototype = oldElement.prototype;

    Element.Methods = { ByTag: {}, Simulated: {} };

    var methods = {};

    var INSPECT_ATTRIBUTES = { id: 'id', className: 'class' };
    function inspect(element) {
        element = $(element);
        var result = '<' + element.tagName.toLowerCase();

        var attribute, value;
        for (var property in INSPECT_ATTRIBUTES) {
            attribute = INSPECT_ATTRIBUTES[property];
            value = (element[property] || '').toString();
            if (value) result += ' ' + attribute + '=' + value.inspect(true);
        }

        return result + '>';
    }

    methods.inspect = inspect;


    function visible(element) {
        return $(element).style.display !== 'none';
    }

    function toggle(element, bool) {
        element = $(element);
        if (Object.isUndefined(bool))
            bool = !Element.visible(element);
        Element[bool ? 'show' : 'hide'](element);

        return element;
    }

    function hide(element) {
        element = $(element);
        element.style.display = 'none';
        return element;
    }

    function show(element) {
        element = $(element);
        element.style.display = '';
        return element;
    }


    Object.extend(methods, {
        visible: visible,
        toggle:  toggle,
        hide:    hide,
        show:    show
    });


    function remove(element) {
        element = $(element);
        element.parentNode.removeChild(element);
        return element;
    }

    var SELECT_ELEMENT_INNERHTML_BUGGY = (function(){
        var el = document.createElement("select"),
            isBuggy = true;
        el.innerHTML = "<option value=\"test\">test</option>";
        if (el.options && el.options[0]) {
            isBuggy = el.options[0].nodeName.toUpperCase() !== "OPTION";
        }
        el = null;
        return isBuggy;
    })();

    var TABLE_ELEMENT_INNERHTML_BUGGY = (function(){
        try {
            var el = document.createElement("table");
            if (el && el.tBodies) {
                el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
                var isBuggy = typeof el.tBodies[0] == "undefined";
                el = null;
                return isBuggy;
            }
        } catch (e) {
            return true;
        }
    })();

    var LINK_ELEMENT_INNERHTML_BUGGY = (function() {
        try {
            var el = document.createElement('div');
            el.innerHTML = "<link />";
            var isBuggy = (el.childNodes.length === 0);
            el = null;
            return isBuggy;
        } catch(e) {
            return true;
        }
    })();

    var ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY ||
        TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY;

    var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
        var s = document.createElement("script"),
            isBuggy = false;
        try {
            s.appendChild(document.createTextNode(""));
            isBuggy = !s.firstChild ||
                s.firstChild && s.firstChild.nodeType !== 3;
        } catch (e) {
            isBuggy = true;
        }
        s = null;
        return isBuggy;
    })();

    function update(element, content) {
        element = $(element);

        var descendants = element.getElementsByTagName('*'),
            i = descendants.length;
        while (i--) purgeElement(descendants[i]);

        if (content && content.toElement)
            content = content.toElement();

        if (Object.isElement(content))
            return element.update().insert(content);


        content = Object.toHTML(content);
        var tagName = element.tagName.toUpperCase();

        if (tagName === 'SCRIPT' && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
            element.text = content;
            return element;
        }

        if (ANY_INNERHTML_BUGGY) {
            if (tagName in INSERTION_TRANSLATIONS.tags) {
                while (element.firstChild)
                    element.removeChild(element.firstChild);

                var nodes = getContentFromAnonymousElement(tagName, content.stripScripts());
                for (var i = 0, node; node = nodes[i]; i++)
                    element.appendChild(node);

            } else if (LINK_ELEMENT_INNERHTML_BUGGY && Object.isString(content) && content.indexOf('<link') > -1) {
                while (element.firstChild)
                    element.removeChild(element.firstChild);

                var nodes = getContentFromAnonymousElement(tagName,
                    content.stripScripts(), true);

                for (var i = 0, node; node = nodes[i]; i++)
                    element.appendChild(node);
            } else {
                element.innerHTML = content.stripScripts();
            }
        } else {
            element.innerHTML = content.stripScripts();
        }

        content.evalScripts.bind(content).defer();
        return element;
    }

    function replace(element, content) {
        element = $(element);

        if (content && content.toElement) {
            content = content.toElement();
        } else if (!Object.isElement(content)) {
            content = Object.toHTML(content);
            var range = element.ownerDocument.createRange();
            range.selectNode(element);
            content.evalScripts.bind(content).defer();
            content = range.createContextualFragment(content.stripScripts());
        }

        element.parentNode.replaceChild(content, element);
        return element;
    }

    var INSERTION_TRANSLATIONS = {
        before: function(element, node) {
            element.parentNode.insertBefore(node, element);
        },
        top: function(element, node) {
            element.insertBefore(node, element.firstChild);
        },
        bottom: function(element, node) {
            element.appendChild(node);
        },
        after: function(element, node) {
            element.parentNode.insertBefore(node, element.nextSibling);
        },

        tags: {
            TABLE:  ['<table>',                '</table>',                   1],
            TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
            TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
            TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
            SELECT: ['<select>',               '</select>',                  1]
        }
    };

    var tags = INSERTION_TRANSLATIONS.tags;

    Object.extend(tags, {
        THEAD: tags.TBODY,
        TFOOT: tags.TBODY,
        TH:    tags.TD
    });

    function replace_IE(element, content) {
        element = $(element);
        if (content && content.toElement)
            content = content.toElement();
        if (Object.isElement(content)) {
            element.parentNode.replaceChild(content, element);
            return element;
        }

        content = Object.toHTML(content);
        var parent = element.parentNode, tagName = parent.tagName.toUpperCase();

        if (tagName in INSERTION_TRANSLATIONS.tags) {
            var nextSibling = Element.next(element);
            var fragments = getContentFromAnonymousElement(
                tagName, content.stripScripts());

            parent.removeChild(element);

            var iterator;
            if (nextSibling)
                iterator = function(node) { parent.insertBefore(node, nextSibling) };
            else
                iterator = function(node) { parent.appendChild(node); }

            fragments.each(iterator);
        } else {
            element.outerHTML = content.stripScripts();
        }

        content.evalScripts.bind(content).defer();
        return element;
    }

    if ('outerHTML' in document.documentElement)
        replace = replace_IE;

    function isContent(content) {
        if (Object.isUndefined(content) || content === null) return false;

        if (Object.isString(content) || Object.isNumber(content)) return true;
        if (Object.isElement(content)) return true;
        if (content.toElement || content.toHTML) return true;

        return false;
    }

    function insertContentAt(element, content, position) {
        position   = position.toLowerCase();
        var method = INSERTION_TRANSLATIONS[position];

        if (content && content.toElement) content = content.toElement();
        if (Object.isElement(content)) {
            method(element, content);
            return element;
        }

        content = Object.toHTML(content);
        var tagName = ((position === 'before' || position === 'after') ?
            element.parentNode : element).tagName.toUpperCase();

        var childNodes = getContentFromAnonymousElement(tagName, content.stripScripts());

        if (position === 'top' || position === 'after') childNodes.reverse();

        for (var i = 0, node; node = childNodes[i]; i++)
            method(element, node);

        content.evalScripts.bind(content).defer();
    }

    function insert(element, insertions) {
        element = $(element);

        if (isContent(insertions))
            insertions = { bottom: insertions };

        for (var position in insertions)
            insertContentAt(element, insertions[position], position);

        return element;
    }

    function wrap(element, wrapper, attributes) {
        element = $(element);

        if (Object.isElement(wrapper)) {
            $(wrapper).writeAttribute(attributes || {});
        } else if (Object.isString(wrapper)) {
            wrapper = new Element(wrapper, attributes);
        } else {
            wrapper = new Element('div', wrapper);
        }

        if (element.parentNode)
            element.parentNode.replaceChild(wrapper, element);

        wrapper.appendChild(element);

        return wrapper;
    }

    function cleanWhitespace(element) {
        element = $(element);
        var node = element.firstChild;

        while (node) {
            var nextNode = node.nextSibling;
            if (node.nodeType === Node.TEXT_NODE && !/\S/.test(node.nodeValue))
                element.removeChild(node);
            node = nextNode;
        }
        return element;
    }

    function empty(element) {
        return $(element).innerHTML.blank();
    }

    function getContentFromAnonymousElement(tagName, html, force) {
        var t = INSERTION_TRANSLATIONS.tags[tagName], div = DIV;

        var workaround = !!t;
        if (!workaround && force) {
            workaround = true;
            t = ['', '', 0];
        }

        if (workaround) {
            div.innerHTML = '&#160;' + t[0] + html + t[1];
            div.removeChild(div.firstChild);
            for (var i = t[2]; i--; )
                div = div.firstChild;
        } else {
            div.innerHTML = html;
        }

        return $A(div.childNodes);
    }

    function clone(element, deep) {
        if (!(element = $(element))) return;
        var clone = element.cloneNode(deep);
        if (!HAS_UNIQUE_ID_PROPERTY) {
            clone._prototypeUID = UNDEFINED;
            if (deep) {
                var descendants = Element.select(clone, '*'),
                    i = descendants.length;
                while (i--)
                    descendants[i]._prototypeUID = UNDEFINED;
            }
        }
        return Element.extend(clone);
    }

    function purgeElement(element) {
        var uid = getUniqueElementID(element);
        if (uid) {
            Element.stopObserving(element);
            if (!HAS_UNIQUE_ID_PROPERTY)
                element._prototypeUID = UNDEFINED;
            delete Element.Storage[uid];
        }
    }

    function purgeCollection(elements) {
        var i = elements.length;
        while (i--)
            purgeElement(elements[i]);
    }

    function purgeCollection_IE(elements) {
        var i = elements.length, element, uid;
        while (i--) {
            element = elements[i];
            uid = getUniqueElementID(element);
            delete Element.Storage[uid];
            delete Event.cache[uid];
        }
    }

    if (HAS_UNIQUE_ID_PROPERTY) {
        purgeCollection = purgeCollection_IE;
    }


    function purge(element) {
        if (!(element = $(element))) return;
        purgeElement(element);

        var descendants = element.getElementsByTagName('*'),
            i = descendants.length;

        while (i--) purgeElement(descendants[i]);

        return null;
    }

    Object.extend(methods, {
        remove:  remove,
        update:  update,
        replace: replace,
        insert:  insert,
        wrap:    wrap,
        cleanWhitespace: cleanWhitespace,
        empty:   empty,
        clone:   clone,
        purge:   purge
    });



    function recursivelyCollect(element, property, maximumLength) {
        element = $(element);
        maximumLength = maximumLength || -1;
        var elements = [];

        while (element = element[property]) {
            if (element.nodeType === Node.ELEMENT_NODE)
                elements.push(Element.extend(element));

            if (elements.length === maximumLength) break;
        }

        return elements;
    }


    function ancestors(element) {
        return recursivelyCollect(element, 'parentNode');
    }

    function descendants(element) {
        return Element.select(element, '*');
    }

    function firstDescendant(element) {
        element = $(element).firstChild;
        while (element && element.nodeType !== Node.ELEMENT_NODE)
            element = element.nextSibling;

        return $(element);
    }

    function immediateDescendants(element) {
        var results = [], child = $(element).firstChild;

        while (child) {
            if (child.nodeType === Node.ELEMENT_NODE)
                results.push(Element.extend(child));

            child = child.nextSibling;
        }

        return results;
    }

    function previousSiblings(element) {
        return recursivelyCollect(element, 'previousSibling');
    }

    function nextSiblings(element) {
        return recursivelyCollect(element, 'nextSibling');
    }

    function siblings(element) {
        element = $(element);
        var previous = previousSiblings(element),
            next = nextSiblings(element);
        return previous.reverse().concat(next);
    }

    function match(element, selector) {
        element = $(element);

        if (Object.isString(selector))
            return Prototype.Selector.match(element, selector);

        return selector.match(element);
    }


    function _recursivelyFind(element, property, expression, index) {
        element = $(element), expression = expression || 0, index = index || 0;
        if (Object.isNumber(expression)) {
            index = expression, expression = null;
        }

        while (element = element[property]) {
            if (element.nodeType !== 1) continue;
            if (expression && !Prototype.Selector.match(element, expression))
                continue;
            if (--index >= 0) continue;

            return Element.extend(element);
        }
    }


    function up(element, expression, index) {
        element = $(element);

        if (arguments.length === 1) return $(element.parentNode);
        return _recursivelyFind(element, 'parentNode', expression, index);
    }

    function down(element, expression, index) {
        if (arguments.length === 1) return firstDescendant(element);
        element = $(element), expression = expression || 0, index = index || 0;

        if (Object.isNumber(expression))
            index = expression, expression = '*';

        var node = Prototype.Selector.select(expression, element)[index];
        return Element.extend(node);
    }

    function previous(element, expression, index) {
        return _recursivelyFind(element, 'previousSibling', expression, index);
    }

    function next(element, expression, index) {
        return _recursivelyFind(element, 'nextSibling', expression, index);
    }

    function select(element) {
        element = $(element);
        var expressions = SLICE.call(arguments, 1).join(', ');
        return Prototype.Selector.select(expressions, element);
    }

    function adjacent(element) {
        element = $(element);
        var expressions = SLICE.call(arguments, 1).join(', ');
        var siblings = Element.siblings(element), results = [];
        for (var i = 0, sibling; sibling = siblings[i]; i++) {
            if (Prototype.Selector.match(sibling, expressions))
                results.push(sibling);
        }

        return results;
    }

    function descendantOf_DOM(element, ancestor) {
        element = $(element), ancestor = $(ancestor);
        while (element = element.parentNode)
            if (element === ancestor) return true;
        return false;
    }

    function descendantOf_contains(element, ancestor) {
        element = $(element), ancestor = $(ancestor);
        if (!ancestor.contains) return descendantOf_DOM(element, ancestor);
        return ancestor.contains(element) && ancestor !== element;
    }

    function descendantOf_compareDocumentPosition(element, ancestor) {
        element = $(element), ancestor = $(ancestor);
        return (element.compareDocumentPosition(ancestor) & 8) === 8;
    }

    var descendantOf;
    if (DIV.compareDocumentPosition) {
        descendantOf = descendantOf_compareDocumentPosition;
    } else if (DIV.contains) {
        descendantOf = descendantOf_contains;
    } else {
        descendantOf = descendantOf_DOM;
    }


    Object.extend(methods, {
        recursivelyCollect:   recursivelyCollect,
        ancestors:            ancestors,
        descendants:          descendants,
        firstDescendant:      firstDescendant,
        immediateDescendants: immediateDescendants,
        previousSiblings:     previousSiblings,
        nextSiblings:         nextSiblings,
        siblings:             siblings,
        match:                match,
        up:                   up,
        down:                 down,
        previous:             previous,
        next:                 next,
        select:               select,
        adjacent:             adjacent,
        descendantOf:         descendantOf,

        getElementsBySelector: select,

        childElements:         immediateDescendants
    });


    var idCounter = 1;
    function identify(element) {
        element = $(element);
        var id = Element.readAttribute(element, 'id');
        if (id) return id;

        do { id = 'anonymous_element_' + idCounter++ } while ($(id));

        Element.writeAttribute(element, 'id', id);
        return id;
    }


    function readAttribute(element, name) {
        return $(element).getAttribute(name);
    }

    function readAttribute_IE(element, name) {
        element = $(element);

        var table = ATTRIBUTE_TRANSLATIONS.read;
        if (table.values[name])
            return table.values[name](element, name);

        if (table.names[name]) name = table.names[name];

        if (name.include(':')) {
            if (!element.attributes || !element.attributes[name]) return null;
            return element.attributes[name].value;
        }

        return element.getAttribute(name);
    }

    function readAttribute_Opera(element, name) {
        if (name === 'title') return element.title;
        return element.getAttribute(name);
    }

    var PROBLEMATIC_ATTRIBUTE_READING = (function() {
        DIV.setAttribute('onclick', []);
        var value = DIV.getAttribute('onclick');
        var isFunction = Object.isArray(value);
        DIV.removeAttribute('onclick');
        return isFunction;
    })();

    if (PROBLEMATIC_ATTRIBUTE_READING) {
        readAttribute = readAttribute_IE;
    } else if (Prototype.Browser.Opera) {
        readAttribute = readAttribute_Opera;
    }


    function writeAttribute(element, name, value) {
        element = $(element);
        var attributes = {}, table = ATTRIBUTE_TRANSLATIONS.write;

        if (typeof name === 'object') {
            attributes = name;
        } else {
            attributes[name] = Object.isUndefined(value) ? true : value;
        }

        for (var attr in attributes) {
            name = table.names[attr] || attr;
            value = attributes[attr];
            if (table.values[attr])
                name = table.values[attr](element, value) || name;
            if (value === false || value === null)
                element.removeAttribute(name);
            else if (value === true)
                element.setAttribute(name, name);
            else element.setAttribute(name, value);
        }

        return element;
    }

    var PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES = (function () {
        if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) {
            return false;
        }
        var checkbox = document.createElement('<input type="checkbox">');
        checkbox.checked = true;
        var node = checkbox.getAttributeNode('checked');
        return !node || !node.specified;
    })();

    function hasAttribute(element, attribute) {
        attribute = ATTRIBUTE_TRANSLATIONS.has[attribute] || attribute;
        var node = $(element).getAttributeNode(attribute);
        return !!(node && node.specified);
    }

    function hasAttribute_IE(element, attribute) {
        if (attribute === 'checked') {
            return element.checked;
        }
        return hasAttribute(element, attribute);
    }

    GLOBAL.Element.Methods.Simulated.hasAttribute =
        PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES ?
            hasAttribute_IE : hasAttribute;

    function classNames(element) {
        return new Element.ClassNames(element);
    }

    var regExpCache = {};
    function getRegExpForClassName(className) {
        if (regExpCache[className]) return regExpCache[className];

        var re = new RegExp("(^|\\s+)" + className + "(\\s+|$)");
        regExpCache[className] = re;
        return re;
    }

    function hasClassName(element, className) {
        if (!(element = $(element))) return;

        var elementClassName = element.className;

        if (elementClassName.length === 0) return false;
        if (elementClassName === className) return true;

        return getRegExpForClassName(className).test(elementClassName);
    }

    function addClassName(element, className) {
        if (!(element = $(element))) return;

        if (!hasClassName(element, className))
            element.className += (element.className ? ' ' : '') + className;

        return element;
    }

    function removeClassName(element, className) {
        if (!(element = $(element))) return;

        element.className = element.className.replace(
            getRegExpForClassName(className), ' ').strip();

        return element;
    }

    function toggleClassName(element, className, bool) {
        if (!(element = $(element))) return;

        if (Object.isUndefined(bool))
            bool = !hasClassName(element, className);

        var method = Element[bool ? 'addClassName' : 'removeClassName'];
        return method(element, className);
    }

    var ATTRIBUTE_TRANSLATIONS = {};

    var classProp = 'className', forProp = 'for';

    DIV.setAttribute(classProp, 'x');
    if (DIV.className !== 'x') {
        DIV.setAttribute('class', 'x');
        if (DIV.className === 'x')
            classProp = 'class';
    }

    var LABEL = document.createElement('label');
    LABEL.setAttribute(forProp, 'x');
    if (LABEL.htmlFor !== 'x') {
        LABEL.setAttribute('htmlFor', 'x');
        if (LABEL.htmlFor === 'x')
            forProp = 'htmlFor';
    }
    LABEL = null;

    function _getAttr(element, attribute) {
        return element.getAttribute(attribute);
    }

    function _getAttr2(element, attribute) {
        return element.getAttribute(attribute, 2);
    }

    function _getAttrNode(element, attribute) {
        var node = element.getAttributeNode(attribute);
        return node ? node.value : '';
    }

    function _getFlag(element, attribute) {
        return $(element).hasAttribute(attribute) ? attribute : null;
    }

    DIV.onclick = Prototype.emptyFunction;
    var onclickValue = DIV.getAttribute('onclick');

    var _getEv;

    if (String(onclickValue).indexOf('{') > -1) {
        _getEv = function(element, attribute) {
            var value = element.getAttribute(attribute);
            if (!value) return null;
            value = value.toString();
            value = value.split('{')[1];
            value = value.split('}')[0];
            return value.strip();
        };
    }
    else if (onclickValue === '') {
        _getEv = function(element, attribute) {
            var value = element.getAttribute(attribute);
            if (!value) return null;
            return value.strip();
        };
    }

    ATTRIBUTE_TRANSLATIONS.read = {
        names: {
            'class':     classProp,
            'className': classProp,
            'for':       forProp,
            'htmlFor':   forProp
        },

        values: {
            style: function(element) {
                return element.style.cssText.toLowerCase();
            },
            title: function(element) {
                return element.title;
            }
        }
    };

    ATTRIBUTE_TRANSLATIONS.write = {
        names: {
            className:   'class',
            htmlFor:     'for',
            cellpadding: 'cellPadding',
            cellspacing: 'cellSpacing'
        },

        values: {
            checked: function(element, value) {
                element.checked = !!value;
            },

            style: function(element, value) {
                element.style.cssText = value ? value : '';
            }
        }
    };

    ATTRIBUTE_TRANSLATIONS.has = { names: {} };

    Object.extend(ATTRIBUTE_TRANSLATIONS.write.names,
        ATTRIBUTE_TRANSLATIONS.read.names);

    var CAMEL_CASED_ATTRIBUTE_NAMES = $w('colSpan rowSpan vAlign dateTime ' +
        'accessKey tabIndex encType maxLength readOnly longDesc frameBorder');

    for (var i = 0, attr; attr = CAMEL_CASED_ATTRIBUTE_NAMES[i]; i++) {
        ATTRIBUTE_TRANSLATIONS.write.names[attr.toLowerCase()] = attr;
        ATTRIBUTE_TRANSLATIONS.has.names[attr.toLowerCase()]   = attr;
    }

    Object.extend(ATTRIBUTE_TRANSLATIONS.read.values, {
        href:        _getAttr2,
        src:         _getAttr2,
        type:        _getAttr,
        action:      _getAttrNode,
        disabled:    _getFlag,
        checked:     _getFlag,
        readonly:    _getFlag,
        multiple:    _getFlag,
        onload:      _getEv,
        onunload:    _getEv,
        onclick:     _getEv,
        ondblclick:  _getEv,
        onmousedown: _getEv,
        onmouseup:   _getEv,
        onmouseover: _getEv,
        onmousemove: _getEv,
        onmouseout:  _getEv,
        onfocus:     _getEv,
        onblur:      _getEv,
        onkeypress:  _getEv,
        onkeydown:   _getEv,
        onkeyup:     _getEv,
        onsubmit:    _getEv,
        onreset:     _getEv,
        onselect:    _getEv,
        onchange:    _getEv
    });


    Object.extend(methods, {
        identify:        identify,
        readAttribute:   readAttribute,
        writeAttribute:  writeAttribute,
        classNames:      classNames,
        hasClassName:    hasClassName,
        addClassName:    addClassName,
        removeClassName: removeClassName,
        toggleClassName: toggleClassName
    });


    function normalizeStyleName(style) {
        if (style === 'float' || style === 'styleFloat')
            return 'cssFloat';
        return style.camelize();
    }

    function normalizeStyleName_IE(style) {
        if (style === 'float' || style === 'cssFloat')
            return 'styleFloat';
        return style.camelize();
    }

    function setStyle(element, styles) {
        element = $(element);
        var elementStyle = element.style, match;

        if (Object.isString(styles)) {
            elementStyle.cssText += ';' + styles;
            if (styles.include('opacity')) {
                var opacity = styles.match(/opacity:\s*(\d?\.?\d*)/)[1];
                Element.setOpacity(element, opacity);
            }
            return element;
        }

        for (var property in styles) {
            if (property === 'opacity') {
                Element.setOpacity(element, styles[property]);
            } else {
                var value = styles[property];
                if (property === 'float' || property === 'cssFloat') {
                    property = Object.isUndefined(elementStyle.styleFloat) ?
                        'cssFloat' : 'styleFloat';
                }
                elementStyle[property] = value;
            }
        }

        return element;
    }


    function getStyle(element, style) {
        element = $(element);
        style = normalizeStyleName(style);

        var value = element.style[style];
        if (!value || value === 'auto') {
            var css = document.defaultView.getComputedStyle(element, null);
            value = css ? css[style] : null;
        }

        if (style === 'opacity') return value ? parseFloat(value) : 1.0;
        return value === 'auto' ? null : value;
    }

    function getStyle_Opera(element, style) {
        switch (style) {
            case 'height': case 'width':
            if (!Element.visible(element)) return null;

            var dim = parseInt(getStyle(element, style), 10);

            if (dim !== element['offset' + style.capitalize()])
                return dim + 'px';

            return Element.measure(element, style);

            default: return getStyle(element, style);
        }
    }

    function getStyle_IE(element, style) {
        element = $(element);
        style = normalizeStyleName_IE(style);

        var value = element.style[style];
        if (!value && element.currentStyle) {
            value = element.currentStyle[style];
        }

        if (style === 'opacity' && !STANDARD_CSS_OPACITY_SUPPORTED)
            return getOpacity_IE(element);

        if (value === 'auto') {
            if ((style === 'width' || style === 'height') && Element.visible(element))
                return Element.measure(element, style) + 'px';
            return null;
        }

        return value;
    }

    function stripAlphaFromFilter_IE(filter) {
        return (filter || '').replace(/alpha\([^\)]*\)/gi, '');
    }

    function hasLayout_IE(element) {
        if (!element.currentStyle || !element.currentStyle.hasLayout)
            element.style.zoom = 1;
        return element;
    }

    var STANDARD_CSS_OPACITY_SUPPORTED = (function() {
        DIV.style.cssText = "opacity:.55";
        return /^0.55/.test(DIV.style.opacity);
    })();

    function setOpacity(element, value) {
        element = $(element);
        if (value == 1 || value === '') value = '';
        else if (value < 0.00001) value = 0;
        element.style.opacity = value;
        return element;
    }

    function setOpacity_IE(element, value) {
        if (STANDARD_CSS_OPACITY_SUPPORTED)
            return setOpacity(element, value);

        element = hasLayout_IE($(element));
        var filter = Element.getStyle(element, 'filter'),
            style = element.style;

        if (value == 1 || value === '') {
            filter = stripAlphaFromFilter_IE(filter);
            if (filter) style.filter = filter;
            else style.removeAttribute('filter');
            return element;
        }

        if (value < 0.00001) value = 0;

        style.filter = stripAlphaFromFilter_IE(filter) +
            'alpha(opacity=' + (value * 100) + ')';

        return element;
    }


    function getOpacity(element) {
        return Element.getStyle(element, 'opacity');
    }

    function getOpacity_IE(element) {
        if (STANDARD_CSS_OPACITY_SUPPORTED)
            return getOpacity(element);

        var filter = Element.getStyle(element, 'filter');
        if (filter.length === 0) return 1.0;
        var match = (filter || '').match(/alpha\(opacity=(.*)\)/);
        if (match && match[1]) return parseFloat(match[1]) / 100;
        return 1.0;
    }


    Object.extend(methods, {
        setStyle:   setStyle,
        getStyle:   getStyle,
        setOpacity: setOpacity,
        getOpacity: getOpacity
    });

    if ('styleFloat' in DIV.style) {
        methods.getStyle = getStyle_IE;
        methods.setOpacity = setOpacity_IE;
        methods.getOpacity = getOpacity_IE;
    }

    var UID = 0;

    GLOBAL.Element.Storage = { UID: 1 };

    function getUniqueElementID(element) {
        if (element === window) return 0;

        if (typeof element._prototypeUID === 'undefined')
            element._prototypeUID = Element.Storage.UID++;
        return element._prototypeUID;
    }

    function getUniqueElementID_IE(element) {
        if (element === window) return 0;
        if (element == document) return 1;
        return element.uniqueID;
    }

    var HAS_UNIQUE_ID_PROPERTY = ('uniqueID' in DIV);
    if (HAS_UNIQUE_ID_PROPERTY)
        getUniqueElementID = getUniqueElementID_IE;

    function getStorage(element) {
        if (!(element = $(element))) return;

        var uid = getUniqueElementID(element);

        if (!Element.Storage[uid])
            Element.Storage[uid] = $H();

        return Element.Storage[uid];
    }

    function store(element, key, value) {
        if (!(element = $(element))) return;
        var storage = getStorage(element);
        if (arguments.length === 2) {
            storage.update(key);
        } else {
            storage.set(key, value);
        }
        return element;
    }

    function retrieve(element, key, defaultValue) {
        if (!(element = $(element))) return;
        var storage = getStorage(element), value = storage.get(key);

        if (Object.isUndefined(value)) {
            storage.set(key, defaultValue);
            value = defaultValue;
        }

        return value;
    }


    Object.extend(methods, {
        getStorage: getStorage,
        store:      store,
        retrieve:   retrieve
    });


    var Methods = {}, ByTag = Element.Methods.ByTag,
        F = Prototype.BrowserFeatures;

    if (!F.ElementExtensions && ('__proto__' in DIV)) {
        GLOBAL.HTMLElement = {};
        GLOBAL.HTMLElement.prototype = DIV['__proto__'];
        F.ElementExtensions = true;
    }

    function checkElementPrototypeDeficiency(tagName) {
        if (typeof window.Element === 'undefined') return false;
        if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) return false;
        var proto = window.Element.prototype;
        if (proto) {
            var id = '_' + (Math.random() + '').slice(2),
                el = document.createElement(tagName);
            proto[id] = 'x';
            var isBuggy = (el[id] !== 'x');
            delete proto[id];
            el = null;
            return isBuggy;
        }

        return false;
    }

    var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY =
        checkElementPrototypeDeficiency('object');

    function extendElementWith(element, methods) {
        for (var property in methods) {
            var value = methods[property];
            if (Object.isFunction(value) && !(property in element))
                element[property] = value.methodize();
        }
    }

    var EXTENDED = {};
    function elementIsExtended(element) {
        var uid = getUniqueElementID(element);
        return (uid in EXTENDED);
    }

    function extend(element) {
        if (!element || elementIsExtended(element)) return element;
        if (element.nodeType !== Node.ELEMENT_NODE || element == window)
            return element;

        var methods = Object.clone(Methods),
            tagName = element.tagName.toUpperCase();

        if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);

        extendElementWith(element, methods);
        EXTENDED[getUniqueElementID(element)] = true;
        return element;
    }

    function extend_IE8(element) {
        if (!element || elementIsExtended(element)) return element;

        var t = element.tagName;
        if (t && (/^(?:object|applet|embed)$/i.test(t))) {
            extendElementWith(element, Element.Methods);
            extendElementWith(element, Element.Methods.Simulated);
            extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);
        }

        return element;
    }

    if (F.SpecificElementExtensions) {
        extend = HTMLOBJECTELEMENT_PROTOTYPE_BUGGY ? extend_IE8 : Prototype.K;
    }

    function addMethodsToTagName(tagName, methods) {
        tagName = tagName.toUpperCase();
        if (!ByTag[tagName]) ByTag[tagName] = {};
        Object.extend(ByTag[tagName], methods);
    }

    function mergeMethods(destination, methods, onlyIfAbsent) {
        if (Object.isUndefined(onlyIfAbsent)) onlyIfAbsent = false;
        for (var property in methods) {
            var value = methods[property];
            if (!Object.isFunction(value)) continue;
            if (!onlyIfAbsent || !(property in destination))
                destination[property] = value.methodize();
        }
    }

    function findDOMClass(tagName) {
        var klass;
        var trans = {
            "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
            "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
            "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
            "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
            "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
                "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
                "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
                "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
                "FrameSet", "IFRAME": "IFrame"
        };
        if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
        if (window[klass]) return window[klass];
        klass = 'HTML' + tagName + 'Element';
        if (window[klass]) return window[klass];
        klass = 'HTML' + tagName.capitalize() + 'Element';
        if (window[klass]) return window[klass];

        var element = document.createElement(tagName),
            proto = element['__proto__'] || element.constructor.prototype;

        element = null;
        return proto;
    }

    function addMethods(methods) {
        if (arguments.length === 0) addFormMethods();

        if (arguments.length === 2) {
            var tagName = methods;
            methods = arguments[1];
        }

        if (!tagName) {
            Object.extend(Element.Methods, methods || {});
        } else {
            if (Object.isArray(tagName)) {
                for (var i = 0, tag; tag = tagName[i]; i++)
                    addMethodsToTagName(tag, methods);
            } else {
                addMethodsToTagName(tagName, methods);
            }
        }

        var ELEMENT_PROTOTYPE = window.HTMLElement ? HTMLElement.prototype :
            Element.prototype;

        if (F.ElementExtensions) {
            mergeMethods(ELEMENT_PROTOTYPE, Element.Methods);
            mergeMethods(ELEMENT_PROTOTYPE, Element.Methods.Simulated, true);
        }

        if (F.SpecificElementExtensions) {
            for (var tag in Element.Methods.ByTag) {
                var klass = findDOMClass(tag);
                if (Object.isUndefined(klass)) continue;
                mergeMethods(klass.prototype, ByTag[tag]);
            }
        }

        Object.extend(Element, Element.Methods);
        Object.extend(Element, Element.Methods.Simulated);
        delete Element.ByTag;
        delete Element.Simulated;

        Element.extend.refresh();

        ELEMENT_CACHE = {};
    }

    Object.extend(GLOBAL.Element, {
        extend:     extend,
        addMethods: addMethods
    });

    if (extend === Prototype.K) {
        GLOBAL.Element.extend.refresh = Prototype.emptyFunction;
    } else {
        GLOBAL.Element.extend.refresh = function() {
            if (Prototype.BrowserFeatures.ElementExtensions) return;
            Object.extend(Methods, Element.Methods);
            Object.extend(Methods, Element.Methods.Simulated);

            EXTENDED = {};
        };
    }

    function addFormMethods() {
        Object.extend(Form, Form.Methods);
        Object.extend(Form.Element, Form.Element.Methods);
        Object.extend(Element.Methods.ByTag, {
            "FORM":     Object.clone(Form.Methods),
            "INPUT":    Object.clone(Form.Element.Methods),
            "SELECT":   Object.clone(Form.Element.Methods),
            "TEXTAREA": Object.clone(Form.Element.Methods),
            "BUTTON":   Object.clone(Form.Element.Methods)
        });
    }

    Element.addMethods(methods);

    function destroyCache_IE() {
        DIV = null;
        ELEMENT_CACHE = null;
    }

    if (window.attachEvent)
        window.attachEvent('onunload', destroyCache_IE);

})(window);
(function() {

    function toDecimal(pctString) {
        var match = pctString.match(/^(\d+)%?$/i);
        if (!match) return null;
        return (Number(match[1]) / 100);
    }

    function getRawStyle(element, style) {
        element = $(element);

        var value = element.style[style];
        if (!value || value === 'auto') {
            var css = document.defaultView.getComputedStyle(element, null);
            value = css ? css[style] : null;
        }

        if (style === 'opacity') return value ? parseFloat(value) : 1.0;
        return value === 'auto' ? null : value;
    }

    function getRawStyle_IE(element, style) {
        var value = element.style[style];
        if (!value && element.currentStyle) {
            value = element.currentStyle[style];
        }
        return value;
    }

    function getContentWidth(element, context) {
        var boxWidth = element.offsetWidth;

        var bl = getPixelValue(element, 'borderLeftWidth',  context) || 0;
        var br = getPixelValue(element, 'borderRightWidth', context) || 0;
        var pl = getPixelValue(element, 'paddingLeft',      context) || 0;
        var pr = getPixelValue(element, 'paddingRight',     context) || 0;

        return boxWidth - bl - br - pl - pr;
    }

    if ('currentStyle' in document.documentElement) {
        getRawStyle = getRawStyle_IE;
    }


    function getPixelValue(value, property, context) {
        var element = null;
        if (Object.isElement(value)) {
            element = value;
            value = getRawStyle(element, property);
        }

        if (value === null || Object.isUndefined(value)) {
            return null;
        }

        if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(value)) {
            return window.parseFloat(value);
        }

        var isPercentage = value.include('%'), isViewport = (context === document.viewport);

        if (/\d/.test(value) && element && element.runtimeStyle && !(isPercentage && isViewport)) {
            var style = element.style.left, rStyle = element.runtimeStyle.left;
            element.runtimeStyle.left = element.currentStyle.left;
            element.style.left = value || 0;
            value = element.style.pixelLeft;
            element.style.left = style;
            element.runtimeStyle.left = rStyle;

            return value;
        }

        if (element && isPercentage) {
            context = context || element.parentNode;
            var decimal = toDecimal(value), whole = null;

            var isHorizontal = property.include('left') || property.include('right') ||
                property.include('width');

            var isVertical   = property.include('top') || property.include('bottom') ||
                property.include('height');

            if (context === document.viewport) {
                if (isHorizontal) {
                    whole = document.viewport.getWidth();
                } else if (isVertical) {
                    whole = document.viewport.getHeight();
                }
            } else {
                if (isHorizontal) {
                    whole = $(context).measure('width');
                } else if (isVertical) {
                    whole = $(context).measure('height');
                }
            }

            return (whole === null) ? 0 : whole * decimal;
        }

        return 0;
    }

    function toCSSPixels(number) {
        if (Object.isString(number) && number.endsWith('px'))
            return number;
        return number + 'px';
    }

    function isDisplayed(element) {
        while (element && element.parentNode) {
            var display = element.getStyle('display');
            if (display === 'none') {
                return false;
            }
            element = $(element.parentNode);
        }
        return true;
    }

    var hasLayout = Prototype.K;
    if ('currentStyle' in document.documentElement) {
        hasLayout = function(element) {
            if (!element.currentStyle.hasLayout) {
                element.style.zoom = 1;
            }
            return element;
        };
    }

    function cssNameFor(key) {
        if (key.include('border')) key = key + '-width';
        return key.camelize();
    }

    Element.Layout = Class.create(Hash, {
        initialize: function($super, element, preCompute) {
            $super();
            this.element = $(element);

            Element.Layout.PROPERTIES.each( function(property) {
                this._set(property, null);
            }, this);

            if (preCompute) {
                this._preComputing = true;
                this._begin();
                Element.Layout.PROPERTIES.each( this._compute, this );
                this._end();
                this._preComputing = false;
            }
        },

        _set: function(property, value) {
            return Hash.prototype.set.call(this, property, value);
        },

        set: function(property, value) {
            throw "Properties of Element.Layout are read-only.";
        },

        get: function($super, property) {
            var value = $super(property);
            return value === null ? this._compute(property) : value;
        },

        _begin: function() {
            if (this._isPrepared()) return;

            var element = this.element;
            if (isDisplayed(element)) {
                this._setPrepared(true);
                return;
            }


            var originalStyles = {
                position:   element.style.position   || '',
                width:      element.style.width      || '',
                visibility: element.style.visibility || '',
                display:    element.style.display    || ''
            };

            element.store('prototype_original_styles', originalStyles);

            var position = getRawStyle(element, 'position'), width = element.offsetWidth;

            if (width === 0 || width === null) {
                element.style.display = 'block';
                width = element.offsetWidth;
            }

            var context = (position === 'fixed') ? document.viewport :
                element.parentNode;

            var tempStyles = {
                visibility: 'hidden',
                display:    'block'
            };

            if (position !== 'fixed') tempStyles.position = 'absolute';

            element.setStyle(tempStyles);

            var positionedWidth = element.offsetWidth, newWidth;
            if (width && (positionedWidth === width)) {
                newWidth = getContentWidth(element, context);
            } else if (position === 'absolute' || position === 'fixed') {
                newWidth = getContentWidth(element, context);
            } else {
                var parent = element.parentNode, pLayout = $(parent).getLayout();

                newWidth = pLayout.get('width') -
                    this.get('margin-left') -
                    this.get('border-left') -
                    this.get('padding-left') -
                    this.get('padding-right') -
                    this.get('border-right') -
                    this.get('margin-right');
            }

            element.setStyle({ width: newWidth + 'px' });

            this._setPrepared(true);
        },

        _end: function() {
            var element = this.element;
            var originalStyles = element.retrieve('prototype_original_styles');
            element.store('prototype_original_styles', null);
            element.setStyle(originalStyles);
            this._setPrepared(false);
        },

        _compute: function(property) {
            var COMPUTATIONS = Element.Layout.COMPUTATIONS;
            if (!(property in COMPUTATIONS)) {
                throw "Property not found.";
            }

            return this._set(property, COMPUTATIONS[property].call(this, this.element));
        },

        _isPrepared: function() {
            return this.element.retrieve('prototype_element_layout_prepared', false);
        },

        _setPrepared: function(bool) {
            return this.element.store('prototype_element_layout_prepared', bool);
        },

        toObject: function() {
            var args = $A(arguments);
            var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
                args.join(' ').split(' ');
            var obj = {};
            keys.each( function(key) {
                if (!Element.Layout.PROPERTIES.include(key)) return;
                var value = this.get(key);
                if (value != null) obj[key] = value;
            }, this);
            return obj;
        },

        toHash: function() {
            var obj = this.toObject.apply(this, arguments);
            return new Hash(obj);
        },

        toCSS: function() {
            var args = $A(arguments);
            var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
                args.join(' ').split(' ');
            var css = {};

            keys.each( function(key) {
                if (!Element.Layout.PROPERTIES.include(key)) return;
                if (Element.Layout.COMPOSITE_PROPERTIES.include(key)) return;

                var value = this.get(key);
                if (value != null) css[cssNameFor(key)] = value + 'px';
            }, this);
            return css;
        },

        inspect: function() {
            return "#<Element.Layout>";
        }
    });

    Object.extend(Element.Layout, {
        PROPERTIES: $w('height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height'),

        COMPOSITE_PROPERTIES: $w('padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height'),

        COMPUTATIONS: {
            'height': function(element) {
                if (!this._preComputing) this._begin();

                var bHeight = this.get('border-box-height');
                if (bHeight <= 0) {
                    if (!this._preComputing) this._end();
                    return 0;
                }

                var bTop = this.get('border-top'),
                    bBottom = this.get('border-bottom');

                var pTop = this.get('padding-top'),
                    pBottom = this.get('padding-bottom');

                if (!this._preComputing) this._end();

                return bHeight - bTop - bBottom - pTop - pBottom;
            },

            'width': function(element) {
                if (!this._preComputing) this._begin();

                var bWidth = this.get('border-box-width');
                if (bWidth <= 0) {
                    if (!this._preComputing) this._end();
                    return 0;
                }

                var bLeft = this.get('border-left'),
                    bRight = this.get('border-right');

                var pLeft = this.get('padding-left'),
                    pRight = this.get('padding-right');

                if (!this._preComputing) this._end();
                return bWidth - bLeft - bRight - pLeft - pRight;
            },

            'padding-box-height': function(element) {
                var height = this.get('height'),
                    pTop = this.get('padding-top'),
                    pBottom = this.get('padding-bottom');

                return height + pTop + pBottom;
            },

            'padding-box-width': function(element) {
                var width = this.get('width'),
                    pLeft = this.get('padding-left'),
                    pRight = this.get('padding-right');

                return width + pLeft + pRight;
            },

            'border-box-height': function(element) {
                if (!this._preComputing) this._begin();
                var height = element.offsetHeight;
                if (!this._preComputing) this._end();
                return height;
            },

            'border-box-width': function(element) {
                if (!this._preComputing) this._begin();
                var width = element.offsetWidth;
                if (!this._preComputing) this._end();
                return width;
            },

            'margin-box-height': function(element) {
                var bHeight = this.get('border-box-height'),
                    mTop = this.get('margin-top'),
                    mBottom = this.get('margin-bottom');

                if (bHeight <= 0) return 0;

                return bHeight + mTop + mBottom;
            },

            'margin-box-width': function(element) {
                var bWidth = this.get('border-box-width'),
                    mLeft = this.get('margin-left'),
                    mRight = this.get('margin-right');

                if (bWidth <= 0) return 0;

                return bWidth + mLeft + mRight;
            },

            'top': function(element) {
                var offset = element.positionedOffset();
                return offset.top;
            },

            'bottom': function(element) {
                var offset = element.positionedOffset(),
                    parent = element.getOffsetParent(),
                    pHeight = parent.measure('height');

                var mHeight = this.get('border-box-height');

                return pHeight - mHeight - offset.top;
            },

            'left': function(element) {
                var offset = element.positionedOffset();
                return offset.left;
            },

            'right': function(element) {
                var offset = element.positionedOffset(),
                    parent = element.getOffsetParent(),
                    pWidth = parent.measure('width');

                var mWidth = this.get('border-box-width');

                return pWidth - mWidth - offset.left;
            },

            'padding-top': function(element) {
                return getPixelValue(element, 'paddingTop');
            },

            'padding-bottom': function(element) {
                return getPixelValue(element, 'paddingBottom');
            },

            'padding-left': function(element) {
                return getPixelValue(element, 'paddingLeft');
            },

            'padding-right': function(element) {
                return getPixelValue(element, 'paddingRight');
            },

            'border-top': function(element) {
                return getPixelValue(element, 'borderTopWidth');
            },

            'border-bottom': function(element) {
                return getPixelValue(element, 'borderBottomWidth');
            },

            'border-left': function(element) {
                return getPixelValue(element, 'borderLeftWidth');
            },

            'border-right': function(element) {
                return getPixelValue(element, 'borderRightWidth');
            },

            'margin-top': function(element) {
                return getPixelValue(element, 'marginTop');
            },

            'margin-bottom': function(element) {
                return getPixelValue(element, 'marginBottom');
            },

            'margin-left': function(element) {
                return getPixelValue(element, 'marginLeft');
            },

            'margin-right': function(element) {
                return getPixelValue(element, 'marginRight');
            }
        }
    });

    if ('getBoundingClientRect' in document.documentElement) {
        Object.extend(Element.Layout.COMPUTATIONS, {
            'right': function(element) {
                var parent = hasLayout(element.getOffsetParent());
                var rect = element.getBoundingClientRect(),
                    pRect = parent.getBoundingClientRect();

                return (pRect.right - rect.right).round();
            },

            'bottom': function(element) {
                var parent = hasLayout(element.getOffsetParent());
                var rect = element.getBoundingClientRect(),
                    pRect = parent.getBoundingClientRect();

                return (pRect.bottom - rect.bottom).round();
            }
        });
    }

    Element.Offset = Class.create({
        initialize: function(left, top) {
            this.left = left.round();
            this.top  = top.round();

            this[0] = this.left;
            this[1] = this.top;
        },

        relativeTo: function(offset) {
            return new Element.Offset(
                this.left - offset.left,
                this.top  - offset.top
            );
        },

        inspect: function() {
            return "#<Element.Offset left: #{left} top: #{top}>".interpolate(this);
        },

        toString: function() {
            return "[#{left}, #{top}]".interpolate(this);
        },

        toArray: function() {
            return [this.left, this.top];
        }
    });

    function getLayout(element, preCompute) {
        return new Element.Layout(element, preCompute);
    }

    function measure(element, property) {
        return $(element).getLayout().get(property);
    }

    function getHeight(element) {
        return Element.getDimensions(element).height;
    }

    function getWidth(element) {
        return Element.getDimensions(element).width;
    }

    function getDimensions(element) {
        element = $(element);
        var display = Element.getStyle(element, 'display');

        if (display && display !== 'none') {
            return { width: element.offsetWidth, height: element.offsetHeight };
        }

        var style = element.style;
        var originalStyles = {
            visibility: style.visibility,
            position:   style.position,
            display:    style.display
        };

        var newStyles = {
            visibility: 'hidden',
            display:    'block'
        };

        if (originalStyles.position !== 'fixed')
            newStyles.position = 'absolute';

        Element.setStyle(element, newStyles);

        var dimensions = {
            width:  element.offsetWidth,
            height: element.offsetHeight
        };

        Element.setStyle(element, originalStyles);

        return dimensions;
    }

    function getOffsetParent(element) {
        element = $(element);

        if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
            return $(document.body);

        var isInline = (Element.getStyle(element, 'display') === 'inline');
        if (!isInline && element.offsetParent) return $(element.offsetParent);

        while ((element = element.parentNode) && element !== document.body) {
            if (Element.getStyle(element, 'position') !== 'static') {
                return isHtml(element) ? $(document.body) : $(element);
            }
        }

        return $(document.body);
    }


    function cumulativeOffset(element) {
        element = $(element);
        var valueT = 0, valueL = 0;
        if (element.parentNode) {
            do {
                valueT += element.offsetTop  || 0;
                valueL += element.offsetLeft || 0;
                element = element.offsetParent;
            } while (element);
        }
        return new Element.Offset(valueL, valueT);
    }

    function positionedOffset(element) {
        element = $(element);

        var layout = element.getLayout();

        var valueT = 0, valueL = 0;
        do {
            valueT += element.offsetTop  || 0;
            valueL += element.offsetLeft || 0;
            element = element.offsetParent;
            if (element) {
                if (isBody(element)) break;
                var p = Element.getStyle(element, 'position');
                if (p !== 'static') break;
            }
        } while (element);

        valueL -= layout.get('margin-top');
        valueT -= layout.get('margin-left');

        return new Element.Offset(valueL, valueT);
    }

    function cumulativeScrollOffset(element) {
        var valueT = 0, valueL = 0;
        do {
            if (element === document.body) {
                var bodyScrollNode = document.documentElement || document.body.parentNode || document.body;
                valueT += !Object.isUndefined(window.pageYOffset) ? window.pageYOffset : bodyScrollNode.scrollTop || 0;
                valueL += !Object.isUndefined(window.pageXOffset) ? window.pageXOffset : bodyScrollNode.scrollLeft || 0;
                break;
            } else {
                valueT += element.scrollTop  || 0;
                valueL += element.scrollLeft || 0;
                element = element.parentNode;
            }
        } while (element);
        return new Element.Offset(valueL, valueT);
    }

    function viewportOffset(forElement) {
        var valueT = 0, valueL = 0, docBody = document.body;

        forElement = $(forElement);
        var element = forElement;
        do {
            valueT += element.offsetTop  || 0;
            valueL += element.offsetLeft || 0;
            if (element.offsetParent == docBody &&
                Element.getStyle(element, 'position') == 'absolute') break;
        } while (element = element.offsetParent);

        element = forElement;
        do {
            if (element != docBody) {
                valueT -= element.scrollTop  || 0;
                valueL -= element.scrollLeft || 0;
            }
        } while (element = element.parentNode);
        return new Element.Offset(valueL, valueT);
    }

    function absolutize(element) {
        element = $(element);

        if (Element.getStyle(element, 'position') === 'absolute') {
            return element;
        }

        var offsetParent = getOffsetParent(element);
        var eOffset = element.viewportOffset(),
            pOffset = offsetParent.viewportOffset();

        var offset = eOffset.relativeTo(pOffset);
        var layout = element.getLayout();

        element.store('prototype_absolutize_original_styles', {
            position: element.getStyle('position'),
            left:     element.getStyle('left'),
            top:      element.getStyle('top'),
            width:    element.getStyle('width'),
            height:   element.getStyle('height')
        });

        element.setStyle({
            position: 'absolute',
            top:    offset.top + 'px',
            left:   offset.left + 'px',
            width:  layout.get('width') + 'px',
            height: layout.get('height') + 'px'
        });

        return element;
    }

    function relativize(element) {
        element = $(element);
        if (Element.getStyle(element, 'position') === 'relative') {
            return element;
        }

        var originalStyles =
            element.retrieve('prototype_absolutize_original_styles');

        if (originalStyles) element.setStyle(originalStyles);
        return element;
    }


    function scrollTo(element) {
        element = $(element);
        var pos = Element.cumulativeOffset(element);
        window.scrollTo(pos.left, pos.top);
        return element;
    }


    function makePositioned(element) {
        element = $(element);
        var position = Element.getStyle(element, 'position'), styles = {};
        if (position === 'static' || !position) {
            styles.position = 'relative';
            if (Prototype.Browser.Opera) {
                styles.top  = 0;
                styles.left = 0;
            }
            Element.setStyle(element, styles);
            Element.store(element, 'prototype_made_positioned', true);
        }
        return element;
    }

    function undoPositioned(element) {
        element = $(element);
        var storage = Element.getStorage(element),
            madePositioned = storage.get('prototype_made_positioned');

        if (madePositioned) {
            storage.unset('prototype_made_positioned');
            Element.setStyle(element, {
                position: '',
                top:      '',
                bottom:   '',
                left:     '',
                right:    ''
            });
        }
        return element;
    }

    function makeClipping(element) {
        element = $(element);

        var storage = Element.getStorage(element),
            madeClipping = storage.get('prototype_made_clipping');

        if (Object.isUndefined(madeClipping)) {
            var overflow = Element.getStyle(element, 'overflow');
            storage.set('prototype_made_clipping', overflow);
            if (overflow !== 'hidden')
                element.style.overflow = 'hidden';
        }

        return element;
    }

    function undoClipping(element) {
        element = $(element);
        var storage = Element.getStorage(element),
            overflow = storage.get('prototype_made_clipping');

        if (!Object.isUndefined(overflow)) {
            storage.unset('prototype_made_clipping');
            element.style.overflow = overflow || '';
        }

        return element;
    }

    function clonePosition(element, source, options) {
        options = Object.extend({
            setLeft:    true,
            setTop:     true,
            setWidth:   true,
            setHeight:  true,
            offsetTop:  0,
            offsetLeft: 0
        }, options || {});

        source  = $(source);
        element = $(element);
        var p, delta, layout, styles = {};

        if (options.setLeft || options.setTop) {
            p = Element.viewportOffset(source);
            delta = [0, 0];
            if (Element.getStyle(element, 'position') === 'absolute') {
                var parent = Element.getOffsetParent(element);
                if (parent !== document.body) delta = Element.viewportOffset(parent);
            }
        }

        if (options.setWidth || options.setHeight) {
            layout = Element.getLayout(source);
        }

        if (options.setLeft)
            styles.left = (p[0] - delta[0] + options.offsetLeft) + 'px';
        if (options.setTop)
            styles.top  = (p[1] - delta[1] + options.offsetTop)  + 'px';

        if (options.setWidth)
            styles.width  = layout.get('border-box-width')  + 'px';
        if (options.setHeight)
            styles.height = layout.get('border-box-height') + 'px';

        return Element.setStyle(element, styles);
    }


    if (Prototype.Browser.IE) {
        getOffsetParent = getOffsetParent.wrap(
            function(proceed, element) {
                element = $(element);

                if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
                    return $(document.body);

                var position = element.getStyle('position');
                if (position !== 'static') return proceed(element);

                element.setStyle({ position: 'relative' });
                var value = proceed(element);
                element.setStyle({ position: position });
                return value;
            }
        );

        positionedOffset = positionedOffset.wrap(function(proceed, element) {
            element = $(element);
            if (!element.parentNode) return new Element.Offset(0, 0);
            var position = element.getStyle('position');
            if (position !== 'static') return proceed(element);

            var offsetParent = element.getOffsetParent();
            if (offsetParent && offsetParent.getStyle('position') === 'fixed')
                hasLayout(offsetParent);

            element.setStyle({ position: 'relative' });
            var value = proceed(element);
            element.setStyle({ position: position });
            return value;
        });
    } else if (Prototype.Browser.Webkit) {
        cumulativeOffset = function(element) {
            element = $(element);
            var valueT = 0, valueL = 0;
            do {
                valueT += element.offsetTop  || 0;
                valueL += element.offsetLeft || 0;
                if (element.offsetParent == document.body) {
                    if (Element.getStyle(element, 'position') == 'absolute') break;
                }

                element = element.offsetParent;
            } while (element);

            return new Element.Offset(valueL, valueT);
        };
    }


    Element.addMethods({
        getLayout:              getLayout,
        measure:                measure,
        getWidth:               getWidth,
        getHeight:              getHeight,
        getDimensions:          getDimensions,
        getOffsetParent:        getOffsetParent,
        cumulativeOffset:       cumulativeOffset,
        positionedOffset:       positionedOffset,
        cumulativeScrollOffset: cumulativeScrollOffset,
        viewportOffset:         viewportOffset,
        absolutize:             absolutize,
        relativize:             relativize,
        scrollTo:               scrollTo,
        makePositioned:         makePositioned,
        undoPositioned:         undoPositioned,
        makeClipping:           makeClipping,
        undoClipping:           undoClipping,
        clonePosition:          clonePosition
    });

    function isBody(element) {
        return element.nodeName.toUpperCase() === 'BODY';
    }

    function isHtml(element) {
        return element.nodeName.toUpperCase() === 'HTML';
    }

    function isDocument(element) {
        return element.nodeType === Node.DOCUMENT_NODE;
    }

    function isDetached(element) {
        return element !== document.body &&
            !Element.descendantOf(element, document.body);
    }

    if ('getBoundingClientRect' in document.documentElement) {
        Element.addMethods({
            viewportOffset: function(element) {
                element = $(element);
                if (isDetached(element)) return new Element.Offset(0, 0);

                var rect = element.getBoundingClientRect(),
                    docEl = document.documentElement;
                return new Element.Offset(rect.left - docEl.clientLeft,
                    rect.top - docEl.clientTop);
            }
        });
    }


})();

(function() {

    var IS_OLD_OPERA = Prototype.Browser.Opera &&
        (window.parseFloat(window.opera.version()) < 9.5);
    var ROOT = null;
    function getRootElement() {
        if (ROOT) return ROOT;
        ROOT = IS_OLD_OPERA ? document.body : document.documentElement;
        return ROOT;
    }

    function getDimensions() {
        return { width: this.getWidth(), height: this.getHeight() };
    }

    function getWidth() {
        return getRootElement().clientWidth;
    }

    function getHeight() {
        return getRootElement().clientHeight;
    }

    function getScrollOffsets() {
        var x = window.pageXOffset || document.documentElement.scrollLeft ||
            document.body.scrollLeft;
        var y = window.pageYOffset || document.documentElement.scrollTop ||
            document.body.scrollTop;

        return new Element.Offset(x, y);
    }

    document.viewport = {
        getDimensions:    getDimensions,
        getWidth:         getWidth,
        getHeight:        getHeight,
        getScrollOffsets: getScrollOffsets
    };

})();
window.$$ = function() {
    var expression = $A(arguments).join(', ');
    return Prototype.Selector.select(expression, document);
};

Prototype.Selector = (function() {

    function select() {
        throw new Error('Method "Prototype.Selector.select" must be defined.');
    }

    function match() {
        throw new Error('Method "Prototype.Selector.match" must be defined.');
    }

    function find(elements, expression, index) {
        index = index || 0;
        var match = Prototype.Selector.match, length = elements.length, matchIndex = 0, i;

        for (i = 0; i < length; i++) {
            if (match(elements[i], expression) && index == matchIndex++) {
                return Element.extend(elements[i]);
            }
        }
    }

    function extendElements(elements) {
        for (var i = 0, length = elements.length; i < length; i++) {
            Element.extend(elements[i]);
        }
        return elements;
    }


    var K = Prototype.K;

    return {
        select: select,
        match: match,
        find: find,
        extendElements: (Element.extend === K) ? K : extendElements,
        extendElement: Element.extend
    };
})();
Prototype._original_property = window.Sizzle;
/*!
 * Sizzle CSS Selector Engine v@VERSION
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: @DATE
 */
(function( window ) {

    var i,
        support,
        Expr,
        getText,
        isXML,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,

        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,

        expando = "sizzle" + -(new Date()),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function( a, b ) {
            if ( a === b ) {
                hasDuplicate = true;
            }
            return 0;
        },

        strundefined = typeof undefined,
        MAX_NEGATIVE = 1 << 31,

        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = arr.indexOf || function( elem ) {
                var i = 0,
                    len = this.length;
                for ( ; i < len; i++ ) {
                    if ( this[i] === elem ) {
                        return i;
                    }
                }
                return -1;
            },

        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

        identifier = characterEncoding.replace( "w", "w#" ),

        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
            "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

        pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

        rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

        rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
        rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

        rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

        rpseudo = new RegExp( pseudos ),
        ridentifier = new RegExp( "^" + identifier + "$" ),

        matchExpr = {
            "ID": new RegExp( "^#(" + characterEncoding + ")" ),
            "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
            "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
            "ATTR": new RegExp( "^" + attributes ),
            "PSEUDO": new RegExp( "^" + pseudos ),
            "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
            "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
            "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
        },

        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,

        rnative = /^[^{]+\{\s*\[native \w/,

        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

        rsibling = /[+~]/,
        rescape = /'|\\/g,

        runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
        funescape = function( _, escaped, escapedWhitespace ) {
            var high = "0x" + escaped - 0x10000;
            return high !== high || escapedWhitespace ?
                escaped :
                high < 0 ?
                    String.fromCharCode( high + 0x10000 ) :
                    String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
        };

    try {
        push.apply(
            (arr = slice.call( preferredDoc.childNodes )),
            preferredDoc.childNodes
        );
        arr[ preferredDoc.childNodes.length ].nodeType;
    } catch ( e ) {
        push = { apply: arr.length ?

            function( target, els ) {
                push_native.apply( target, slice.call(els) );
            } :

            function( target, els ) {
                var j = target.length,
                    i = 0;
                while ( (target[j++] = els[i++]) ) {}
                target.length = j - 1;
            }
        };
    }

    window.Sizzle = function Sizzle( selector, context, results, seed ) {
        var match, elem, m, nodeType,
            i, groups, old, nid, newContext, newSelector;

        if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
            setDocument( context );
        }

        context = context || document;
        results = results || [];

        if ( !selector || typeof selector !== "string" ) {
            return results;
        }

        if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
            return [];
        }

        if ( documentIsHTML && !seed ) {

            if ( (match = rquickExpr.exec( selector )) ) {
                if ( (m = match[1]) ) {
                    if ( nodeType === 9 ) {
                        elem = context.getElementById( m );
                        if ( elem && elem.parentNode ) {
                            if ( elem.id === m ) {
                                results.push( elem );
                                return results;
                            }
                        } else {
                            return results;
                        }
                    } else {
                        if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                            contains( context, elem ) && elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    }

                } else if ( match[2] ) {
                    push.apply( results, context.getElementsByTagName( selector ) );
                    return results;

                } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
                    push.apply( results, context.getElementsByClassName( m ) );
                    return results;
                }
            }

            if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                nid = old = expando;
                newContext = context;
                newSelector = nodeType === 9 && selector;

                if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                    groups = tokenize( selector );

                    if ( (old = context.getAttribute("id")) ) {
                        nid = old.replace( rescape, "\\$&" );
                    } else {
                        context.setAttribute( "id", nid );
                    }
                    nid = "[id='" + nid + "'] ";

                    i = groups.length;
                    while ( i-- ) {
                        groups[i] = nid + toSelector( groups[i] );
                    }
                    newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                    newSelector = groups.join(",");
                }

                if ( newSelector ) {
                    try {
                        push.apply( results,
                            newContext.querySelectorAll( newSelector )
                        );
                        return results;
                    } catch(qsaError) {
                    } finally {
                        if ( !old ) {
                            context.removeAttribute("id");
                        }
                    }
                }
            }
        }

        return select( selector.replace( rtrim, "$1" ), context, results, seed );
    }

    /**
     * Create key-value caches of limited size
     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */
    function createCache() {
        var keys = [];

        function cache( key, value ) {
            if ( keys.push( key + " " ) > Expr.cacheLength ) {
                delete cache[ keys.shift() ];
            }
            return (cache[ key + " " ] = value);
        }
        return cache;
    }

    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction( fn ) {
        fn[ expando ] = true;
        return fn;
    }

    /**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */
    function assert( fn ) {
        var div = document.createElement("div");

        try {
            return !!fn( div );
        } catch (e) {
            return false;
        } finally {
            if ( div.parentNode ) {
                div.parentNode.removeChild( div );
            }
            div = null;
        }
    }

    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle( attrs, handler ) {
        var arr = attrs.split("|"),
            i = attrs.length;

        while ( i-- ) {
            Expr.attrHandle[ arr[i] ] = handler;
        }
    }

    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck( a, b ) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                ( ~b.sourceIndex || MAX_NEGATIVE ) -
                ( ~a.sourceIndex || MAX_NEGATIVE );

        if ( diff ) {
            return diff;
        }

        if ( cur ) {
            while ( (cur = cur.nextSibling) ) {
                if ( cur === b ) {
                    return -1;
                }
            }
        }

        return a ? 1 : -1;
    }

    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo( type ) {
        return function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo( type ) {
        return function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }

    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo( fn ) {
        return markFunction(function( argument ) {
            argument = +argument;
            return markFunction(function( seed, matches ) {
                var j,
                    matchIndexes = fn( [], seed.length, argument ),
                    i = matchIndexes.length;

                while ( i-- ) {
                    if ( seed[ (j = matchIndexes[i]) ] ) {
                        seed[j] = !(matches[j] = seed[j]);
                    }
                }
            });
        });
    }

    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext( context ) {
        return context && typeof context.getElementsByTagName !== strundefined && context;
    }

    support = Sizzle.support = {};

    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */
    isXML = Sizzle.isXML = function( elem ) {
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
    };

    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function( node ) {
        var hasCompare,
            doc = node ? node.ownerDocument || node : preferredDoc,
            parent = doc.defaultView;

        if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
            return document;
        }

        document = doc;
        docElem = doc.documentElement;

        documentIsHTML = !isXML( doc );

        if ( parent && parent !== parent.top ) {
            if ( parent.addEventListener ) {
                parent.addEventListener( "unload", function() {
                    setDocument();
                }, false );
            } else if ( parent.attachEvent ) {
                parent.attachEvent( "onunload", function() {
                    setDocument();
                });
            }
        }

        /* Attributes
         ---------------------------------------------------------------------- */

        support.attributes = assert(function( div ) {
            div.className = "i";
            return !div.getAttribute("className");
        });

        /* getElement(s)By*
         ---------------------------------------------------------------------- */

        support.getElementsByTagName = assert(function( div ) {
            div.appendChild( doc.createComment("") );
            return !div.getElementsByTagName("*").length;
        });

        support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
                div.innerHTML = "<div class='a'></div><div class='a i'></div>";

                div.firstChild.className = "i";
                return div.getElementsByClassName("i").length === 2;
            });

        support.getById = assert(function( div ) {
            docElem.appendChild( div ).id = expando;
            return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
        });

        if ( support.getById ) {
            Expr.find["ID"] = function( id, context ) {
                if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
                    var m = context.getElementById( id );
                    return m && m.parentNode ? [m] : [];
                }
            };
            Expr.filter["ID"] = function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                    return elem.getAttribute("id") === attrId;
                };
            };
        } else {
            delete Expr.find["ID"];

            Expr.filter["ID"] =  function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                    var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            };
        }

        Expr.find["TAG"] = support.getElementsByTagName ?
            function( tag, context ) {
                if ( typeof context.getElementsByTagName !== strundefined ) {
                    return context.getElementsByTagName( tag );
                }
            } :
            function( tag, context ) {
                var elem,
                    tmp = [],
                    i = 0,
                    results = context.getElementsByTagName( tag );

                if ( tag === "*" ) {
                    while ( (elem = results[i++]) ) {
                        if ( elem.nodeType === 1 ) {
                            tmp.push( elem );
                        }
                    }

                    return tmp;
                }
                return results;
            };

        Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
                    return context.getElementsByClassName( className );
                }
            };

        /* QSA/matchesSelector
         ---------------------------------------------------------------------- */


        rbuggyMatches = [];

        rbuggyQSA = [];

        if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
            assert(function( div ) {
                div.innerHTML = "<select t=''><option selected=''></option></select>";

                if ( div.querySelectorAll("[t^='']").length ) {
                    rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                }

                if ( !div.querySelectorAll("[selected]").length ) {
                    rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                }

                if ( !div.querySelectorAll(":checked").length ) {
                    rbuggyQSA.push(":checked");
                }
            });

            assert(function( div ) {
                var input = doc.createElement("input");
                input.setAttribute( "type", "hidden" );
                div.appendChild( input ).setAttribute( "name", "D" );

                if ( div.querySelectorAll("[name=d]").length ) {
                    rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                }

                if ( !div.querySelectorAll(":enabled").length ) {
                    rbuggyQSA.push( ":enabled", ":disabled" );
                }

                div.querySelectorAll("*,:x");
                rbuggyQSA.push(",.*:");
            });
        }

        if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
                docElem.mozMatchesSelector ||
                docElem.oMatchesSelector ||
                docElem.msMatchesSelector) )) ) {

            assert(function( div ) {
                support.disconnectedMatch = matches.call( div, "div" );

                matches.call( div, "[s!='']:x" );
                rbuggyMatches.push( "!=", pseudos );
            });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
        rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

        /* Contains
         ---------------------------------------------------------------------- */
        hasCompare = rnative.test( docElem.compareDocumentPosition );

        contains = hasCompare || rnative.test( docElem.contains ) ?
            function( a, b ) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !!( bup && bup.nodeType === 1 && (
                        adown.contains ?
                            adown.contains( bup ) :
                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                    ));
            } :
            function( a, b ) {
                if ( b ) {
                    while ( (b = b.parentNode) ) {
                        if ( b === a ) {
                            return true;
                        }
                    }
                }
                return false;
            };

        /* Sorting
         ---------------------------------------------------------------------- */

        sortOrder = hasCompare ?
            function( a, b ) {

                if ( a === b ) {
                    hasDuplicate = true;
                    return 0;
                }

                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if ( compare ) {
                    return compare;
                }

                compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                    a.compareDocumentPosition( b ) :

                    1;

                if ( compare & 1 ||
                    (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                    if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                        return -1;
                    }
                    if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                        return 1;
                    }

                    return sortInput ?
                        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                        0;
                }

                return compare & 4 ? -1 : 1;
            } :
            function( a, b ) {
                if ( a === b ) {
                    hasDuplicate = true;
                    return 0;
                }

                var cur,
                    i = 0,
                    aup = a.parentNode,
                    bup = b.parentNode,
                    ap = [ a ],
                    bp = [ b ];

                if ( !aup || !bup ) {
                    return a === doc ? -1 :
                        b === doc ? 1 :
                            aup ? -1 :
                                bup ? 1 :
                                    sortInput ?
                                        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                                        0;

                } else if ( aup === bup ) {
                    return siblingCheck( a, b );
                }

                cur = a;
                while ( (cur = cur.parentNode) ) {
                    ap.unshift( cur );
                }
                cur = b;
                while ( (cur = cur.parentNode) ) {
                    bp.unshift( cur );
                }

                while ( ap[i] === bp[i] ) {
                    i++;
                }

                return i ?
                    siblingCheck( ap[i], bp[i] ) :

                    ap[i] === preferredDoc ? -1 :
                        bp[i] === preferredDoc ? 1 :
                            0;
            };

        return doc;
    };

    Sizzle.matches = function( expr, elements ) {
        return Sizzle( expr, null, null, elements );
    };

    Sizzle.matchesSelector = function( elem, expr ) {
        if ( ( elem.ownerDocument || elem ) !== document ) {
            setDocument( elem );
        }

        expr = expr.replace( rattributeQuotes, "='$1']" );

        if ( support.matchesSelector && documentIsHTML &&
            ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
            ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

            try {
                var ret = matches.call( elem, expr );

                if ( ret || support.disconnectedMatch ||
                    elem.document && elem.document.nodeType !== 11 ) {
                    return ret;
                }
            } catch(e) {}
        }

        return Sizzle( expr, document, null, [elem] ).length > 0;
    };

    Sizzle.contains = function( context, elem ) {
        if ( ( context.ownerDocument || context ) !== document ) {
            setDocument( context );
        }
        return contains( context, elem );
    };

    Sizzle.attr = function( elem, name ) {
        if ( ( elem.ownerDocument || elem ) !== document ) {
            setDocument( elem );
        }

        var fn = Expr.attrHandle[ name.toLowerCase() ],
            val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                fn( elem, name, !documentIsHTML ) :
                undefined;

        return val !== undefined ?
            val :
            support.attributes || !documentIsHTML ?
                elem.getAttribute( name ) :
                (val = elem.getAttributeNode(name)) && val.specified ?
                    val.value :
                    null;
    };

    Sizzle.error = function( msg ) {
        throw new Error( "Syntax error, unrecognized expression: " + msg );
    };

    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function( results ) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0;

        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice( 0 );
        results.sort( sortOrder );

        if ( hasDuplicate ) {
            while ( (elem = results[i++]) ) {
                if ( elem === results[ i ] ) {
                    j = duplicates.push( i );
                }
            }
            while ( j-- ) {
                results.splice( duplicates[ j ], 1 );
            }
        }

        sortInput = null;

        return results;
    };

    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function( elem ) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;

        if ( !nodeType ) {
            while ( (node = elem[i++]) ) {
                ret += getText( node );
            }
        } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
            if ( typeof elem.textContent === "string" ) {
                return elem.textContent;
            } else {
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    ret += getText( elem );
                }
            }
        } else if ( nodeType === 3 || nodeType === 4 ) {
            return elem.nodeValue;
        }

        return ret;
    };

    Expr = Sizzle.selectors = {

        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
        },

        preFilter: {
            "ATTR": function( match ) {
                match[1] = match[1].replace( runescape, funescape );

                match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

                if ( match[2] === "~=" ) {
                    match[3] = " " + match[3] + " ";
                }

                return match.slice( 0, 4 );
            },

            "CHILD": function( match ) {
                /* matches from matchExpr["CHILD"]
                 1 type (only|nth|...)
                 2 what (child|of-type)
                 3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                 4 xn-component of xn+y argument ([+-]?\d*n|)
                 5 sign of xn-component
                 6 x of xn-component
                 7 sign of y-component
                 8 y of y-component
                 */
                match[1] = match[1].toLowerCase();

                if ( match[1].slice( 0, 3 ) === "nth" ) {
                    if ( !match[3] ) {
                        Sizzle.error( match[0] );
                    }

                    match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                    match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                } else if ( match[3] ) {
                    Sizzle.error( match[0] );
                }

                return match;
            },

            "PSEUDO": function( match ) {
                var excess,
                    unquoted = !match[5] && match[2];

                if ( matchExpr["CHILD"].test( match[0] ) ) {
                    return null;
                }

                if ( match[3] && match[4] !== undefined ) {
                    match[2] = match[4];

                } else if ( unquoted && rpseudo.test( unquoted ) &&
                    (excess = tokenize( unquoted, true )) &&
                    (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                    match[0] = match[0].slice( 0, excess );
                    match[2] = unquoted.slice( 0, excess );
                }

                return match.slice( 0, 3 );
            }
        },

        filter: {

            "TAG": function( nodeNameSelector ) {
                var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                return nodeNameSelector === "*" ?
                    function() { return true; } :
                    function( elem ) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
            },

            "CLASS": function( className ) {
                var pattern = classCache[ className + " " ];

                return pattern ||
                    (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                    classCache( className, function( elem ) {
                        return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
                    });
            },

            "ATTR": function( name, operator, check ) {
                return function( elem ) {
                    var result = Sizzle.attr( elem, name );

                    if ( result == null ) {
                        return operator === "!=";
                    }
                    if ( !operator ) {
                        return true;
                    }

                    result += "";

                    return operator === "=" ? result === check :
                        operator === "!=" ? result !== check :
                            operator === "^=" ? check && result.indexOf( check ) === 0 :
                                operator === "*=" ? check && result.indexOf( check ) > -1 :
                                    operator === "$=" ? check && result.slice( -check.length ) === check :
                                        operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
                                            operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                false;
                };
            },

            "CHILD": function( type, what, argument, first, last ) {
                var simple = type.slice( 0, 3 ) !== "nth",
                    forward = type.slice( -4 ) !== "last",
                    ofType = what === "of-type";

                return first === 1 && last === 0 ?

                    function( elem ) {
                        return !!elem.parentNode;
                    } :

                    function( elem, context, xml ) {
                        var cache, outerCache, node, diff, nodeIndex, start,
                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType;

                        if ( parent ) {

                            if ( simple ) {
                                while ( dir ) {
                                    node = elem;
                                    while ( (node = node[ dir ]) ) {
                                        if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }

                            start = [ forward ? parent.firstChild : parent.lastChild ];

                            if ( forward && useCache ) {
                                outerCache = parent[ expando ] || (parent[ expando ] = {});
                                cache = outerCache[ type ] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[ nodeIndex ];

                                while ( (node = ++nodeIndex && node && node[ dir ] ||

                                    (diff = nodeIndex = 0) || start.pop()) ) {

                                    if ( node.nodeType === 1 && ++diff && node === elem ) {
                                        outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }

                            } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                                diff = cache[1];

                            } else {
                                while ( (node = ++nodeIndex && node && node[ dir ] ||
                                    (diff = nodeIndex = 0) || start.pop()) ) {

                                    if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                        if ( useCache ) {
                                            (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                        }

                                        if ( node === elem ) {
                                            break;
                                        }
                                    }
                                }
                            }

                            diff -= last;
                            return diff === first || ( diff % first === 0 && diff / first >= 0 );
                        }
                    };
            },

            "PSEUDO": function( pseudo, argument ) {
                var args,
                    fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                        Sizzle.error( "unsupported pseudo: " + pseudo );

                if ( fn[ expando ] ) {
                    return fn( argument );
                }

                if ( fn.length > 1 ) {
                    args = [ pseudo, pseudo, "", argument ];
                    return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                        markFunction(function( seed, matches ) {
                            var idx,
                                matched = fn( seed, argument ),
                                i = matched.length;
                            while ( i-- ) {
                                idx = indexOf.call( seed, matched[i] );
                                seed[ idx ] = !( matches[ idx ] = matched[i] );
                            }
                        }) :
                        function( elem ) {
                            return fn( elem, 0, args );
                        };
                }

                return fn;
            }
        },

        pseudos: {
            "not": markFunction(function( selector ) {
                var input = [],
                    results = [],
                    matcher = compile( selector.replace( rtrim, "$1" ) );

                return matcher[ expando ] ?
                    markFunction(function( seed, matches, context, xml ) {
                        var elem,
                            unmatched = matcher( seed, null, xml, [] ),
                            i = seed.length;

                        while ( i-- ) {
                            if ( (elem = unmatched[i]) ) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) :
                    function( elem, context, xml ) {
                        input[0] = elem;
                        matcher( input, null, xml, results );
                        return !results.pop();
                    };
            }),

            "has": markFunction(function( selector ) {
                return function( elem ) {
                    return Sizzle( selector, elem ).length > 0;
                };
            }),

            "contains": markFunction(function( text ) {
                return function( elem ) {
                    return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                };
            }),

            "lang": markFunction( function( lang ) {
                if ( !ridentifier.test(lang || "") ) {
                    Sizzle.error( "unsupported lang: " + lang );
                }
                lang = lang.replace( runescape, funescape ).toLowerCase();
                return function( elem ) {
                    var elemLang;
                    do {
                        if ( (elemLang = documentIsHTML ?
                                elem.lang :
                            elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                        }
                    } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                    return false;
                };
            }),

            "target": function( elem ) {
                var hash = window.location && window.location.hash;
                return hash && hash.slice( 1 ) === elem.id;
            },

            "root": function( elem ) {
                return elem === docElem;
            },

            "focus": function( elem ) {
                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },

            "enabled": function( elem ) {
                return elem.disabled === false;
            },

            "disabled": function( elem ) {
                return elem.disabled === true;
            },

            "checked": function( elem ) {
                var nodeName = elem.nodeName.toLowerCase();
                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
            },

            "selected": function( elem ) {
                if ( elem.parentNode ) {
                    elem.parentNode.selectedIndex;
                }

                return elem.selected === true;
            },

            "empty": function( elem ) {
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    if ( elem.nodeType < 6 ) {
                        return false;
                    }
                }
                return true;
            },

            "parent": function( elem ) {
                return !Expr.pseudos["empty"]( elem );
            },

            "header": function( elem ) {
                return rheader.test( elem.nodeName );
            },

            "input": function( elem ) {
                return rinputs.test( elem.nodeName );
            },

            "button": function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
            },

            "text": function( elem ) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" &&
                    elem.type === "text" &&

                    ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
            },

            "first": createPositionalPseudo(function() {
                return [ 0 ];
            }),

            "last": createPositionalPseudo(function( matchIndexes, length ) {
                return [ length - 1 ];
            }),

            "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                return [ argument < 0 ? argument + length : argument ];
            }),

            "even": createPositionalPseudo(function( matchIndexes, length ) {
                var i = 0;
                for ( ; i < length; i += 2 ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            }),

            "odd": createPositionalPseudo(function( matchIndexes, length ) {
                var i = 1;
                for ( ; i < length; i += 2 ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            }),

            "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                var i = argument < 0 ? argument + length : argument;
                for ( ; --i >= 0; ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            }),

            "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                var i = argument < 0 ? argument + length : argument;
                for ( ; ++i < length; ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            })
        }
    };

    Expr.pseudos["nth"] = Expr.pseudos["eq"];

    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
        Expr.pseudos[ i ] = createInputPseudo( i );
    }
    for ( i in { submit: true, reset: true } ) {
        Expr.pseudos[ i ] = createButtonPseudo( i );
    }

    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    function tokenize( selector, parseOnly ) {
        var matched, match, tokens, type,
            soFar, groups, preFilters,
            cached = tokenCache[ selector + " " ];

        if ( cached ) {
            return parseOnly ? 0 : cached.slice( 0 );
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while ( soFar ) {

            if ( !matched || (match = rcomma.exec( soFar )) ) {
                if ( match ) {
                    soFar = soFar.slice( match[0].length ) || soFar;
                }
                groups.push( (tokens = []) );
            }

            matched = false;

            if ( (match = rcombinators.exec( soFar )) ) {
                matched = match.shift();
                tokens.push({
                    value: matched,
                    type: match[0].replace( rtrim, " " )
                });
                soFar = soFar.slice( matched.length );
            }

            for ( type in Expr.filter ) {
                if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                    (match = preFilters[ type ]( match ))) ) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice( matched.length );
                }
            }

            if ( !matched ) {
                break;
            }
        }

        return parseOnly ?
            soFar.length :
            soFar ?
                Sizzle.error( selector ) :
                tokenCache( selector, groups ).slice( 0 );
    }

    function toSelector( tokens ) {
        var i = 0,
            len = tokens.length,
            selector = "";
        for ( ; i < len; i++ ) {
            selector += tokens[i].value;
        }
        return selector;
    }

    function addCombinator( matcher, combinator, base ) {
        var dir = combinator.dir,
            checkNonElements = base && dir === "parentNode",
            doneName = done++;

        return combinator.first ?
            function( elem, context, xml ) {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        return matcher( elem, context, xml );
                    }
                }
            } :

            function( elem, context, xml ) {
                var oldCache, outerCache,
                    newCache = [ dirruns, doneName ];

                if ( xml ) {
                    while ( (elem = elem[ dir ]) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                            if ( matcher( elem, context, xml ) ) {
                                return true;
                            }
                        }
                    }
                } else {
                    while ( (elem = elem[ dir ]) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                            outerCache = elem[ expando ] || (elem[ expando ] = {});
                            if ( (oldCache = outerCache[ dir ]) &&
                                oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                return (newCache[ 2 ] = oldCache[ 2 ]);
                            } else {
                                outerCache[ dir ] = newCache;

                                if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
    }

    function elementMatcher( matchers ) {
        return matchers.length > 1 ?
            function( elem, context, xml ) {
                var i = matchers.length;
                while ( i-- ) {
                    if ( !matchers[i]( elem, context, xml ) ) {
                        return false;
                    }
                }
                return true;
            } :
            matchers[0];
    }

    function multipleContexts( selector, contexts, results ) {
        var i = 0,
            len = contexts.length;
        for ( ; i < len; i++ ) {
            Sizzle( selector, contexts[i], results );
        }
        return results;
    }

    function condense( unmatched, map, filter, context, xml ) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;

        for ( ; i < len; i++ ) {
            if ( (elem = unmatched[i]) ) {
                if ( !filter || filter( elem, context, xml ) ) {
                    newUnmatched.push( elem );
                    if ( mapped ) {
                        map.push( i );
                    }
                }
            }
        }

        return newUnmatched;
    }

    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
        if ( postFilter && !postFilter[ expando ] ) {
            postFilter = setMatcher( postFilter );
        }
        if ( postFinder && !postFinder[ expando ] ) {
            postFinder = setMatcher( postFinder, postSelector );
        }
        return markFunction(function( seed, results, context, xml ) {
            var temp, i, elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,

                elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                matcherIn = preFilter && ( seed || !selector ) ?
                    condense( elems, preMap, preFilter, context, xml ) :
                    elems,

                matcherOut = matcher ?
                    postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                        [] :

                        results :
                    matcherIn;

            if ( matcher ) {
                matcher( matcherIn, matcherOut, context, xml );
            }

            if ( postFilter ) {
                temp = condense( matcherOut, postMap );
                postFilter( temp, [], context, xml );

                i = temp.length;
                while ( i-- ) {
                    if ( (elem = temp[i]) ) {
                        matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                    }
                }
            }

            if ( seed ) {
                if ( postFinder || preFilter ) {
                    if ( postFinder ) {
                        temp = [];
                        i = matcherOut.length;
                        while ( i-- ) {
                            if ( (elem = matcherOut[i]) ) {
                                temp.push( (matcherIn[i] = elem) );
                            }
                        }
                        postFinder( null, (matcherOut = []), temp, xml );
                    }

                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) &&
                            (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

                            seed[temp] = !(results[temp] = elem);
                        }
                    }
                }

            } else {
                matcherOut = condense(
                    matcherOut === results ?
                        matcherOut.splice( preexisting, matcherOut.length ) :
                        matcherOut
                );
                if ( postFinder ) {
                    postFinder( null, results, matcherOut, xml );
                } else {
                    push.apply( results, matcherOut );
                }
            }
        });
    }

    function matcherFromTokens( tokens ) {
        var checkContext, matcher, j,
            len = tokens.length,
            leadingRelative = Expr.relative[ tokens[0].type ],
            implicitRelative = leadingRelative || Expr.relative[" "],
            i = leadingRelative ? 1 : 0,

            matchContext = addCombinator( function( elem ) {
                return elem === checkContext;
            }, implicitRelative, true ),
            matchAnyContext = addCombinator( function( elem ) {
                return indexOf.call( checkContext, elem ) > -1;
            }, implicitRelative, true ),
            matchers = [ function( elem, context, xml ) {
                return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                        (checkContext = context).nodeType ?
                            matchContext( elem, context, xml ) :
                            matchAnyContext( elem, context, xml ) );
            } ];

        for ( ; i < len; i++ ) {
            if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
            } else {
                matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                if ( matcher[ expando ] ) {
                    j = ++i;
                    for ( ; j < len; j++ ) {
                        if ( Expr.relative[ tokens[j].type ] ) {
                            break;
                        }
                    }
                    return setMatcher(
                        i > 1 && elementMatcher( matchers ),
                        i > 1 && toSelector(
                            tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                        ).replace( rtrim, "$1" ),
                        matcher,
                        i < j && matcherFromTokens( tokens.slice( i, j ) ),
                        j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                        j < len && toSelector( tokens )
                    );
                }
                matchers.push( matcher );
            }
        }

        return elementMatcher( matchers );
    }

    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function( seed, context, xml, results, outermost ) {
                var elem, j, matcher,
                    matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,
                    elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                    len = elems.length;

                if ( outermost ) {
                    outermostContext = context !== document && context;
                }

                for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                    if ( byElement && elem ) {
                        j = 0;
                        while ( (matcher = elementMatchers[j++]) ) {
                            if ( matcher( elem, context, xml ) ) {
                                results.push( elem );
                                break;
                            }
                        }
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                        }
                    }

                    if ( bySet ) {
                        if ( (elem = !matcher && elem) ) {
                            matchedCount--;
                        }

                        if ( seed ) {
                            unmatched.push( elem );
                        }
                    }
                }

                matchedCount += i;
                if ( bySet && i !== matchedCount ) {
                    j = 0;
                    while ( (matcher = setMatchers[j++]) ) {
                        matcher( unmatched, setMatched, context, xml );
                    }

                    if ( seed ) {
                        if ( matchedCount > 0 ) {
                            while ( i-- ) {
                                if ( !(unmatched[i] || setMatched[i]) ) {
                                    setMatched[i] = pop.call( results );
                                }
                            }
                        }

                        setMatched = condense( setMatched );
                    }

                    push.apply( results, setMatched );

                    if ( outermost && !seed && setMatched.length > 0 &&
                        ( matchedCount + setMatchers.length ) > 1 ) {

                        Sizzle.uniqueSort( results );
                    }
                }

                if ( outermost ) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }

                return unmatched;
            };

        return bySet ?
            markFunction( superMatcher ) :
            superMatcher;
    }

    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[ selector + " " ];

        if ( !cached ) {
            if ( !match ) {
                match = tokenize( selector );
            }
            i = match.length;
            while ( i-- ) {
                cached = matcherFromTokens( match[i] );
                if ( cached[ expando ] ) {
                    setMatchers.push( cached );
                } else {
                    elementMatchers.push( cached );
                }
            }

            cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

            cached.selector = selector;
        }
        return cached;
    };

    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    select = Sizzle.select = function( selector, context, results, seed ) {
        var i, tokens, token, type, find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize( (selector = compiled.selector || selector) );

        results = results || [];

        if ( match.length === 1 ) {

            tokens = match[0] = match[0].slice( 0 );
            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                support.getById && context.nodeType === 9 && documentIsHTML &&
                Expr.relative[ tokens[1].type ] ) {

                context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                if ( !context ) {
                    return results;

                } else if ( compiled ) {
                    context = context.parentNode;
                }

                selector = selector.slice( tokens.shift().value.length );
            }

            i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
            while ( i-- ) {
                token = tokens[i];

                if ( Expr.relative[ (type = token.type) ] ) {
                    break;
                }
                if ( (find = Expr.find[ type ]) ) {
                    if ( (seed = find(
                            token.matches[0].replace( runescape, funescape ),
                            rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                        )) ) {

                        tokens.splice( i, 1 );
                        selector = seed.length && toSelector( tokens );
                        if ( !selector ) {
                            push.apply( results, seed );
                            return results;
                        }

                        break;
                    }
                }
            }
        }

        ( compiled || compile( selector, match ) )(
            seed,
            context,
            !documentIsHTML,
            results,
            rsibling.test( selector ) && testContext( context.parentNode ) || context
        );
        return results;
    };


    support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

    support.detectDuplicates = !!hasDuplicate;

    setDocument();

    support.sortDetached = assert(function( div1 ) {
        return div1.compareDocumentPosition( document.createElement("div") ) & 1;
    });

    if ( !assert(function( div ) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#" ;
        }) ) {
        addHandle( "type|href|height|width", function( elem, name, isXML ) {
            if ( !isXML ) {
                return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
            }
        });
    }

    if ( !support.attributes || !assert(function( div ) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute( "value", "" );
            return div.firstChild.getAttribute( "value" ) === "";
        }) ) {
        addHandle( "value", function( elem, name, isXML ) {
            if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                return elem.defaultValue;
            }
        });
    }

    if ( !assert(function( div ) {
            return div.getAttribute("disabled") == null;
        }) ) {
        addHandle( booleans, function( elem, name, isXML ) {
            var val;
            if ( !isXML ) {
                return elem[ name ] === true ? name.toLowerCase() :
                    (val = elem.getAttributeNode( name )) && val.specified ?
                        val.value :
                        null;
            }
        });
    }

    if ( typeof define === "function" && define.amd ) {
        define(function() { return Sizzle; });
    } else if ( typeof module !== "undefined" && module.exports ) {
        module.exports = Sizzle;
    } else {
        window.Sizzle = Sizzle;
    }

})( window );

;(function(engine) {
    var extendElements = Prototype.Selector.extendElements;

    function select(selector, scope) {
        return extendElements(engine(selector, scope || document));
    }

    function match(element, selector) {
        return engine.matches(selector, [element]).length == 1;
    }

    Prototype.Selector.engine = engine;
    Prototype.Selector.select = select;
    Prototype.Selector.match = match;
})(Sizzle);

window.Sizzle = Prototype._original_property;
delete Prototype._original_property;

var Form = {
    reset: function(form) {
        form = $(form);
        form.reset();
        return form;
    },

    serializeElements: function(elements, options) {
        if (typeof options != 'object') options = { hash: !!options };
        else if (Object.isUndefined(options.hash)) options.hash = true;
        var key, value, submitted = false, submit = options.submit, accumulator, initial;

        if (options.hash) {
            initial = {};
            accumulator = function(result, key, value) {
                if (key in result) {
                    if (!Object.isArray(result[key])) result[key] = [result[key]];
                    result[key] = result[key].concat(value);
                } else result[key] = value;
                return result;
            };
        } else {
            initial = '';
            accumulator = function(result, key, values) {
                if (!Object.isArray(values)) {values = [values];}
                if (!values.length) {return result;}
                var encodedKey = encodeURIComponent(key).gsub(/%20/, '+');
                return result + (result ? "&" : "") + values.map(function (value) {
                        value = value.gsub(/(\r)?\n/, '\r\n');
                        value = encodeURIComponent(value);
                        value = value.gsub(/%20/, '+');
                        return encodedKey + "=" + value;
                    }).join("&");
            };
        }

        return elements.inject(initial, function(result, element) {
            if (!element.disabled && element.name) {
                key = element.name; value = $(element).getValue();
                if (value != null && element.type != 'file' && (element.type != 'submit' || (!submitted &&
                    submit !== false && (!submit || key == submit) && (submitted = true)))) {
                    result = accumulator(result, key, value);
                }
            }
            return result;
        });
    }
};

Form.Methods = {
    serialize: function(form, options) {
        return Form.serializeElements(Form.getElements(form), options);
    },


    getElements: function(form) {
        var elements = $(form).getElementsByTagName('*');
        var element, results = [], serializers = Form.Element.Serializers;

        for (var i = 0; element = elements[i]; i++) {
            if (serializers[element.tagName.toLowerCase()])
                results.push(Element.extend(element));
        }
        return results;
    },

    getInputs: function(form, typeName, name) {
        form = $(form);
        var inputs = form.getElementsByTagName('input');

        if (!typeName && !name) return $A(inputs).map(Element.extend);

        for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
            var input = inputs[i];
            if ((typeName && input.type != typeName) || (name && input.name != name))
                continue;
            matchingInputs.push(Element.extend(input));
        }

        return matchingInputs;
    },

    disable: function(form) {
        form = $(form);
        Form.getElements(form).invoke('disable');
        return form;
    },

    enable: function(form) {
        form = $(form);
        Form.getElements(form).invoke('enable');
        return form;
    },

    findFirstElement: function(form) {
        var elements = $(form).getElements().findAll(function(element) {
            return 'hidden' != element.type && !element.disabled;
        });
        var firstByIndex = elements.findAll(function(element) {
            return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
        }).sortBy(function(element) { return element.tabIndex }).first();

        return firstByIndex ? firstByIndex : elements.find(function(element) {
            return /^(?:input|select|textarea)$/i.test(element.tagName);
        });
    },

    focusFirstElement: function(form) {
        form = $(form);
        var element = form.findFirstElement();
        if (element) element.activate();
        return form;
    },

    request: function(form, options) {
        form = $(form), options = Object.clone(options || { });

        var params = options.parameters, action = form.readAttribute('action') || '';
        if (action.blank()) action = window.location.href;
        options.parameters = form.serialize(true);

        if (params) {
            if (Object.isString(params)) params = params.toQueryParams();
            Object.extend(options.parameters, params);
        }

        if (form.hasAttribute('method') && !options.method)
            options.method = form.method;

        return new Ajax.Request(action, options);
    }
};

/*--------------------------------------------------------------------------*/


Form.Element = {
    focus: function(element) {
        $(element).focus();
        return element;
    },

    select: function(element) {
        $(element).select();
        return element;
    }
};

Form.Element.Methods = {

    serialize: function(element) {
        element = $(element);
        if (!element.disabled && element.name) {
            var value = element.getValue();
            if (value != undefined) {
                var pair = { };
                pair[element.name] = value;
                return Object.toQueryString(pair);
            }
        }
        return '';
    },

    getValue: function(element) {
        element = $(element);
        var method = element.tagName.toLowerCase();
        return Form.Element.Serializers[method](element);
    },

    setValue: function(element, value) {
        element = $(element);
        var method = element.tagName.toLowerCase();
        Form.Element.Serializers[method](element, value);
        return element;
    },

    clear: function(element) {
        $(element).value = '';
        return element;
    },

    present: function(element) {
        return $(element).value != '';
    },

    activate: function(element) {
        element = $(element);
        try {
            element.focus();
            if (element.select && (element.tagName.toLowerCase() != 'input' ||
                !(/^(?:button|reset|submit)$/i.test(element.type))))
                element.select();
        } catch (e) { }
        return element;
    },

    disable: function(element) {
        element = $(element);
        element.disabled = true;
        return element;
    },

    enable: function(element) {
        element = $(element);
        element.disabled = false;
        return element;
    }
};

/*--------------------------------------------------------------------------*/

var Field = Form.Element;

var $F = Form.Element.Methods.getValue;

/*--------------------------------------------------------------------------*/

Form.Element.Serializers = (function() {
    function input(element, value) {
        switch (element.type.toLowerCase()) {
            case 'checkbox':
            case 'radio':
                return inputSelector(element, value);
            default:
                return valueSelector(element, value);
        }
    }

    function inputSelector(element, value) {
        if (Object.isUndefined(value))
            return element.checked ? element.value : null;
        else element.checked = !!value;
    }

    function valueSelector(element, value) {
        if (Object.isUndefined(value)) return element.value;
        else element.value = value;
    }

    function select(element, value) {
        if (Object.isUndefined(value))
            return (element.type === 'select-one' ? selectOne : selectMany)(element);

        var opt, currentValue, single = !Object.isArray(value);
        for (var i = 0, length = element.length; i < length; i++) {
            opt = element.options[i];
            currentValue = this.optionValue(opt);
            if (single) {
                if (currentValue == value) {
                    opt.selected = true;
                    return;
                }
            }
            else opt.selected = value.include(currentValue);
        }
    }

    function selectOne(element) {
        var index = element.selectedIndex;
        return index >= 0 ? optionValue(element.options[index]) : null;
    }

    function selectMany(element) {
        var values, length = element.length;
        if (!length) return null;

        for (var i = 0, values = []; i < length; i++) {
            var opt = element.options[i];
            if (opt.selected) values.push(optionValue(opt));
        }
        return values;
    }

    function optionValue(opt) {
        return Element.hasAttribute(opt, 'value') ? opt.value : opt.text;
    }

    return {
        input:         input,
        inputSelector: inputSelector,
        textarea:      valueSelector,
        select:        select,
        selectOne:     selectOne,
        selectMany:    selectMany,
        optionValue:   optionValue,
        button:        valueSelector
    };
})();

/*--------------------------------------------------------------------------*/


Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
    initialize: function($super, element, frequency, callback) {
        $super(callback, frequency);
        this.element   = $(element);
        this.lastValue = this.getValue();
    },

    execute: function() {
        var value = this.getValue();
        if (Object.isString(this.lastValue) && Object.isString(value) ?
            this.lastValue != value : String(this.lastValue) != String(value)) {
            this.callback(this.element, value);
            this.lastValue = value;
        }
    }
});

Form.Element.Observer = Class.create(Abstract.TimedObserver, {
    getValue: function() {
        return Form.Element.getValue(this.element);
    }
});

Form.Observer = Class.create(Abstract.TimedObserver, {
    getValue: function() {
        return Form.serialize(this.element);
    }
});

/*--------------------------------------------------------------------------*/

Abstract.EventObserver = Class.create({
    initialize: function(element, callback) {
        this.element  = $(element);
        this.callback = callback;

        this.lastValue = this.getValue();
        if (this.element.tagName.toLowerCase() == 'form')
            this.registerFormCallbacks();
        else
            this.registerCallback(this.element);
    },

    onElementEvent: function() {
        var value = this.getValue();
        if (this.lastValue != value) {
            this.callback(this.element, value);
            this.lastValue = value;
        }
    },

    registerFormCallbacks: function() {
        Form.getElements(this.element).each(this.registerCallback, this);
    },

    registerCallback: function(element) {
        if (element.type) {
            switch (element.type.toLowerCase()) {
                case 'checkbox':
                case 'radio':
                    Event.observe(element, 'click', this.onElementEvent.bind(this));
                    break;
                default:
                    Event.observe(element, 'change', this.onElementEvent.bind(this));
                    break;
            }
        }
    }
});

Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
    getValue: function() {
        return Form.Element.getValue(this.element);
    }
});

Form.EventObserver = Class.create(Abstract.EventObserver, {
    getValue: function() {
        return Form.serialize(this.element);
    }
});
(function(GLOBAL) {
    var DIV = document.createElement('div');
    var docEl = document.documentElement;
    var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
        && 'onmouseleave' in docEl;

    var Event = {
        KEY_BACKSPACE: 8,
        KEY_TAB:       9,
        KEY_RETURN:   13,
        KEY_ESC:      27,
        KEY_LEFT:     37,
        KEY_UP:       38,
        KEY_RIGHT:    39,
        KEY_DOWN:     40,
        KEY_DELETE:   46,
        KEY_HOME:     36,
        KEY_END:      35,
        KEY_PAGEUP:   33,
        KEY_PAGEDOWN: 34,
        KEY_INSERT:   45
    };


    var isIELegacyEvent = function(event) { return false; };

    if (window.attachEvent) {
        if (window.addEventListener) {
            isIELegacyEvent = function(event) {
                return !(event instanceof window.Event);
            };
        } else {
            isIELegacyEvent = function(event) { return true; };
        }
    }

    var _isButton;

    function _isButtonForDOMEvents(event, code) {
        return event.which ? (event.which === code + 1) : (event.button === code);
    }

    var legacyButtonMap = { 0: 1, 1: 4, 2: 2 };
    function _isButtonForLegacyEvents(event, code) {
        return event.button === legacyButtonMap[code];
    }

    function _isButtonForWebKit(event, code) {
        switch (code) {
            case 0: return event.which == 1 && !event.metaKey;
            case 1: return event.which == 2 || (event.which == 1 && event.metaKey);
            case 2: return event.which == 3;
            default: return false;
        }
    }

    if (window.attachEvent) {
        if (!window.addEventListener) {
            _isButton = _isButtonForLegacyEvents;
        } else {
            _isButton = function(event, code) {
                return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) :
                    _isButtonForDOMEvents(event, code);
            }
        }
    } else if (Prototype.Browser.WebKit) {
        _isButton = _isButtonForWebKit;
    } else {
        _isButton = _isButtonForDOMEvents;
    }

    function isLeftClick(event)   { return _isButton(event, 0) }

    function isMiddleClick(event) { return _isButton(event, 1) }

    function isRightClick(event)  { return _isButton(event, 2) }

    function element(event) {
        return Element.extend(_element(event));
    }

    function _element(event) {
        event = Event.extend(event);

        var node = event.target, type = event.type,
            currentTarget = event.currentTarget;

        if (currentTarget && currentTarget.tagName) {
            if (type === 'load' || type === 'error' ||
                (type === 'click' && currentTarget.tagName.toLowerCase() === 'input'
                && currentTarget.type === 'radio'))
                node = currentTarget;
        }

        return node.nodeType == Node.TEXT_NODE ? node.parentNode : node;
    }

    function findElement(event, expression) {
        var element = _element(event), selector = Prototype.Selector;
        if (!expression) return Element.extend(element);
        while (element) {
            if (Object.isElement(element) && selector.match(element, expression))
                return Element.extend(element);
            element = element.parentNode;
        }
    }

    function pointer(event) {
        return { x: pointerX(event), y: pointerY(event) };
    }

    function pointerX(event) {
        var docElement = document.documentElement,
            body = document.body || { scrollLeft: 0 };

        return event.pageX || (event.clientX +
            (docElement.scrollLeft || body.scrollLeft) -
            (docElement.clientLeft || 0));
    }

    function pointerY(event) {
        var docElement = document.documentElement,
            body = document.body || { scrollTop: 0 };

        return  event.pageY || (event.clientY +
            (docElement.scrollTop || body.scrollTop) -
            (docElement.clientTop || 0));
    }


    function stop(event) {
        Event.extend(event);
        event.preventDefault();
        event.stopPropagation();

        event.stopped = true;
    }


    Event.Methods = {
        isLeftClick:   isLeftClick,
        isMiddleClick: isMiddleClick,
        isRightClick:  isRightClick,

        element:     element,
        findElement: findElement,

        pointer:  pointer,
        pointerX: pointerX,
        pointerY: pointerY,

        stop: stop
    };

    var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
        m[name] = Event.Methods[name].methodize();
        return m;
    });

    if (window.attachEvent) {
        function _relatedTarget(event) {
            var element;
            switch (event.type) {
                case 'mouseover':
                case 'mouseenter':
                    element = event.fromElement;
                    break;
                case 'mouseout':
                case 'mouseleave':
                    element = event.toElement;
                    break;
                default:
                    return null;
            }
            return Element.extend(element);
        }

        var additionalMethods = {
            stopPropagation: function() { this.cancelBubble = true },
            preventDefault:  function() { this.returnValue = false },
            inspect: function() { return '[object Event]' }
        };

        Event.extend = function(event, element) {
            if (!event) return false;

            if (!isIELegacyEvent(event)) return event;

            if (event._extendedByPrototype) return event;
            event._extendedByPrototype = Prototype.emptyFunction;

            var pointer = Event.pointer(event);

            Object.extend(event, {
                target: event.srcElement || element,
                relatedTarget: _relatedTarget(event),
                pageX:  pointer.x,
                pageY:  pointer.y
            });

            Object.extend(event, methods);
            Object.extend(event, additionalMethods);

            return event;
        };
    } else {
        Event.extend = Prototype.K;
    }

    if (window.addEventListener) {
        Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
        Object.extend(Event.prototype, methods);
    }

    var EVENT_TRANSLATIONS = {
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    };

    function getDOMEventName(eventName) {
        return EVENT_TRANSLATIONS[eventName] || eventName;
    }

    if (MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED)
        getDOMEventName = Prototype.K;

    function getUniqueElementID(element) {
        if (element === window) return 0;

        if (typeof element._prototypeUID === 'undefined')
            element._prototypeUID = Element.Storage.UID++;
        return element._prototypeUID;
    }

    function getUniqueElementID_IE(element) {
        if (element === window) return 0;
        if (element == document) return 1;
        return element.uniqueID;
    }

    if ('uniqueID' in DIV)
        getUniqueElementID = getUniqueElementID_IE;

    function isCustomEvent(eventName) {
        return eventName.include(':');
    }

    Event._isCustomEvent = isCustomEvent;

    function getRegistryForElement(element, uid) {
        var CACHE = GLOBAL.Event.cache;
        if (Object.isUndefined(uid))
            uid = getUniqueElementID(element);
        if (!CACHE[uid]) CACHE[uid] = { element: element };
        return CACHE[uid];
    }

    function destroyRegistryForElement(element, uid) {
        if (Object.isUndefined(uid))
            uid = getUniqueElementID(element);
        delete GLOBAL.Event.cache[uid];
    }


    function register(element, eventName, handler) {
        var registry = getRegistryForElement(element);
        if (!registry[eventName]) registry[eventName] = [];
        var entries = registry[eventName];

        var i = entries.length;
        while (i--)
            if (entries[i].handler === handler) return null;

        var uid = getUniqueElementID(element);
        var responder = GLOBAL.Event._createResponder(uid, eventName, handler);
        var entry = {
            responder: responder,
            handler:   handler
        };

        entries.push(entry);
        return entry;
    }

    function unregister(element, eventName, handler) {
        var registry = getRegistryForElement(element);
        var entries = registry[eventName];
        if (!entries) return;

        var i = entries.length, entry;
        while (i--) {
            if (entries[i].handler === handler) {
                entry = entries[i];
                break;
            }
        }

        if (!entry) return;

        var index = entries.indexOf(entry);
        entries.splice(index, 1);

        return entry;
    }


    function observe(element, eventName, handler) {
        element = $(element);
        var entry = register(element, eventName, handler);

        if (entry === null) return element;

        var responder = entry.responder;
        if (isCustomEvent(eventName))
            observeCustomEvent(element, eventName, responder);
        else
            observeStandardEvent(element, eventName, responder);

        return element;
    }

    function observeStandardEvent(element, eventName, responder) {
        var actualEventName = getDOMEventName(eventName);
        if (element.addEventListener) {
            element.addEventListener(actualEventName, responder, false);
        } else {
            element.attachEvent('on' + actualEventName, responder);
        }
    }

    function observeCustomEvent(element, eventName, responder) {
        if (element.addEventListener) {
            element.addEventListener('dataavailable', responder, false);
        } else {
            element.attachEvent('ondataavailable', responder);
            element.attachEvent('onlosecapture',   responder);
        }
    }

    function stopObserving(element, eventName, handler) {
        element = $(element);
        var handlerGiven = !Object.isUndefined(handler),
            eventNameGiven = !Object.isUndefined(eventName);

        if (!eventNameGiven && !handlerGiven) {
            stopObservingElement(element);
            return element;
        }

        if (!handlerGiven) {
            stopObservingEventName(element, eventName);
            return element;
        }

        var entry = unregister(element, eventName, handler);

        if (!entry) return element;
        removeEvent(element, eventName, entry.responder);
        return element;
    }

    function stopObservingStandardEvent(element, eventName, responder) {
        var actualEventName = getDOMEventName(eventName);
        if (element.removeEventListener) {
            element.removeEventListener(actualEventName, responder, false);
        } else {
            element.detachEvent('on' + actualEventName, responder);
        }
    }

    function stopObservingCustomEvent(element, eventName, responder) {
        if (element.removeEventListener) {
            element.removeEventListener('dataavailable', responder, false);
        } else {
            element.detachEvent('ondataavailable', responder);
            element.detachEvent('onlosecapture',   responder);
        }
    }



    function stopObservingElement(element) {
        var uid = getUniqueElementID(element), registry = GLOBAL.Event.cache[uid];
        if (!registry) return;

        destroyRegistryForElement(element, uid);

        var entries, i;
        for (var eventName in registry) {
            if (eventName === 'element') continue;

            entries = registry[eventName];
            i = entries.length;
            while (i--)
                removeEvent(element, eventName, entries[i].responder);
        }
    }

    function stopObservingEventName(element, eventName) {
        var registry = getRegistryForElement(element);
        var entries = registry[eventName];
        if (!entries) return;
        delete registry[eventName];

        var i = entries.length;
        while (i--)
            removeEvent(element, eventName, entries[i].responder);
    }


    function removeEvent(element, eventName, handler) {
        if (isCustomEvent(eventName))
            stopObservingCustomEvent(element, eventName, handler);
        else
            stopObservingStandardEvent(element, eventName, handler);
    }



    function getFireTarget(element) {
        if (element !== document) return element;
        if (document.createEvent && !element.dispatchEvent)
            return document.documentElement;
        return element;
    }

    function fire(element, eventName, memo, bubble) {
        element = getFireTarget($(element));
        if (Object.isUndefined(bubble)) bubble = true;
        memo = memo || {};

        var event = fireEvent(element, eventName, memo, bubble);
        return Event.extend(event);
    }

    function fireEvent_DOM(element, eventName, memo, bubble) {
        var event = document.createEvent('HTMLEvents');
        event.initEvent('dataavailable', bubble, true);

        event.eventName = eventName;
        event.memo = memo;

        element.dispatchEvent(event);
        return event;
    }

    function fireEvent_IE(element, eventName, memo, bubble) {
        var event = document.createEventObject();
        event.eventType = bubble ? 'ondataavailable' : 'onlosecapture';

        event.eventName = eventName;
        event.memo = memo;

        element.fireEvent(event.eventType, event);
        return event;
    }

    var fireEvent = document.createEvent ? fireEvent_DOM : fireEvent_IE;



    Event.Handler = Class.create({
        initialize: function(element, eventName, selector, callback) {
            this.element   = $(element);
            this.eventName = eventName;
            this.selector  = selector;
            this.callback  = callback;
            this.handler   = this.handleEvent.bind(this);
        },


        start: function() {
            Event.observe(this.element, this.eventName, this.handler);
            return this;
        },

        stop: function() {
            Event.stopObserving(this.element, this.eventName, this.handler);
            return this;
        },

        handleEvent: function(event) {
            var element = Event.findElement(event, this.selector);
            if (element) this.callback.call(this.element, event, element);
        }
    });

    function on(element, eventName, selector, callback) {
        element = $(element);
        if (Object.isFunction(selector) && Object.isUndefined(callback)) {
            callback = selector, selector = null;
        }

        return new Event.Handler(element, eventName, selector, callback).start();
    }

    Object.extend(Event, Event.Methods);

    Object.extend(Event, {
        fire:          fire,
        observe:       observe,
        stopObserving: stopObserving,
        on:            on
    });

    Element.addMethods({
        fire:          fire,

        observe:       observe,

        stopObserving: stopObserving,

        on:            on
    });

    Object.extend(document, {
        fire:          fire.methodize(),

        observe:       observe.methodize(),

        stopObserving: stopObserving.methodize(),

        on:            on.methodize(),

        loaded:        false
    });

    if (GLOBAL.Event) Object.extend(window.Event, Event);
    else GLOBAL.Event = Event;

    GLOBAL.Event.cache = {};

    function destroyCache_IE() {
        GLOBAL.Event.cache = null;
    }

    if (window.attachEvent)
        window.attachEvent('onunload', destroyCache_IE);

    DIV = null;
    docEl = null;
})(this);

(function(GLOBAL) {
    /* Code for creating leak-free event responders is based on work by
     John-David Dalton. */

    var docEl = document.documentElement;
    var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
        && 'onmouseleave' in docEl;

    function isSimulatedMouseEnterLeaveEvent(eventName) {
        return !MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &&
            (eventName === 'mouseenter' || eventName === 'mouseleave');
    }

    function createResponder(uid, eventName, handler) {
        if (Event._isCustomEvent(eventName))
            return createResponderForCustomEvent(uid, eventName, handler);
        if (isSimulatedMouseEnterLeaveEvent(eventName))
            return createMouseEnterLeaveResponder(uid, eventName, handler);

        return function(event) {
            if (!Event.cache) return;

            var element = Event.cache[uid].element;
            Event.extend(event, element);
            handler.call(element, event);
        };
    }

    function createResponderForCustomEvent(uid, eventName, handler) {
        return function(event) {
            var element = Event.cache[uid].element;

            if (Object.isUndefined(event.eventName))
                return false;

            if (event.eventName !== eventName)
                return false;

            Event.extend(event, element);
            handler.call(element, event);
        };
    }

    function createMouseEnterLeaveResponder(uid, eventName, handler) {
        return function(event) {
            var element = Event.cache[uid].element;

            Event.extend(event, element);
            var parent = event.relatedTarget;

            while (parent && parent !== element) {
                try { parent = parent.parentNode; }
                catch(e) { parent = element; }
            }

            if (parent === element) return;
            handler.call(element, event);
        }
    }

    GLOBAL.Event._createResponder = createResponder;
    docEl = null;
})(this);

(function(GLOBAL) {
    /* Support for the DOMContentLoaded event is based on work by Dan Webb,
     Matthias Miller, Dean Edwards, John Resig, and Diego Perini. */

    var TIMER;

    function fireContentLoadedEvent() {
        if (document.loaded) return;
        if (TIMER) window.clearTimeout(TIMER);
        document.loaded = true;
        document.fire('dom:loaded');
    }

    function checkReadyState() {
        if (document.readyState === 'complete') {
            document.detachEvent('onreadystatechange', checkReadyState);
            fireContentLoadedEvent();
        }
    }

    function pollDoScroll() {
        try {
            document.documentElement.doScroll('left');
        } catch (e) {
            TIMER = pollDoScroll.defer();
            return;
        }

        fireContentLoadedEvent();
    }


    if (document.readyState === 'complete') {
        fireContentLoadedEvent();
        return;
    }

    if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
    } else {
        document.attachEvent('onreadystatechange', checkReadyState);
        if (window == top) TIMER = pollDoScroll.defer();
    }

    Event.observe(window, 'load', fireContentLoadedEvent);
})(this);


Element.addMethods();
/*------------------------------- DEPRECATED -------------------------------*/

Hash.toQueryString = Object.toQueryString;

var Toggle = { display: Element.toggle };

Element.Methods.childOf = Element.Methods.descendantOf;

var Insertion = {
    Before: function(element, content) {
        return Element.insert(element, {before:content});
    },

    Top: function(element, content) {
        return Element.insert(element, {top:content});
    },

    Bottom: function(element, content) {
        return Element.insert(element, {bottom:content});
    },

    After: function(element, content) {
        return Element.insert(element, {after:content});
    }
};

var $continue = new Error('"throw $continue" is deprecated, use "return" instead');

var Position = {
    includeScrollOffsets: false,

    prepare: function() {
        this.deltaX =  window.pageXOffset
            || document.documentElement.scrollLeft
            || document.body.scrollLeft
            || 0;
        this.deltaY =  window.pageYOffset
            || document.documentElement.scrollTop
            || document.body.scrollTop
            || 0;
    },

    within: function(element, x, y) {
        if (this.includeScrollOffsets)
            return this.withinIncludingScrolloffsets(element, x, y);
        this.xcomp = x;
        this.ycomp = y;
        this.offset = Element.cumulativeOffset(element);

        return (y >= this.offset[1] &&
        y <  this.offset[1] + element.offsetHeight &&
        x >= this.offset[0] &&
        x <  this.offset[0] + element.offsetWidth);
    },

    withinIncludingScrolloffsets: function(element, x, y) {
        var offsetcache = Element.cumulativeScrollOffset(element);

        this.xcomp = x + offsetcache[0] - this.deltaX;
        this.ycomp = y + offsetcache[1] - this.deltaY;
        this.offset = Element.cumulativeOffset(element);

        return (this.ycomp >= this.offset[1] &&
        this.ycomp <  this.offset[1] + element.offsetHeight &&
        this.xcomp >= this.offset[0] &&
        this.xcomp <  this.offset[0] + element.offsetWidth);
    },

    overlap: function(mode, element) {
        if (!mode) return 0;
        if (mode == 'vertical')
            return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
                element.offsetHeight;
        if (mode == 'horizontal')
            return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
                element.offsetWidth;
    },


    cumulativeOffset: Element.Methods.cumulativeOffset,

    positionedOffset: Element.Methods.positionedOffset,

    absolutize: function(element) {
        Position.prepare();
        return Element.absolutize(element);
    },

    relativize: function(element) {
        Position.prepare();
        return Element.relativize(element);
    },

    realOffset: Element.Methods.cumulativeScrollOffset,

    offsetParent: Element.Methods.getOffsetParent,

    page: Element.Methods.viewportOffset,

    clone: function(source, target, options) {
        options = options || { };
        return Element.clonePosition(target, source, options);
    }
};

/*--------------------------------------------------------------------------*/

if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
    function iter(name) {
        return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";
    }

    instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
        function(element, className) {
            className = className.toString().strip();
            var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
            return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
        } : function(element, className) {
        className = className.toString().strip();
        var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
        if (!classNames && !className) return elements;

        var nodes = $(element).getElementsByTagName('*');
        className = ' ' + className + ' ';

        for (var i = 0, child, cn; child = nodes[i]; i++) {
            if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
                (classNames && classNames.all(function(name) {
                    return !name.toString().blank() && cn.include(' ' + name + ' ');
                }))))
                elements.push(Element.extend(child));
        }
        return elements;
    };

    return function(className, parentElement) {
        return $(parentElement || document.body).getElementsByClassName(className);
    };
}(Element.Methods);

/*--------------------------------------------------------------------------*/

Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
    initialize: function(element) {
        this.element = $(element);
    },

    _each: function(iterator, context) {
        this.element.className.split(/\s+/).select(function(name) {
            return name.length > 0;
        })._each(iterator, context);
    },

    set: function(className) {
        this.element.className = className;
    },

    add: function(classNameToAdd) {
        if (this.include(classNameToAdd)) return;
        this.set($A(this).concat(classNameToAdd).join(' '));
    },

    remove: function(classNameToRemove) {
        if (!this.include(classNameToRemove)) return;
        this.set($A(this).without(classNameToRemove).join(' '));
    },

    toString: function() {
        return $A(this).join(' ');
    }
};

Object.extend(Element.ClassNames.prototype, Enumerable);

/*--------------------------------------------------------------------------*/

(function() {
    window.Selector = Class.create({
        initialize: function(expression) {
            this.expression = expression.strip();
        },

        findElements: function(rootElement) {
            return Prototype.Selector.select(this.expression, rootElement);
        },

        match: function(element) {
            return Prototype.Selector.match(element, this.expression);
        },

        toString: function() {
            return this.expression;
        },

        inspect: function() {
            return "#<Selector: " + this.expression + ">";
        }
    });

    Object.extend(Selector, {
        matchElements: function(elements, expression) {
            var match = Prototype.Selector.match,
                results = [];

            for (var i = 0, length = elements.length; i < length; i++) {
                var element = elements[i];
                if (match(element, expression)) {
                    results.push(Element.extend(element));
                }
            }
            return results;
        },

        findElement: function(elements, expression, index) {
            index = index || 0;
            var matchIndex = 0, element;
            for (var i = 0, length = elements.length; i < length; i++) {
                element = elements[i];
                if (Prototype.Selector.match(element, expression) && index === matchIndex++) {
                    return Element.extend(element);
                }
            }
        },

        findChildElements: function(element, expressions) {
            var selector = expressions.toArray().join(', ');
            return Prototype.Selector.select(selector, element || document);
        }
    });
})();




















// Non-Lively Compatibility
if (!window.module) {
    window.module = function(dottedPath) {
        if (dottedPath == '') return window;
        var path = dottedPath.split('.'),

            name = path.pop(),
            parent = module(path.join('.'));
        if (!parent[name]) parent[name] = {
            requires: function(ignored) { return this; },
            toRun: function(code) { code(); },
            uri: function() {}
        };
        return parent[name];
    };
    JSLoader = {
        loadJs: function() {}
    };
    window.URL = {};

    window.Properties = {
        all: function(object, predicate) {
            var a = [];
            for (var name in object) {
                if ((object.__lookupGetter__(name) ||
                    !Object.isFunction(object[name])) &&
                    (predicate ? predicate(name, object) : true)) {
                    a.push(name);
                }
            }
            return a;
        },

        allOwnPropertiesOrFunctions: function(obj, predicate) {
            var result = [];
            Object.getOwnPropertyNames(obj).forEach(function(name) {
                if (predicate(obj, name))
                    result.push(name);
            });
            return result;
        },

        own: function(object) {
            var a = [];
            for (var name in object) {
                if (object.hasOwnProperty(name) &&
                    (object.__lookupGetter__(name) ||
                    !Object.isFunction(object[name]))) {
                    a.push(name);
                }
            }
            return a;
        },

        forEachOwn: function(object, func, context) {
            var result = [];
            for (var name in object) {
                if (!object.hasOwnProperty(name)) continue;
                var value = object[name];
                if (!Object.isFunction(value)) {
                    result.push(func.call(context || this, name, value));
                }
            }
            return result;
        },

        nameFor: function(object, value) {
            for (var name in object) { if (object[name] === value) return name; }
            return undefined;
        },

        values: function(obj) {
            var values = [];
            for (var name in obj) { values.push(obj[name]); }
            return values;
        },

        ownValues: function(obj) {
            var values = [];
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) values.push(obj[name]);
            }
            return values;
        },

        printObjectSize: function(obj) {
            return Numbers.humanReadableByteSize(JSON.stringify(obj).length);
        },

        any: function(obj, predicate) {
            for (var name in obj) { if (predicate(obj, name)) return true; }
            return false;
        },

        allProperties: function(obj, predicate) {
            var result = [];
            for (var name in obj) {
                if (predicate(obj, name)) result.push(name);
            }
            return result;
        },

        hash: function(obj) {
            return Object.keys(obj).sort().join('').hashCode();
        }

    };
    window.Config = {};
    window.cop = {};
    window.Global = window;
    var Module = function() { return null; };
    window.lively = new Module();
    lively.Class = Class;
    lively.Module = Module;
    window.dbgOn = (function(b) { if (b) { debugger } });

    function __oldNamespace(spec, context) {
        var i, N;
        context = context || window;
        spec = spec.valueOf();
        if (typeof spec === 'object') {
            if (typeof spec.length === 'number') {
                //assume an array-like object
                for (i = 0, N = spec.length; i < N; i++) {
                    return namespace(spec[i], context);
                }
            } else {
                //spec is a specification object
                for (i in spec) if (spec.hasOwnProperty(i)) {
                    context[i] = context[i];
                    //recursively descend tree
                    return namespace(spec[i], context[i]);
                }
            }
        } else if (typeof spec === 'string') {
            (function handleStringCase() {
                var parts;
                parts = spec.split('.');
                for (i = 0, N = parts.length; i < N; i++) {
                    spec = parts[i];
                    context[spec] = context[spec] || {};
                    context = context[spec];
                }
            })();
            return context;
        } else {
            throw new TypeError();
        }
    }

    function namespace(spec, context) {
        var codeDB;
        if (spec[0] == '$') {
            codeDB = spec.substring(1, spec.indexOf('.'));
            spec = spec.substring(spec.indexOf('.') + 1);
        }
        var ret = __oldNamespace(spec, context);
        if (codeDB) {
            ret.fromDB = codeDB;
        }
        return ret;
    }

    Object.extend(Class, {
        isClass: function Class$isClass(object) {
            if (object === Object ||
                object === Array ||
                object === Function ||
                object === String ||
                object === Boolean ||
                object === Date ||
                object === RegExp ||
                object === Number) {
                return true;
            }
            return (object instanceof Function) &&
                (object.superclass !== undefined);
        },
        namespaceFor: function Class$namespaceFor(className) {
            // get the namespace object given the qualified name
            var lastDot = className.lastIndexOf('.');
            if (lastDot < 0) return window;
            else return namespace(className.substring(0, lastDot));
        },
        unqualifiedNameFor: function Class$unqualifiedNameFor(name) {
            var lastDot = name.lastIndexOf('.'); // lastDot may be -1
            var unqualifiedName = name.substring(lastDot + 1);
            return unqualifiedName;
        }
    });

    Object.extend(Function.prototype, {
        subclass: function(/*... */) {
            var args = $A(arguments),
                className = args.shift(),
                targetScope = Global,
                shortName = null;

            if (className) {
                targetScope = lively.Class.namespaceFor(className);
                shortName = lively.Class.unqualifiedNameFor(className);
            } else {
                shortName = 'anonymous_' + (lively.Class.anonymousCounter++);
                className = shortName;
            }

            var klass;
            if (className &&
                targetScope[shortName] &&
                (targetScope[shortName].superclass === this)) {
                // preserve the class to allow using the subclass
                // construct in interactive development
                klass = targetScope[shortName];
            } else {
                klass = function() {
                    if (this.initialize) this.initialize.apply(this, arguments);
                    return this;
                };
                klass.name = shortName;
                klass.superclass = this;
                var protoclass = function() { };
                protoclass.prototype = this.prototype;
                klass.prototype = new protoclass();
                klass.prototype.constructor = klass;
                klass.prototype.constructor.type = className;
                klass.prototype.constructor.displayName = className;
                if (className) targetScope[shortName] = klass;

                // remember the module that contains the class def
                if (Global.lively && lively.Module && lively.Module.current)
                    klass.sourceModule = lively.Module.current();
            }

            // the remaining args should be category strings or source objects
            this.addMethods.apply(klass, args);

            if (!klass.prototype.initialize)
                klass.prototype.initialize = function() {};

            return klass;
        },

        addMethods: function(/*...*/) {
            var args = arguments;
            for (var i = 0; i < args.length; i++) {
                if (!Object.isString(args[i])) { // ignore categories
                    this.addCategorizedMethods(
                        args[i] instanceof Function ? (args[i])() : args[i]
                    );
                }
            }
        },

        addCategorizedMethods: function(source) {
            var ancestor = this.superclass && this.superclass.prototype;

            var className = this.type || 'Anonymous';

            for (var property in source) {

                if (property == 'constructor') continue;

                var getter = source.__lookupGetter__(property);
                if (getter) this.prototype.__defineGetter__(property, getter);
                var setter = source.__lookupSetter__(property);
                if (setter) this.prototype.__defineSetter__(property, setter);
                if (getter || setter) continue;

                var value = source[property];
                // weirdly, RegExps are functions in Safari, so testing for
                // Object.isFunction on regexp field values will return true.
                // But they're not full-blown functions and don't
                // inherit argumentNames from Function.prototype

                var hasSuperCall = (ancestor &&
                Object.isFunction(value) &&
                value.argumentNames &&
                value.argumentNames().first() == '$super');
                if (hasSuperCall) {
                    // wrapped in a function to save the value of 'method' for advice
                    (function() {
                        var method = value;
                        var advice = (function(m) {
                            return function callSuper() {
                                var method = ancestor[m];
                                if (!method)
                                    throw new Error(
                                        Strings.format(
                                            'Trying to call super of %s>>%s ' +
                                            'but no super method in %s',
                                            className,
                                            m,
                                            ancestor.constructor.type
                                        )
                                    );
                                return method.apply(this, arguments);
                            };
                        })(property);

                        advice.methodName = ('$super:' +
                        (this.superclass ?
                        this.superclass.type + '>>' :
                            '') +
                        property);

                        value = Object.extend(advice.wrap(method), {
                            valueOf: function() { return method },
                            toString: function() { return method.toString() },
                            originalFunction: method
                        });
                        // for lively.Closures
                        method.varMapping = {$super: advice};
                    })();
                }

                this.prototype[property] = value;

                if (Object.isFunction(value)) {
                    // remember name for profiling in WebKit
                    value.displayName = className + '$' + property;
                    for (; value; value = value.originalFunction) {
                        value.declaredClass = this.prototype.constructor.type;
                        value.methodName = property;
                    }
                }
            } // end of for (var property in source)

            return this;
        },

        binds: function() { return this; },

        getVarMapping: function() { return this.varMapping; }
    });

    var lutUUID = [];
    for (var i = 0; i < 256; i++) lutUUID[i] = (i < 16 ? '0' : '') + (i).toString(16);
    window.Strings = {
        newUUID: function() {
            // fastest implementation I found. Stolen from
            // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
            var d0 = Math.random() * 0xffffffff | 0;
            var d1 = Math.random() * 0xffffffff | 0;
            var d2 = Math.random() * 0xffffffff | 0;
            var d3 = Math.random() * 0xffffffff | 0;
            return lutUUID[d0 & 0xff] + lutUUID[d0 >> 8 & 0xff] +
                lutUUID[d0 >> 16 & 0xff] + lutUUID[d0 >> 24 & 0xff] + '-' +
                lutUUID[d1 & 0xff] + lutUUID[d1 >> 8 & 0xff] + '-' +
                lutUUID[d1 >> 16 & 0x0f | 0x40] + lutUUID[d1 >> 24 & 0xff] + '-' +
                lutUUID[d2 & 0x3f | 0x80] + lutUUID[d2 >> 8 & 0xff] + '-' +
                lutUUID[d2 >> 16 & 0xff] + lutUUID[d2 >> 24 & 0xff] +
                lutUUID[d3 & 0xff] + lutUUID[d3 >> 8 & 0xff] +
                lutUUID[d3 >> 16 & 0xff] + lutUUID[d3 >> 24 & 0xff];
        },

        format: function Strings$format() {
            return Strings.formatFromArray(Array.from(arguments));
        },

        // adapted from firebug lite
        formatFromArray: function Strings$formatFromArray(objects) {
            var self = objects.shift();
            if (!self) {
                console.log('Error in Strings>>formatFromArray, arg1 undefined');
            }

            function appendText(object, string) {
                return '' + object;
            }

            function appendInteger(value, string) {
                return value.toString();
            }

            function appendFloat(value, string, precision) {
                if (precision > -1) return value.toFixed(precision);
                else return value.toString();
            }

            function appendObject(value, string) {
                return Objects.inspect(value);
            }

            var appenderMap = {
                s: appendText,
                d: appendInteger,
                i: appendInteger,
                f: appendFloat,
                o: appendObject
            };
            var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;

            function parseFormat(fmt) {
                var oldFmt = fmt;
                var parts = [];

                for (var m = reg.exec(fmt); m; m = reg.exec(fmt)) {
                    var type = m[8] || m[5],
                        appender = type in appenderMap ? appenderMap[type] : appendObject,
                        precision = m[3] ? parseInt(m[3]) : (m[4] == '.' ? -1 : 0);
                    parts.push(fmt.substr(0, m[0][0] == '%' ? m.index : m.index + 1));
                    parts.push({appender: appender, precision: precision});

                    fmt = fmt.substr(m.index + m[0].length);
                }
                if (fmt)
                    parts.push(fmt.toString());

                return parts;
            };

            var parts = parseFormat(self),
                str = '',
                objIndex = 0;

            for (var i = 0; i < parts.length; ++i) {
                var part = parts[i];
                if (part && typeof(part) == 'object') {
                    var object = objects[objIndex++];
                    str += (part.appender || appendText)(object, str, part.precision);
                } else {
                    str += appendText(part, str);
                }
            }
            return str;
        }
    };

    Array.prototype.removeAt = (function(idx) {
        this.splice(idx, 1);
    });

    Array.prototype.remove = (function(obj) {
        var idx = this.indexOf(obj);
        if (idx >= 0) {
            this.removeAt(idx);
        }
    });

    Array.range = (function(begin, end, step) {
        step = step || 1;
        var result = [];
        for (var i = begin; i <= end; i += step) {
            result.push(i);
        }
        return result;
    });

    Array.prototype.equals = (function(otherArray) {
        // Returns true iff each element in `this` is equal (`==`) to its
        // corresponding element in `otherArray`
        var len = this.length;
        if (!otherArray || len !== otherArray.length) return false;
        for (var i = 0; i < len; i++) {
            if (this[i] && otherArray[i] && this[i].equals && otherArray[i].equals) {
                if (!this[i].equals(otherArray[i])) {
                    return false;
                } else {
                    continue;
                }
            }
            if (this[i] != otherArray[i]) return false;
        }
        return true;
    });

    if (typeof(Set) == 'undefined') {
        Global.Set = function() {
            throw 'Set not supported';
        };
    }

    window.alertOK = (function(msg) {
        console.log(msg);
    });
}

/*!
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 *
 */

// @win window reference
// @fn function reference
function contentLoaded(win, fn) {
    var done = false, top = true,

        doc = win.document, root = doc.documentElement,

        add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
        rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
        pre = doc.addEventListener ? '' : 'on',

        init = (function(e) {
            if (e.type == 'readystatechange' && doc.readyState != 'complete')
                return;
            (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);
            if (!done && (done = true))
                fn.call(win, e.type || e);
        }),

        poll = function() {
            try {
                root.doScroll('left');
            } catch (e) {
                setTimeout(poll, 50);
                return;
            }
            init('poll');
        };

    if (doc.readyState == 'complete')
        fn.call(win, 'lazy');
    else {
        if (doc.createEventObject && root.doScroll) {
            try {
                top = !win.frameElement;
            } catch (e) {}
            if (top) poll();
        }
        doc[add](pre + 'DOMContentLoaded', init, false);
        doc[add](pre + 'readystatechange', init, false);
        win[add](pre + 'load', init, false);
    }
}











/*
 * Copyright (c) 2008-2011 Hasso Plattner Institute
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


/*
 * COP Layers for JavaScript
 */

module('cop.Layers').requires().toRun(function(thisModule) {

    /* Private Helpers for Development */

    Config.ignoredepricatedProceed = true;

    var log_layer_code = false;
    var log = function log(string) { if(log_layer_code) console.log(string); };

    /*
     * Private State
     */

    Object.extend(cop, {
        dynamicInlining: Config.copDynamicInlining && !document.URL.include('noDynamicInlining'),
        staticInlining: false,
        proceedStack: [],
        GlobalLayers: [],
// hack, to work around absence of identity dictionaries in JavaScript
// we could perhaps limit ourselfs to layer only those objects that respond to object.id()
// because working with objects is a serialization problem in itself, perhaps we should restrict ourself in working with classes
// So classes have names and names can be used as keys in dictionaries :-)
        object_id_counter: 0,
    });

    /*
     * Private Methods
     */
    Object.extend(cop, {

        // for debbuggin ContextJS itself
        withLogLayerCode: function(func) {
            try {
                var old  = log_layer_code;
                log_layer_code = true;
                func();
            } finally {
                log_layer_code = old;
            }
        },

        getLayerDefinitionForObject: function(layer, object) {
            // log("cop.getLayerDefinitionForObject(" + layer + "," + object +")")
            if (!layer || !object) return;
            var result = layer[object._layer_object_id];
            return result ? result : cop.getLayerDefinitionForObject(layer, object.prototype);
        },


        ensurePartialLayer: function(layer, object) {
            if (!layer)
                throw new Error("in ensurePartialLayer: layer is nil");
            if (!object.hasOwnProperty("_layer_object_id"))
                object._layer_object_id = cop.object_id_counter++;
            if (!layer[object._layer_object_id])
                layer[object._layer_object_id] = {_layered_object: object};
            return layer[object._layer_object_id];
        },

        layerMethod: function(layer, object,  property, func) {
            cop.ensurePartialLayer(layer, object)[property] = func;
            func.displayName = "layered " + layer.name + " " + (object.constructor ? (object.constructor.type + "$"): "") + property;
            cop.makeFunctionLayerAware(object, property, layer.isHidden);
            Object.isFunction(object.getName) && (layer.layeredFunctionsList[object][property] = true)
        },

        layerGetterMethod: function(layer, object, property, getter) {
            cop.ensurePartialLayer(layer, object).__defineGetter__(property, getter);
        },

        layerSetterMethod: function(layer, object, property, setter) {
            cop.ensurePartialLayer(layer, object).__defineSetter__(property, setter);
        },

        layerProperty: function(layer, object,  property, defs) {
            var getter = defs.__lookupGetter__(property);
            if (getter) cop.layerGetterMethod(layer, object, property, getter);

            var setter = defs.__lookupSetter__(property);
            if (setter) cop.layerSetterMethod(layer, object, property, setter);

            if (getter || setter) cop.makePropertyLayerAware(object, property);
            else cop.layerMethod(layer, object,  property, defs[property]);
        },

        layerPropertyWithShadow: function(layer, object, property) {
            // shadowing does not work with current implementation
            // see the shadow tests in LayersTest
            var defs = {},
                baseValue = object[property],
                layeredPropName = "_layered_" + layer.getName() + "_" + property;
            defs.__defineGetter__(property, function layeredGetter() {
                return this[layeredPropName] === undefined ? cop.proceed() : this[layeredPropName];
            }.binds({layeredPropName: layeredPropName, baseValue: baseValue}));
            defs.__defineSetter__(property, function layeredSetter(v) {
                this[layeredPropName] = v;
            }.binds({layeredPropName: layeredPropName}));
            cop.layerProperty(layer, object, property, defs);
        },

        computeLayersFor: function Layers$computeLayersFor(obj) {
            return obj && obj.activeLayers ? obj.activeLayers(cop.currentLayers) : cop.currentLayers();
        },

        composeLayers: function(stack) {
            var result = cop.GlobalLayers.clone();
            for (var i = 0; i < stack.length; i++) {
                var current = stack[i];
                if (current.withLayers)
                    result = result.without.apply(result, current.withLayers).concat(current.withLayers)
                else if (current.withoutLayers)
                    result = result.without.apply(result, current.withoutLayers);
            }
            return result;
        },

        currentLayers: function() {
            if (cop.LayerStack.length == 0)
                throw new Error("The default layer is missing");

            // NON OPTIMIZED VERSION FOR STATE BASED LAYER ACTIVATION
            var current = cop.LayerStack.last();
            if (!current.composition || (cop.dynamicInlining && !current.composition.hash)) {
                current.composition = cop.composeLayers(cop.LayerStack);
                if (cop.dynamicInlining)
                    current.composition.hash = cop.computeHashForLayers(current.composition);
            }

            return current.composition;
        },

        // clear cached layer compositions
        invalidateLayerComposition: function() {
            cop.LayerStack.forEach(function(ea) { ea.composition = null });
        },

        resetLayerStack: function() {
            cop.LayerStack = [{
                isStatic: true,
                toString: function() { return "BaseLayer" },
                composition: null
            }];
            cop.invalidateLayerComposition();
        },

        lookupLayeredFunctionForObject: function(self, layer, function_name, methodType, n) {
            if (!layer) return undefined;
            // we have to look for layer defintions in self, self.prototype,
            // ... there may be layered methods in a subclass of "obj"
            var layered_function,
                layer_definition_for_object = cop.getLayerDefinitionForObject(layer, self);
            if (layer_definition_for_object) {
                // log("  found layer definitions for object");
                // TODO: optional proceed goes here....
                if (methodType == 'getter') {
                    layered_function = layer_definition_for_object.__lookupGetter__(function_name);
                } else if (methodType == 'setter'){
                    layered_function = layer_definition_for_object.__lookupSetter__(function_name);
                } else {
                    if (layer_definition_for_object.hasOwnProperty(function_name))
                        layered_function = layer_definition_for_object[function_name];
                }
            }
            if (!layered_function) {
                // try the superclass hierachy
                // log("look for superclass of: " + self.constructor)
                var superclass = self.constructor.superclass;
                if (superclass) {
                    foundClass = superclass;
                    // log("layered function is not found in this partial method, lookup for my prototype?")
                    return cop.lookupLayeredFunctionForObject(superclass.prototype, layer, function_name, methodType);
                } else {
                    // log("obj has not prototype")
                }
            }
            return layered_function;
        },

        pvtMakeFunctionOrPropertyLayerAware: function(obj, slotName, baseValue, type, isHidden) {
            // install in obj[slotName] a cop wrapper that weaves partial methods
            // into real method (baseValue)

            if (baseValue.isLayerAware) return;

            if (cop.staticInlining)
                return cop.makeSlotLayerAwareWithStaticInlining(obj, slotName, baseValue, type)

            if (cop.dynamicInlining)
                return cop.makeSlotLayerAwareWithDynamicInlining(obj, slotName, baseValue, type)

            cop.makeSlotLayerAwareWithNormalLookup(obj, slotName, baseValue, type, isHidden);
        },
        makeSlotLayerAwareWithNormalLookup: function(obj, slotName, baseValue, type, isHidden) {
            var wrapped_function = function() {
                var composition = new cop.PartialLayerComposition(
                    this, obj, slotName, baseValue, type);
                cop.proceedStack.push(composition);
                try {
                    return cop.proceed.apply(this, arguments);
                } finally {
                    cop.proceedStack.pop()
                };
            };
            wrapped_function.isLayerAware = true;
            // this is more declarative outside of COP context
            wrapped_function.isContextJSWrapper = true;

            if (isHidden)
                wrapped_function.toString = function () {return this.getOriginal().toString()}

            // For wrapped_function.getOriginal()
            wrapped_function.originalFunction = baseValue;

            if (type == "getter") {
                obj.__defineGetter__(slotName, wrapped_function);
            } else if (type == "setter") {
                obj.__defineSetter__(slotName, wrapped_function);
            } else {
                obj[slotName] = wrapped_function;
            }
        },

        makeFunctionLayerAware: function(base_obj, function_name, isHidden) {
            if (!base_obj) throw new Error("can't layer an non existent object");

            /* ensure base function */
            var base_function = base_obj[function_name];
            if (!base_function) {
                // console.log("WARNING can't layer an non existent function" + function_name +" , so do nothing")
                // return;
                base_function = function() { return null; };
            };
            cop.pvtMakeFunctionOrPropertyLayerAware(base_obj, function_name, base_function, undefined, isHidden)
        },

        makePropertyLayerAware: function(baseObj, property) {
            if (!baseObj) throw new Error("can't layer an non existent object");

            // ensure base getter and setter
            var getter = baseObj.__lookupGetter__(property),
                propName = "__layered_" + property + "__";
            if (!getter) {
                // does not work when dealing with classes and instances...
                baseObj[propName] = baseObj[property]; // take over old value
                getter = function() { return this[propName] }.binds({propName: propName});
                baseObj.__defineGetter__(property, getter);
            };
            var setter = baseObj.__lookupSetter__(property);
            if (!setter) {
                setter = function(value) { return this[propName] = value }.binds({propName: propName});
                baseObj.__defineSetter__(property, setter);
            };

            cop.pvtMakeFunctionOrPropertyLayerAware(baseObj, property, getter, 'getter');
            cop.pvtMakeFunctionOrPropertyLayerAware(baseObj, property, setter, 'setter');
        },
        makeFunctionLayerUnaware: function(base_obj, function_name) {
            if (!base_obj)
                throw new Error("need object to makeFunctionLayerUnaware");

            var prevFunction;
            var currentFunction = base_obj[function_name];

            if (currentFunction === undefined)
                return; // nothing to do here


            while (typeof currentFunction.originalFunction == 'function' &&
            !currentFunction.isLayerAware) {

                var prevFunction = currentFunction;
                currentFunction = currentFunction.originalFunction
            }

            if (!(currentFunction.isLayerAware))
                return; // nothing to do here

            var originalFunction = currentFunction.originalFunction

            if (!(originalFunction instanceof Function))
                throw new Error("makeFunctionLayerUnaware Error: no orignal function");

            if (prevFunction instanceof Function) {
                prevFunction.originalFunction = originalFunction
            } else {
                base_obj[function_name] = originalFunction
            }
        },

        uninstallLayersInObject: function(object) {
            Functions.own(object).forEach(function(ea){
                cop.makeFunctionLayerUnaware(object, ea)
            })
        },

        // cop.uninstallLayersInAllClasses()
        uninstallLayersInAllClasses: function() {

            Global.classes(true).forEach(function(ea) {
                cop.uninstallLayersInObject(ea.prototype)
            })
        },

        allLayers: function(optObject) {
            // does not really return all layers... layers in namespaces are not found!
            // therefore you can query all layers in an optObject
            return Object.values(optObject || Global).select(function(ea) { return ea instanceof Layer})
        }
    });

    /* PUPLIC COP  Layer Definition */
    Object.extend(cop, {
        // creates a named global layer
        create: function(name, silent) {
            var context = lively.Class.namespaceFor(name),
                layerName = lively.Class.unqualifiedNameFor(name);
            return context[layerName] = cop.basicCreate(layerName, context);
        },
        basicCreate: function(layerName, context) {
            context = context || Global;
            return context[layerName] || new Layer(layerName, context.namespaceIdentifier);
        },


        // DEPRICATED
        layer: function(name) {
            console.log("SyntaxDepricated: cop.layer(... use cop.create(")
            return cop.create(name, true);
        },

        // DEPRICATED
        createLayer: function(name) {
            console.log("SyntaxDepricated: cop.createLayer(... use cop.create(")
            return cop.create(name, false);
        },

        // Layering objects may be a garbage collection problem, because the layers keep strong reference to the objects
        layerObject: function(layer, object, defs) {
            // log("cop.layerObject");
            Object.isFunction(object.getName) && (layer.layeredFunctionsList[object] =  {})
            Object.keys(defs).forEach(function(function_name) {
                // log(" layer property: " + function_name);
                cop.layerProperty(layer, object, function_name, defs);
            });
        },

        // layer around only the class methods
        layerClass: function(layer, classObject, defs) {
            if (!classObject || !classObject.prototype) {
                throw new Error("ContextJS: can not refine class '" +
                    classObject +  "' in " + layer);
            }
            cop.layerObject(layer, classObject.prototype, defs);
        },

        // layer around class methods and all subclass methods
        // (might be related to Aspect oriented programming)
        layerClassAndSubclasses: function(layer, classObject, defs) {
            // log("layerClassAndSubclasses");
            cop.layerClass(layer, classObject, defs);

            // and now wrap all overriden methods...
            classObject.allSubclasses().forEach(function(eaClass) {
                // log("make m1 layer aware in " + eaClass)
                var obj = eaClass.prototype;
                Object.keys(defs).forEach(function(eaFunctionName) {
                    if (obj.hasOwnProperty(eaFunctionName)) {
                        if (obj[eaFunctionName] instanceof Function) {
                            cop.makeFunctionLayerAware(obj, eaFunctionName);
                        } else {
                            // to be tested...
                            // cop.makePropertyLayerAware(eaClass.prototype, m1)
                        }
                    };
                });
            });
        },

        /* Layer Activation */
        withLayers: function withLayers(layers, func) {
            cop.LayerStack.push({withLayers: layers});
            // console.log("callee: " + cop.withLayers.caller)
            try {
                return func();
            } finally {
                cop.LayerStack.pop();
            }
        },

        withoutLayers: function withoutLayers(layers, func) {
            cop.LayerStack.push({withoutLayers: layers});
            try {
                return func();
            } finally {
                cop.LayerStack.pop();
            }
        },


        /* Global Layer Activation */
        enableLayer: function(layer) {
            if (cop.GlobalLayers.include(layer)) return;
            cop.GlobalLayers.push(layer);
            cop.invalidateLayerComposition();
        },

        disableLayer: function(layer) {
            var idx = cop.GlobalLayers.indexOf(layer)
            if (idx < 0) return;
            cop.GlobalLayers.removeAt(idx);
            cop.invalidateLayerComposition();
        },

        proceed: function(/* arguments */) {
            // COP Proceed Function
            var composition = cop.proceedStack.last();
            if (!composition) {
                console.log('ContextJS: no composition to proceed (stack is empty) ')
                return
            };

            // TODO use index instead of shifiting?
            if (composition.partialMethodIndex == undefined)
                composition.partialMethodIndex = composition.partialMethods.length - 1;

            var index = composition.partialMethodIndex;
            var partialMethod = composition.partialMethods[index];
            if (!partialMethod) {
                if (!partialMethod) throw new COPError('no partialMethod to proceed')
            } else {
                try {
                    composition.partialMethodIndex  = index - 1;
                    if (!Config.ignoredepricatedProceed && partialMethod.toString().match(/^[\t ]*function ?\(\$?proceed/)) {
                        var args = $A(arguments);
                        args.unshift(cop.proceed);
                        var msg = "proceed in arguments list in " + composition.functionName
                        if (Config.throwErrorOnDepricated) throw new Error("DEPRICATED ERROR: " + msg);
                        if (Config.logDepricated) {
                            // console.log("source: " + partialMethod.toString())
                            console.log("DEPRICATED WARNING: " + msg);
                        }
                        var result = partialMethod.apply(composition.object, args);
                    } else {
                        var result = partialMethod.apply(composition.object, arguments);
                    }

                } finally {
                    composition.partialMethodIndex = index
                }
                return result
            }
        }
    })


// Mark old ContextJS API as Depricated
    var markNamespaceEntryAsDepricated = function(newNamespace, newName, oldNamespace, oldName) {
        oldNamespace[oldName] = newNamespace[newName].wrap(function(proceed) {
            if (Config.throwErrorOnDepricated) throw new Error("DEPRICATED ERROR: " + oldName + " is depricated");
            if (Config.logDepricated) console.log("DEPRICATED WARNING: " + oldName + " is depricated");
            var args = $A(arguments);
            args.shift();
            return proceed.apply(this, args);
        });
    };

    markNamespaceEntryAsDepricated(cop, "enableLayer", Global,  "enableLayer");
    markNamespaceEntryAsDepricated(cop, "disableLayer", Global,  "disableLayer");
    markNamespaceEntryAsDepricated(cop, "withLayers", Global,  "withLayers");
    markNamespaceEntryAsDepricated(cop, "withoutLayers", Global,  "withoutLayers");
    markNamespaceEntryAsDepricated(cop, "createLayer", Global,  "createLayer");
    markNamespaceEntryAsDepricated(cop, "layerObject", Global,  "layerObject");
    markNamespaceEntryAsDepricated(cop, "layerClass", Global,  "layerClass");
    markNamespaceEntryAsDepricated(cop, "layerClassAndSubclasses", Global,  "layerClassAndSubclasses");

// Class Definitions

// TODO How to make this independend from the Lively Kernel class system?
    Object.subclass("Layer",
        'initializing', {
            initialize: function(name, namespaceName) {
                this.name = name;
                this.namespaceName = namespaceName || 'Global';
                this.layeredFunctionsList = {};

                if (Global.lively && lively.lang && lively.Module)
                    this.sourceModule = lively.Module.current();
            },
        },
        'accessing', {
            getName: function() { return this.name },
            fullName: function() { return this.namespaceName + '.' + this.getName() },
            layeredObjects: function() {
                return Properties.own(this)
                    .collect(function(ea) {return this[ea] && this[ea]._layered_object}, this)
                    .select(function(ea) {return ea})
            },
            layeredClasses: function() {
                return this.layeredObjects()
                    .collect(function(ea) { return ea.constructor })
                    .select(function(ea) {return lively.Class.isClass(ea) })
            },



        },
        'testing', {
            isGlobal: function() { return cop.GlobalLayers.include(this) },
        },
        'removing', {
            remove: function() {
                // Deletes the LayerClass, but keeps the layered Functions.
                if (this.isGlobal()) this.beNotGlobal();
                var ns = module(this.namespaceName);
                delete ns[this.name];
            },
            uninstall: function() {
                // Uninstalls just this layer, functions that are layered by other Layers will not be reset.
                var layer = this;
                this.layeredObjects().each(function (eachLayeredObj) {
                    var layerIdx = Object.isFunction(eachLayeredObj.activeLayers)?
                        eachLayeredObj.activeLayers().indexOf(layer) : -1;
                    Properties.own(layer.layeredFunctionsList[eachLayeredObj]).each(function (eachLayeredFunc) {
                        var newerLayer = eachLayeredObj.activeLayers().find(function (eachOtherLayer) {
                            var eachOtherLayerIdx = eachLayeredObj.activeLayers().indexOf(eachOtherLayer),
                                isNewer = (eachOtherLayerIdx  !== -1) && (eachOtherLayerIdx < layerIdx)
                            return isNewer && eachOtherLayer.layeredFunctionsList[eachLayeredObj][eachLayeredFunc]
                        })
                        if (!newerLayer)
                            cop.makeFunctionLayerUnaware(eachLayeredObj, eachLayeredFunc)
                    })
                })
                this.remove()
                alertOK('Successfully uninstalled Layer '+this+' in Global Classes');
            },

        },
        'layer installation',     {
            layerClass: function(classObj, methods) {
                cop.layerClass(this, classObj, methods);
                return this;
            },

            layerObject: function(obj, methods) {
                cop.layerObject(this, obj, methods);
                return this;
            },
            refineClass: function(classObj, methods) {
                cop.layerClass(this, classObj, methods);
                return this
            },

            refineObject: function(obj, methods) {
                cop.layerObject(this, obj, methods);
                return this
            },

            unrefineObject: function(obj) {
                var id = obj._layer_object_id;
                if (id !== undefined)
                    delete this[id]
            },

            unrefineClass: function(classObj) {
                this.unrefineObject(classObj.prototype)
            },
        },
        'layer activation', {
            beGlobal: function() {
                cop.enableLayer(this);
                return this;
            },

            beNotGlobal: function() {
                cop.disableLayer(this);
                return this;
            },
            hide: function() {
                // Hidden layers do not appear when evaluating the sourcecode of a function
                // TODO: this function has to be called BEFORE the layer refines any class, due to problems in unrefining classes.
                this.isHidden = true
                return this;
            },

        },
        'debugging', {
            toString: function() { return this.getName() },
        },
        'deprecated serialization', {
            toLiteral: function() {
                if (!this.name)
                    console.warn("Layer: Can not serialize without a name!");
                return {
                    name: this.name
                };
            },
        });

// Lively Kernel Literal Serialization
    Object.extend(Layer, {
        fromLiteral: function(literal) {
            // console.log("Deserializing Layer Activation from: " + literal.name)
            return cop.create(literal.name, false);
        }
    });

    /* Example implementation of a layerable object */
    Object.extend(Global, {LayerableObjectTrait: {}});
    Object.extend(LayerableObjectTrait, {
        activeLayers: function() {
            var result = {withLayers: [], withoutLayers: []};
            this.dynamicLayers(result);
            this.structuralLayers(result)
            this.globalLayers(result)
            return result.withLayers
        },

        collectWithLayersIn: function(layers, result) {
            for (var i = 0; i < layers.length; i++) {
                var ea = layers[i]
                if ((result.withLayers.indexOf(ea) === -1) && (result.withoutLayers.indexOf(ea) === -1))
                    result.withLayers.unshift(ea)
            };
        },

        collectWithoutLayersIn: function(layers, result) {
            for (var i = 0; i < layers.length; i++) {
                var ea = layers[i]
                if ((result.withoutLayers.indexOf(ea) === -1))
                    result.withoutLayers.push(ea)
            };
        },

        dynamicLayers: function(result) {
            // optimized version, that does not use closures and recursion
            var stack = cop.LayerStack;
            // top down, ignore bottom element
            for (var j = stack.length - 1; j > 0; j--) {
                var current = stack[j];
                if (current.withLayers)
                    this.collectWithLayersIn(current.withLayers, result);
                if (current.withoutLayers)
                    this.collectWithoutLayersIn(current.withoutLayers, result);
            }
            return result
        },

        structuralLayers: function(result) {
            var allLayers = result.withLayers,
                allWithoutLayers = result.withoutLayers,
                obj = this;

            // go ownerchain backward and gather all layer activations and deactivations
            while (obj) {
                // don't use accessor methods because of speed... (not measured yet)
                if (obj.withLayers)
                    this.collectWithLayersIn(obj.withLayers, result);
                if (obj.withoutLayers)
                    this.collectWithoutLayersIn(obj.withoutLayers, result);

                // recurse, stop if owner is undefined
                obj = obj.owner
            }
            return result;
        },

        globalLayers: function(result) {
            this.collectWithLayersIn(cop.GlobalLayers, result);
            return result
        },

        setWithLayers: function(layers) { this.withLayers = layers },

        addWithLayer: function(layer) {
            var layers = this.getWithLayers();
            if (!layers.include(layer)) this.setWithLayers(layers.concat([layer]))
        },

        removeWithLayer: function(layer) {
            var layers = this.getWithLayers();
            if (layers.include(layer)) this.setWithLayers(layers.without(layer));
        },
        addWithoutLayer: function(layer) {
            var layers = this.getWithoutLayers();
            if (!layers.include(layer)) this.setWithoutLayers(layers.concat([layer]))
        },
        removeWithoutLayer: function(layer) {
            var layers = this.getWithoutLayers();
            this.setWithoutLayers(layers.without(layer));
        },



        setWithoutLayers: function(layers) { this.withoutLayers = layers },

        getWithLayers: function(layers) { return this.withLayers || [] },

        getWithoutLayers: function(layers) { return this.withoutLayers || [] },
    });

    Object.subclass("LayerableObject", LayerableObjectTrait);

    Object.subclass('COPError', {
        initialize: function(msg) {
            this.msg = msg
        },
        toString: function() { return "COP Error: " + this.msg },
    });

    Object.subclass("cop.PartialLayerComposition", {
        initialize: function(obj,  prototypeObject, functionName, baseFunction, methodType) {
            this.partialMethods = [baseFunction];
            var layers = cop.computeLayersFor(obj);
            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    partialMethod = cop.lookupLayeredFunctionForObject(
                        obj, layer, functionName, methodType);
                if (partialMethod) this.partialMethods.push(partialMethod);
            };
            this.object = obj;
            this.prototypeObject = prototypeObject;
            this.functionName = functionName;
        }
    })

// DEPRICATED Syntactic Sugar: Layer in Class

    /*
     * extend the subclassing behavior of Lively Kernel to allow fo Layer-In-Class constructs
     */
    Object.extend(Function.prototype, {
        subclass: Object.subclass.wrap(function(proceed) {
            var args = $A(arguments);
            args.shift();
            var layeredMethods = [];

            for (var i=1; i < args.length; i++) {
                var methods = args[i];
                if (Object.isString(methods)) continue; // if it's a category
                Object.keys(methods).forEach(function(ea) {
                    var m = ea.match(/([A-Za-z0-9]+)\$([A-Za-z0-9]*)/);
                    if (m) {
                        var getter = methods.__lookupGetter__(m[0]);
                        var setter = methods.__lookupSetter__(m[0]);
                        layeredMethods.push({layerName: m[1], methodName: m[2], methodBody: methods[ea],
                            getterMethod: getter, setterMethod: setter});
                        delete methods[ea];
                    };
                });
            };
            var klass =  proceed.apply(this, args);
            layeredMethods.forEach(function(ea){
                // log("layer property " + ea.methodName + " in " + ea.layerName);
                var layer = Global[ea.layerName];
                if (!layer) throw new Error("could not find layer: " + ea.layerName);
                if (ea.getterMethod || ea.setterMethod) {
                    if (ea.getterMethod) {
                        cop.layerGetterMethod(layer, klass.prototype, ea.methodName, ea.getterMethod);
                    };
                    if (ea.setterMethod) {
                        cop.layerSetterMethod(layer, klass.prototype, ea.methodName, ea.setterMethod);
                    };
                    cop.makePropertyLayerAware(klass.prototype, ea.methodName);
                } else {
                    // log("layer method " + ea.methodName + " in " + ea.layerName);
                    cop.layerMethod(layer, klass.prototype, ea.methodName, ea.methodBody);
                }
            });
            return klass;
        })
    });

    cop.resetLayerStack();

    if (cop.dynamicInlining)
        module('cop.Flatten').load(true);

});

















// try to use StringBuffer instead of string concatenation to improve performance

function StringBuffer() {
    this.strings = []
    for (var idx = 0; idx < arguments.length; idx++)
        this.nextPutAll(arguments[idx])
}
StringBuffer.prototype.nextPutAll = function(s) { this.strings.push(s) }
StringBuffer.prototype.contents   = function()  { return this.strings.join("") }
String.prototype.writeStream      = function() { return new StringBuffer(this) }

// make Arrays print themselves sensibly

printOn = function(x, ws) {
    if (x === undefined || x === null)
        ws.nextPutAll("" + x)
    else if (x.constructor === Array) {
        ws.nextPutAll("[")
        for (var idx = 0; idx < x.length; idx++) {
            if (idx > 0)
                ws.nextPutAll(", ")
            printOn(x[idx], ws)
        }
        ws.nextPutAll("]")
    }
    else
        ws.nextPutAll(x.toString())
}

Array.prototype.ometaToString = function() { var ws = "".writeStream(); printOn(this, ws); return ws.contents() }

// delegation

objectThatDelegatesTo = function(x, props) {
    var f = function() { }
    f.prototype = x
    var r = new f()
    for (var p in props)
        if (props.hasOwnProperty(p))
            r[p] = props[p]
    return r
}

// some reflective stuff

ownPropertyNames = function(x) {
    var r = []
    for (var name in x)
        if (x.hasOwnProperty(name))
            r.push(name)
    return r
}

isImmutable = function(x) {
    return x === null || x === undefined || typeof x === "boolean" || typeof x === "number" || typeof x === "string"
}

String.prototype.digitValue  = function() { return this.charCodeAt(0) - "0".charCodeAt(0) }

isSequenceable = function(x) { return typeof x == "string" || x.constructor === Array }

// some functional programming stuff

Array.prototype.map = Array.prototype.map || function(f) {
        var r = []
        for (var idx = 0; idx < this.length; idx++)
            r[idx] = f(this[idx])
        return r
    }

Array.prototype.reduce = Array.prototype.reduce || function(f, z) {
        var r = z
        for (var idx = 0; idx < this.length; idx++)
            r = f(r, this[idx])
        return r
    }

Array.prototype.delimWith = function(d) {
    return this.reduce(
        function(xs, x) {
            if (xs.length > 0)
                xs.push(d)
            xs.push(x)
            return xs
        },
        [])
}

// Squeak's ReadStream, kind of

function ReadStream(anArrayOrString) {
    this.src = anArrayOrString
    this.pos = 0
}
ReadStream.prototype.atEnd = function() { return this.pos >= this.src.length }
ReadStream.prototype.next  = function() { return this.src.at(this.pos++) }

// escape characters

String.prototype.pad = function(s, len) {
    var r = this
    while (r.length < len)
        r = s + r
    return r
}

escapeStringFor = new Object()
for (var c = 0; c < 128; c++)
    escapeStringFor[c] = String.fromCharCode(c)
escapeStringFor["'".charCodeAt(0)]  = "\\'"
escapeStringFor['"'.charCodeAt(0)]  = '\\"'
escapeStringFor["\\".charCodeAt(0)] = "\\\\"
escapeStringFor["\b".charCodeAt(0)] = "\\b"
escapeStringFor["\f".charCodeAt(0)] = "\\f"
escapeStringFor["\n".charCodeAt(0)] = "\\n"
escapeStringFor["\r".charCodeAt(0)] = "\\r"
escapeStringFor["\t".charCodeAt(0)] = "\\t"
escapeStringFor["\v".charCodeAt(0)] = "\\v"
escapeChar = function(c) {
    var charCode = c.charCodeAt(0)
    if (charCode < 128)
        return escapeStringFor[charCode]
    else if (128 <= charCode && charCode < 256)
        return "\\x" + charCode.toString(16).pad("0", 2)
    else
        return "\\u" + charCode.toString(16).pad("0", 4)
}

function ometaUnescape(s) {
    if (s.charAt(0) == '\\')
        switch (s.charAt(1)) {
            case "'":  return "'"
            case '"':  return '"'
            case '\\': return '\\'
            case 'b':  return '\b'
            case 'f':  return '\f'
            case 'n':  return '\n'
            case 'r':  return '\r'
            case 't':  return '\t'
            case 'v':  return '\v'
            case 'x':  return String.fromCharCode(parseInt(s.substring(2, 4), 16))
            case 'u':  return String.fromCharCode(parseInt(s.substring(2, 6), 16))
            default:   return s.charAt(1)
        }
    else
        return s
}

String.prototype.toProgramString = function() {
    var ws = '"'.writeStream()
    for (var idx = 0; idx < this.length; idx++)
        ws.nextPutAll(escapeChar(this.charAt(idx)))
    ws.nextPutAll('"')
    return ws.contents()
}

// C-style tempnam function

function tempnam(s) { return (s ? s : "_tmpnam_") + tempnam.n++ }
tempnam.n = 0

// unique tags for objects (useful for making "hash tables")

getTag = (function() {
    var numIdx = 0
    return function(x) {
        if (x === null || x === undefined)
            return x
        switch (typeof x) {
            case "boolean": return x == true ? "Btrue" : "Bfalse"
            case "string":  return "S" + x
            case "number":  return "N" + x
            default:        return x.hasOwnProperty("_id_") ? x._id_ : x._id_ = "R" + numIdx++
        }
    }
})()
















/*
 new syntax:
 #foo and `foo	match the string object 'foo' (it's also accepted in my JS)
 'abc'		match the string object 'abc'
 'c'			match the string object 'c'
 ``abc''		match the sequence of string objects 'a', 'b', 'c'
 "abc"		token('abc')
 [1 2 3]		match the array object [1, 2, 3]
 foo(bar)		apply rule foo with argument bar
 -> ...		semantic actions written in JS (see OMetaParser's atomicHostExpr rule)
 */

/*
 ometa M {
 number = number:n digit:d -> { n * 10 + d.digitValue() }
 | digit:d          -> { d.digitValue() }
 }

 translates to...

 M = objectThatDelegatesTo(OMeta, {
 number: function() {
 return this._or(function() {
 var n = this._apply("number"),
 d = this._apply("digit")
 return n * 10 + d.digitValue()
 },
 function() {
 var d = this._apply("digit")
 return d.digitValue()
 }
 )
 }
 })
 M.matchAll("123456789", "number")
 */

// the failure exception

fail = { toString: function() { return "match failed" } }

// streams and memoization

function OMInputStream(hd, tl) {
    this.memo = { }
    this.lst  = tl.lst
    this.idx  = tl.idx
    this.hd   = hd
    this.tl   = tl
}
OMInputStream.prototype.head = function() { return this.hd }
OMInputStream.prototype.tail = function() { return this.tl }
OMInputStream.prototype.type = function() { return this.lst.constructor }
OMInputStream.prototype.upTo = function(that) {
    var r = [], curr = this
    while (curr != that) {
        r.push(curr.head())
        curr = curr.tail()
    }
    return this.type() == String ? r.join('') : r
}

function OMInputStreamEnd(lst, idx) {
    this.memo = { }
    this.lst = lst
    this.idx = idx
}
OMInputStreamEnd.prototype = objectThatDelegatesTo(OMInputStream.prototype)
OMInputStreamEnd.prototype.head = function() { throw fail }
OMInputStreamEnd.prototype.tail = function() { throw fail }

// This is necessary b/c in IE, you can't say "foo"[idx]
Array.prototype.at  = function(idx) { return this[idx] }
String.prototype.at = String.prototype.charAt

function ListOMInputStream(lst, idx) {
    this.memo = { }
    this.lst  = lst
    this.idx  = idx
    this.hd   = lst.at(idx)
}
ListOMInputStream.prototype = objectThatDelegatesTo(OMInputStream.prototype)
ListOMInputStream.prototype.head = function() { return this.hd }
ListOMInputStream.prototype.tail = function() { return this.tl || (this.tl = makeListOMInputStream(this.lst, this.idx + 1)) }

function makeListOMInputStream(lst, idx) { return new (idx < lst.length ? ListOMInputStream : OMInputStreamEnd)(lst, idx) }

Array.prototype.toOMInputStream  = function() { return makeListOMInputStream(this, 0) }
String.prototype.toOMInputStream = function() { return makeListOMInputStream(this, 0) }

function makeOMInputStreamProxy(target) {
    return objectThatDelegatesTo(target, {
        memo:   { },
        target: target,
        tl: undefined,
        tail:   function() { return this.tl || (this.tl = makeOMInputStreamProxy(target.tail())) }
    })
}

// Failer (i.e., that which makes things fail) is used to detect (direct) left recursion and memoize failures

function Failer() { }
Failer.prototype.used = false

// the OMeta "class" and basic functionality

OMeta = {
    _apply: function(rule) {
        var memoRec = this.input.memo[rule]
        if (memoRec == undefined) {
            var origInput = this.input,
                failer    = new Failer()
            if (this[rule] === undefined)
                throw 'tried to apply undefined rule "' + rule + '"'
            this.input.memo[rule] = failer
            this.input.memo[rule] = memoRec = {ans: this[rule].call(this), nextInput: this.input}
            if (failer.used) {
                var sentinel = this.input
                this._applyTryRules(origInput, rule, sentinel, memoRec);
            }
        }
        else if (memoRec instanceof Failer) {
            memoRec.used = true
            throw fail
        }
        this.input = memoRec.nextInput
        return memoRec.ans
    },

    _applyTryRules: function(origInput, rule, sentinel, memoRec) {
        while (true) {
            try {
                this.input = origInput
                var ans = this[rule].call(this)
                if (this.input == sentinel)
                    throw fail
                memoRec.ans       = ans
                memoRec.nextInput = this.input
            }
            catch (f) {
                if (f != fail)
                    throw f
                break
            }
        }
    },

    // note: _applyWithArgs and _superApplyWithArgs are not memoized, so they can't be left-recursive
    _applyWithArgs: function(rule) {
        var ruleFn = this[rule]
        var ruleFnArity = ruleFn.length
        for (var idx = arguments.length - 1; idx >= ruleFnArity + 1; idx--) // prepend "extra" arguments in reverse order
            this._prependInput(arguments[idx])
        return ruleFnArity == 0 ?
            ruleFn.call(this) :
            ruleFn.apply(this, Array.prototype.slice.call(arguments, 1, ruleFnArity + 1))
    },
    _superApplyWithArgs: function(recv, rule) {
        var ruleFn = this[rule]
        var ruleFnArity = ruleFn.length
        for (var idx = arguments.length - 1; idx > ruleFnArity + 2; idx--) // prepend "extra" arguments in reverse order
            recv._prependInput(arguments[idx])
        return ruleFnArity == 0 ?
            ruleFn.call(recv) :
            ruleFn.apply(recv, Array.prototype.slice.call(arguments, 2, ruleFnArity + 2))
    },
    _prependInput: function(v) {
        this.input = new OMInputStream(v, this.input)
    },

    // if you want your grammar (and its subgrammars) to memoize parameterized rules, invoke this method on it:
    memoizeParameterizedRules: function() {
        this._prependInput = function(v) {
            var newInput
            if (isImmutable(v)) {
                newInput = this.input[getTag(v)]
                if (!newInput) {
                    newInput = new OMInputStream(v, this.input)
                    this.input[getTag(v)] = newInput
                }
            }
            else newInput = new OMInputStream(v, this.input)
            this.input = newInput
        }
        this._applyWithArgs = function(rule) {
            var ruleFnArity = this[rule].length
            for (var idx = arguments.length - 1; idx >= ruleFnArity + 1; idx--) // prepend "extra" arguments in reverse order
                this._prependInput(arguments[idx])
            return ruleFnArity == 0 ?
                this._apply(rule) :
                this[rule].apply(this, Array.prototype.slice.call(arguments, 1, ruleFnArity + 1))
        }
    },

    _pred: function(b) {
        if (b)
            return true
        throw fail
    },
    _not: function(x) {
        var origInput = this.input
        try { x.call(this) }
        catch (f) {
            if (f != fail)
                throw f
            this.input = origInput
            return true
        }
        throw fail
    },
    _lookahead: function(x) {
        var origInput = this.input,
            r         = x.call(this)
        this.input = origInput
        return r
    },
    _or: function() {
        var origInput = this.input
        for (var idx = 0; idx < arguments.length; idx++)
            try { this.input = origInput; return arguments[idx].call(this) }
            catch (f) {
                if (f != fail)
                    throw f
            }
        throw fail
    },
    _xor: function(ruleName) {
        var origInput = this.input, idx = 1, newInput, ans
        while (idx < arguments.length) {
            try {
                this.input = origInput
                ans = arguments[idx].call(this)
                if (newInput)
                    throw 'more than one choice matched by "exclusive-OR" in ' + ruleName
                newInput = this.input
            }
            catch (f) {
                if (f != fail)
                    throw f
            }
            idx++
        }
        if (newInput) {
            this.input = newInput
            return ans
        }
        else
            throw fail
    },
    disableXORs: function() {
        this._xor = this._or
    },
    _opt: function(x) {
        var origInput = this.input, ans
        try { ans = x.call(this) }
        catch (f) {
            if (f != fail)
                throw f
            this.input = origInput
        }
        return ans
    },
    _many: function(x) {
        var ans = arguments[1] != undefined ? [arguments[1]] : []
        while (true) {
            var origInput = this.input
            try { ans.push(x.call(this)) }
            catch (f) {
                if (f != fail)
                    throw f
                this.input = origInput
                break
            }
        }
        return ans
    },
    _many1: function(x) { return this._many(x, x.call(this)) },
    _form: function(x) {
        var v = this._apply("anything")
        if (!isSequenceable(v))
            throw fail
        var origInput = this.input
        this.input = v.toOMInputStream()
        var r = x.call(this)
        this._apply("end")
        this.input = origInput
        return v
    },
    _consumedBy: function(x) {
        var origInput = this.input
        x.call(this)
        return origInput.upTo(this.input)
    },
    _idxConsumedBy: function(x) {
        var origInput = this.input
        x.call(this)
        return {fromIdx: origInput.idx, toIdx: this.input.idx}
    },
    _interleave: function(mode1, part1, mode2, part2 /* ..., moden, partn */) {
        var currInput = this.input, ans = []
        for (var idx = 0; idx < arguments.length; idx += 2)
            ans[idx / 2] = (arguments[idx] == "*" || arguments[idx] == "+") ? [] : undefined
        while (true) {
            var idx = 0, allDone = true
            while (idx < arguments.length) {
                if (arguments[idx] != "0")
                    try {
                        this.input = currInput
                        switch (arguments[idx]) {
                            case "*": ans[idx / 2].push(arguments[idx + 1].call(this));                       break
                            case "+": ans[idx / 2].push(arguments[idx + 1].call(this)); arguments[idx] = "*"; break
                            case "?": ans[idx / 2] =    arguments[idx + 1].call(this);  arguments[idx] = "0"; break
                            case "1": ans[idx / 2] =    arguments[idx + 1].call(this);  arguments[idx] = "0"; break
                            default:  throw "invalid mode '" + arguments[idx] + "' in OMeta._interleave"
                        }
                        currInput = this.input
                        break
                    }
                    catch (f) {
                        if (f != fail)
                            throw f
                        // if this (failed) part's mode is "1" or "+", we're not done yet
                        allDone = allDone && (arguments[idx] == "*" || arguments[idx] == "?")
                    }
                idx += 2
            }
            if (idx == arguments.length) {
                if (allDone)
                    return ans
                else
                    throw fail
            }
        }
    },
    _currIdx: function() { return this.input.idx },

    // some basic rules
    anything: function() {
        var r = this.input.head()
        this.input = this.input.tail()
        return r
    },
    end: function() {
        return this._not(function() { return this._apply("anything") })
    },
    pos: function() {
        return this.input.idx
    },
    empty: function() { return true },
    apply: function(r) {
        return this._apply(r)
    },
    foreign: function(g, r) {
        var gi  = objectThatDelegatesTo(g, {input: makeOMInputStreamProxy(this.input)}),
            ans = gi._apply(r)
        this.input = gi.input.target
        return ans
    },

    //  some useful "derived" rules
    exactly: function(wanted) {
        if (wanted === this._apply("anything"))
            return wanted
        throw fail
    },
    "true": function() {
        var r = this._apply("anything")
        this._pred(r === true)
        return r
    },
    "false": function() {
        var r = this._apply("anything")
        this._pred(r === false)
        return r
    },
    "undefined": function() {
        var r = this._apply("anything")
        this._pred(r === undefined)
        return r
    },
    number: function() {
        var r = this._apply("anything")
        this._pred(typeof r === "number")
        return r
    },
    string: function() {
        var r = this._apply("anything")
        this._pred(typeof r === "string")
        return r
    },
    "char": function() {
        var r = this._apply("anything")
        this._pred(typeof r === "string" && r.length == 1)
        return r
    },
    space: function() {
        var r = this._apply("char"), code = r.charCodeAt(0);
        this._pred(code <= 32 || code === 160);
        return r
    },
    spaces: function() {
        return this._many(function() { return this._apply("space") })
    },
    digit: function() {
        var r = this._apply("char")
        this._pred(r >= "0" && r <= "9")
        return r
    },
    lower: function() {
        var r = this._apply("char")
        this._pred(r >= "a" && r <= "z")
        return r
    },
    upper: function() {
        var r = this._apply("char")
        this._pred(r >= "A" && r <= "Z")
        return r
    },
    letter: function() {
        return this._or(function() { return this._apply("lower") },
            function() { return this._apply("upper") })
    },
    letterOrDigit: function() {
        return this._or(function() { return this._apply("letter") },
            function() { return this._apply("digit")  })
    },
    firstAndRest: function(first, rest)  {
        return this._many(function() { return this._apply(rest) }, this._apply(first))
    },
    seq: function(xs) {
        for (var idx = 0; idx < xs.length; idx++)
            this._applyWithArgs("exactly", xs.at(idx))
        return xs
    },
    notLast: function(rule) {
        var r = this._apply(rule)
        this._lookahead(function() { return this._apply(rule) })
        return r
    },
    listOf: function(rule, delim) {
        return this._or(function() {
                var r = this._apply(rule)
                return this._many(function() {
                        this._applyWithArgs("token", delim)
                        return this._apply(rule)
                    },
                    r)
            },
            function() { return [] })
    },
    token: function(cs) {
        this._apply("spaces")
        return this._applyWithArgs("seq", cs)
    },
    fromTo: function (x, y) {
        return this._consumedBy(function() {
            this._applyWithArgs("seq", x)
            this._many(function() {
                this._not(function() { this._applyWithArgs("seq", y) })
                this._apply("char")
            })
            this._applyWithArgs("seq", y)
        })
    },

    initialize: function() { },
    // match and matchAll are a grammar's "public interface"
    _genericMatch: function(input, rule, args, matchFailed) {
        if (args == undefined)
            args = []
        var realArgs = [rule]
        for (var idx = 0; idx < args.length; idx++)
            realArgs.push(args[idx])
        var m = objectThatDelegatesTo(this, {input: input})
        m.initialize()
        try { return realArgs.length == 1 ? m._apply.call(m, realArgs[0]) : m._applyWithArgs.apply(m, realArgs) }
        catch (f) {
            if (f == fail && matchFailed != undefined) {
                var input = m.input
                if (input.idx != undefined) {
                    while (input.tl != undefined && input.tl.idx != undefined)
                        input = input.tl
                    input.idx--
                }
                return matchFailed(m, input.idx)
            }
            throw f
        }
    },
    match: function(obj, rule, args, matchFailed) {
        var toString = Array.prototype.toString;
        Array.prototype.toString = Array.prototype.ometaToString;
        try {
            return this._genericMatch([obj].toOMInputStream(),    rule, args, matchFailed)
        } finally {
            Array.prototype.toString = toString;
        }
    },
    matchAll: function(listyObj, rule, args, matchFailed) {
        var toString = Array.prototype.toString;
        Array.prototype.toString = Array.prototype.ometaToString;
        try {
            return this._genericMatch(listyObj.toOMInputStream(), rule, args, matchFailed)
        } finally {
            Array.prototype.toString = toString;
        }
    },
    createInstance: function() {
        var m = objectThatDelegatesTo(this)
        m.initialize()
        m.matchAll = function(listyObj, aRule) {
            this.input = listyObj.toOMInputStream()
            return this._apply(aRule)
        }
        return m
    }
}














Parser = objectThatDelegatesTo(OMeta, {
})











/*
 * Optimized Parser for parsing blocks of JavaScript code
 */

Global.ChunkParser = {

    start: function(ometaParser, chunkStart, chunkEnd) {
        this.ometaParser = ometaParser;
        this.isString = (chunkStart === chunkEnd) && (chunkStart === '\'' || chunkStart === '\"');
        this.chunkStart = chunkStart;
        this.chunkEnd = chunkEnd;
        this.chunkEndFound = false;
        this.next = null;
        this.counter = 0;
        this.result = [];
        this.parseStart();
        // dbgOn(true);
        do { this.makeStep() } while (!this.parseRest());
        return this.result;
    },

    parseStart: function() {
        this.result.push(this.ometaParser._applyWithArgs('exactly', this.chunkStart));
    },

    makeStep: function() {
        this.next = this.ometaParser._apply("anything");
        this.result.push(this.next);
        this.nextNext = this.ometaParser.input.hd;
        return this.next;
    },

    backup: function() {
        this.backupRecorded = true;
        this.backupInput = this.ometaParser.input;
        this.backupNext = this.next;
        this.backupNextNext = this.nextNext;
        this.backupCounter = this.counter;
        this.backupResult = this.result;
    },

    useBackup: function() {
        if (!this.backupRecorded) throw dbgOn(new Error('Using Chunk parser backup but did not record it!'));
        this.ometaParser.input = this.backupInput;
        this.next = this.backupNext;
        this.nextNext = this.backupNextNext;
        this.counter = this.backupCounter;
        this.result = this.backupResult;
    },

    parseEscapedChar: function() {
        while (this.next === '\\') {
            this.makeStep();
            this.makeStep();
        }
    },

    parseComment: function() {
        if (this.next !== '/') return false;
        var comment1Opened = this.nextNext === '/';
        var comment2Opened = this.nextNext === '*'
        if (!comment1Opened && !comment2Opened) return;
        this.makeStep(); this.makeStep();
        while (true) { // this seems to crash Safari/Webkit, using do while below
            this.parseEscapedChar();
            if (comment1Opened && (this.next === '\n' || this.next === '\r')) return;
            if (comment2Opened && this.next === '*' && this.nextNext === '/' && this.makeStep()) return;
            this.makeStep();
        }
    },

    parseString: function() {
        var string1Opened;
        var string2Opened;
        if (this.chunkStart === '\'' || this.chunkStart === '"') return;
        if (this.next === '\'') string1Opened = true;
        if (this.next === '"') string2Opened = true;
        if (!string1Opened && !string2Opened) return;
        this.makeStep();
        while (true) { // this seems to crash Safari/Webkit
            this.parseEscapedChar()
            if (string1Opened && this.next === '\'') return;
            if (string2Opened && this.next === '"') return;
            this.makeStep();
        }
    },

    parseRegex: function() {
        var regexOpen = this.next === '/' && this.nextNext !== '*' && this.nextNext !== '/';
        if (!regexOpen) return;
        this.backup();
        this.makeStep();
        while (true) {
            this.parseEscapedChar();
            // Assume regex are on one line
            if (this.next === '\n' || this.next === '\r') {
                this.useBackup();
                return;
            }
            if (this.next === '/') return;
            this.makeStep();
        }
    },

    parseRest: function() {
        this.parseEscapedChar();
        if (!this.isString) {
            this.parseRegex();
            this.parseString();
            this.parseComment();
        }
        if (this.next === this.chunkEnd && this.counter === 0) // end
            return true;
        if (this.next === this.chunkEnd) { // end of another chunk
            this.counter--;
            return false;
        }
        if (this.next === this.chunkStart) // begin of another chunk
            this.counter++;
        return false;
    }

};

OMeta.basicChunk = function() {
    var chunkStart = this._apply("anything"),
        chunkEnd   = this._apply("anything");
    if (!this.chunkParser)
        this.chunkParser = objectThatDelegatesTo(ChunkParser,{});
    //this.chunkParser = objectThatDelegatesTo(Object,ChunkParser, {});
    return this.chunkParser.start(this, chunkStart, chunkEnd);
}









{BSOMetaParser=objectThatDelegatesTo(OMeta,{
    "space":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return OMeta._superApplyWithArgs(this,'space')}),(function(){return this._applyWithArgs("fromTo","//","\n")}),(function(){return this._applyWithArgs("fromTo","/*","*/")}))},
    "nameFirst":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return (function(){switch(this._apply('anything')){case "_":return "_";case "$":return "$";default: throw fail}}).call(this)}),(function(){return this._apply("letter")}))},
    "nameRest":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("nameFirst")}),(function(){return this._apply("digit")}))},
    "tsName":function(){var $elf=this,_fromIdx=this.input.idx;return this._consumedBy((function(){return (function(){this._apply("nameFirst");return this._many((function(){return this._apply("nameRest")}))}).call(this)}))},
    "name":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._apply("tsName")}).call(this)},
    "hexDigit":function(){var $elf=this,_fromIdx=this.input.idx,x,v;return (function(){x=this._apply("char");v=this["hexDigits"].indexOf(x.toLowerCase());this._pred((v >= (0)));return v}).call(this)},
    "eChar":function(){var $elf=this,_fromIdx=this.input.idx,s;return this._or((function(){return (function(){s=this._consumedBy((function(){return (function(){this._applyWithArgs("exactly","\\");return this._or((function(){return (function(){switch(this._apply('anything')){case "u":return (function(){this._apply("hexDigit");this._apply("hexDigit");this._apply("hexDigit");return this._apply("hexDigit")}).call(this);case "x":return (function(){this._apply("hexDigit");return this._apply("hexDigit")}).call(this);default: throw fail}}).call(this)}),(function(){return this._apply("char")}))}).call(this)}));return unescape(s)}).call(this)}),(function(){return this._apply("char")}))},
    "tsString":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){this._applyWithArgs("exactly","\'");xs=this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\'")}));return this._apply("eChar")}).call(this)}));this._applyWithArgs("exactly","\'");return xs.join("")}).call(this)},
    "characters":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){this._applyWithArgs("exactly","`");this._applyWithArgs("exactly","`");xs=this._many((function(){return (function(){this._not((function(){return (function(){this._applyWithArgs("exactly","\'");return this._applyWithArgs("exactly","\'")}).call(this)}));return this._apply("eChar")}).call(this)}));this._applyWithArgs("exactly","\'");this._applyWithArgs("exactly","\'");return ["App","seq",xs.join("").toProgramString()]}).call(this)},
    "sCharacters":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){this._applyWithArgs("exactly","\"");xs=this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\"")}));return this._apply("eChar")}).call(this)}));this._applyWithArgs("exactly","\"");return ["App","token",xs.join("").toProgramString()]}).call(this)},
    "string":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._or((function(){return (function(){(function(){switch(this._apply('anything')){case "#":return "#";case "`":return "`";default: throw fail}}).call(this);return this._apply("tsName")}).call(this)}),(function(){return this._apply("tsString")}));return ["App","exactly",xs.toProgramString()]}).call(this)},
    "number":function(){var $elf=this,_fromIdx=this.input.idx,n;return (function(){n=this._consumedBy((function(){return (function(){this._opt((function(){return this._applyWithArgs("exactly","-")}));return this._many1((function(){return this._apply("digit")}))}).call(this)}));return ["App","exactly",n]}).call(this)},
    "keyword":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._apply("anything");this._applyWithArgs("token",xs);this._not((function(){return this._apply("letterOrDigit")}));return xs}).call(this)},
    "args":function(){var $elf=this,_fromIdx=this.input.idx,xs;return this._or((function(){return (function(){switch(this._apply('anything')){case "(":return (function(){xs=this._applyWithArgs("listOf","hostExpr",",");this._applyWithArgs("token",")");return xs}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return []}).call(this)}))},
    "application":function(){var $elf=this,_fromIdx=this.input.idx,rule,as,grm;return this._or((function(){return (function(){this._applyWithArgs("token","^");rule=this._apply("name");as=this._apply("args");return ["App","super",(("\'" + rule) + "\'")].concat(as)}).call(this)}),(function(){return (function(){grm=this._apply("name");this._applyWithArgs("token",".");rule=this._apply("name");as=this._apply("args");return ["App","foreign",grm,(("\'" + rule) + "\'")].concat(as)}).call(this)}),(function(){return (function(){rule=this._apply("name");as=this._apply("args");return ["App",rule].concat(as)}).call(this)}))},
    "hostExpr":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("foreign",BSSemActionParser,'expr');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
    "curlyHostExpr":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("foreign",BSSemActionParser,'curlySemAction');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
    "primHostExpr":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._applyWithArgs("foreign",BSSemActionParser,'semAction');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
    "atomicHostExpr":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("curlyHostExpr")}),(function(){return this._apply("primHostExpr")}))},
    "semAction":function(){var $elf=this,_fromIdx=this.input.idx,x;return this._or((function(){return (function(){x=this._apply("curlyHostExpr");return ["Act",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!");x=this._apply("atomicHostExpr");return ["Act",x]}).call(this)}))},
    "arrSemAction":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){this._applyWithArgs("token","->");x=this._apply("atomicHostExpr");return ["Act",x]}).call(this)},
    "semPred":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){this._applyWithArgs("token","?");x=this._apply("atomicHostExpr");return ["Pred",x]}).call(this)},
    "expr":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._applyWithArgs("expr5",true);xs=this._many1((function(){return (function(){this._applyWithArgs("token","|");return this._applyWithArgs("expr5",true)}).call(this)}));return ["Or",x].concat(xs)}).call(this)}),(function(){return (function(){x=this._applyWithArgs("expr5",true);xs=this._many1((function(){return (function(){this._applyWithArgs("token","||");return this._applyWithArgs("expr5",true)}).call(this)}));return ["XOr",x].concat(xs)}).call(this)}),(function(){return this._applyWithArgs("expr5",false)}))},
    "expr5":function(){var $elf=this,_fromIdx=this.input.idx,ne,x,xs;return (function(){ne=this._apply("anything");return this._or((function(){return (function(){x=this._apply("interleavePart");xs=this._many1((function(){return (function(){this._applyWithArgs("token","&&");return this._apply("interleavePart")}).call(this)}));return ["Interleave",x].concat(xs)}).call(this)}),(function(){return this._applyWithArgs("expr4",ne)}))}).call(this)},
    "interleavePart":function(){var $elf=this,_fromIdx=this.input.idx,part;return this._or((function(){return (function(){this._applyWithArgs("token","(");part=this._applyWithArgs("expr4",true);this._applyWithArgs("token",")");return ["1",part]}).call(this)}),(function(){return (function(){part=this._applyWithArgs("expr4",true);return this._applyWithArgs("modedIPart",part)}).call(this)}))},
    "modedIPart":function(){var $elf=this,_fromIdx=this.input.idx,part;return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");return this._form((function(){return (function(){this._applyWithArgs("exactly","Many");return part=this._apply("anything")}).call(this)}))}).call(this)}));return ["*",part]}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");return this._form((function(){return (function(){this._applyWithArgs("exactly","Many1");return part=this._apply("anything")}).call(this)}))}).call(this)}));return ["+",part]}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");return this._form((function(){return (function(){this._applyWithArgs("exactly","Opt");return part=this._apply("anything")}).call(this)}))}).call(this)}));return ["?",part]}).call(this)}),(function(){return (function(){part=this._apply("anything");return ["1",part]}).call(this)}))},
    "expr4":function(){var $elf=this,_fromIdx=this.input.idx,ne,xs,act;return (function(){ne=this._apply("anything");return this._or((function(){return (function(){xs=this._many((function(){return this._apply("expr3")}));act=this._apply("arrSemAction");return ["And"].concat(xs).concat([act])}).call(this)}),(function(){return (function(){this._pred(ne);xs=this._many1((function(){return this._apply("expr3")}));return ["And"].concat(xs)}).call(this)}),(function(){return (function(){this._pred((ne == false));xs=this._many((function(){return this._apply("expr3")}));return ["And"].concat(xs)}).call(this)}))}).call(this)},
    "optIter":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return this._or((function(){return (function(){switch(this._apply('anything')){case "*":return ["Many",x];case "+":return ["Many1",x];case "?":return ["Opt",x];default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return x}).call(this)}))}).call(this)},
    "optBind":function(){var $elf=this,_fromIdx=this.input.idx,x,n;return (function(){x=this._apply("anything");return this._or((function(){return (function(){switch(this._apply('anything')){case ":":return (function(){n=this._apply("name");return (function (){(this["locals"][n]=true);return ["Set",n,x]}).call(this)}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return x}).call(this)}))}).call(this)},
    "expr3":function(){var $elf=this,_fromIdx=this.input.idx,n,x,e;return this._or((function(){return (function(){this._applyWithArgs("token",":");n=this._apply("name");return (function (){(this["locals"][n]=true);return ["Set",n,["App","anything"]]}).call(this)}).call(this)}),(function(){return (function(){e=this._or((function(){return (function(){x=this._apply("expr2");return this._applyWithArgs("optIter",x)}).call(this)}),(function(){return this._apply("semAction")}));return this._applyWithArgs("optBind",e)}).call(this)}),(function(){return this._apply("semPred")}))},
    "expr2":function(){var $elf=this,_fromIdx=this.input.idx,x;return this._or((function(){return (function(){this._applyWithArgs("token","~");x=this._apply("expr2");return ["Not",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","&");x=this._apply("expr1");return ["Lookahead",x]}).call(this)}),(function(){return this._apply("expr1")}))},
    "expr1":function(){var $elf=this,_fromIdx=this.input.idx,x;return this._or((function(){return this._apply("application")}),(function(){return (function(){x=this._or((function(){return this._applyWithArgs("keyword","undefined")}),(function(){return this._applyWithArgs("keyword","nil")}),(function(){return this._applyWithArgs("keyword","true")}),(function(){return this._applyWithArgs("keyword","false")}));return ["App","exactly",x]}).call(this)}),(function(){return (function(){this._apply("spaces");return this._or((function(){return this._apply("characters")}),(function(){return this._apply("sCharacters")}),(function(){return this._apply("string")}),(function(){return this._apply("number")}))}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");x=this._apply("expr");this._applyWithArgs("token","]");return ["Form",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<");x=this._apply("expr");this._applyWithArgs("token",">");return ["ConsBy",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","@<");x=this._apply("expr");this._applyWithArgs("token",">");return ["IdxConsBy",x]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","(");x=this._apply("expr");this._applyWithArgs("token",")");return x}).call(this)}))},
    "ruleName":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("name")}),(function(){return (function(){this._apply("spaces");return this._apply("tsString")}).call(this)}))},
    "rule":function(){var $elf=this,_fromIdx=this.input.idx,n,x,xs;return (function(){this._lookahead((function(){return n=this._apply("ruleName")}));(this["locals"]=({"$elf=this": true,"_fromIdx=this.input.idx": true}));x=this._applyWithArgs("rulePart",n);xs=this._many((function(){return (function(){this._applyWithArgs("token",",");return this._applyWithArgs("rulePart",n)}).call(this)}));return ["Rule",n,ownPropertyNames(this["locals"]),["Or",x].concat(xs)]}).call(this)},
    "rulePart":function(){var $elf=this,_fromIdx=this.input.idx,rn,n,b1,b2;return (function(){rn=this._apply("anything");n=this._apply("ruleName");this._pred((n == rn));b1=this._applyWithArgs("expr4",false);return this._or((function(){return (function(){this._applyWithArgs("token","=");b2=this._apply("expr");return ["And",b1,b2]}).call(this)}),(function(){return (function(){this._apply("empty");return b1}).call(this)}))}).call(this)},
    "grammar":function(){var $elf=this,_fromIdx=this.input.idx,n,sn,rs;return (function(){this._applyWithArgs("keyword","ometa");n=this._apply("name");sn=this._or((function(){return (function(){this._applyWithArgs("token","<:");return this._apply("name")}).call(this)}),(function(){return (function(){this._apply("empty");return "OMeta"}).call(this)}));this._applyWithArgs("token","{");rs=this._applyWithArgs("listOf","rule",",");this._applyWithArgs("token","}");return this._applyWithArgs("foreign",BSOMetaOptimizer,'optimizeGrammar',["Grammar",n,sn].concat(rs))}).call(this)}});(BSOMetaParser["hexDigits"]="0123456789abcdef");BSOMetaTranslator=objectThatDelegatesTo(OMeta,{
    "App":function(){var $elf=this,_fromIdx=this.input.idx,args,rule;return this._or((function(){return (function(){switch(this._apply('anything')){case "super":return (function(){args=this._many1((function(){return this._apply("anything")}));return [this["sName"],"._superApplyWithArgs(this,",args.join(","),")"].join("")}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){rule=this._apply("anything");args=this._many1((function(){return this._apply("anything")}));return ["this._applyWithArgs(\"",rule,"\",",args.join(","),")"].join("")}).call(this)}),(function(){return (function(){rule=this._apply("anything");return ["this._apply(\"",rule,"\")"].join("")}).call(this)}))},
    "Act":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return expr}).call(this)},
    "Pred":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return ["this._pred(",expr,")"].join("")}).call(this)},
    "Or":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("transFn")}));return ["this._or(",xs.join(","),")"].join("")}).call(this)},
    "XOr":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("transFn")}));xs.unshift(((this["name"] + ".") + this["rName"]).toProgramString());return ["this._xor(",xs.join(","),")"].join("")}).call(this)},
    "And":function(){var $elf=this,_fromIdx=this.input.idx,xs,y;return this._or((function(){return (function(){xs=this._many((function(){return this._applyWithArgs("notLast","trans")}));y=this._apply("trans");xs.push(("return " + y));return ["(function(){",xs.join(";"),"}).call(this)"].join("")}).call(this)}),(function(){return "undefined"}))},
    "Opt":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._opt(",x,")"].join("")}).call(this)},
    "Many":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._many(",x,")"].join("")}).call(this)},
    "Many1":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._many1(",x,")"].join("")}).call(this)},
    "Set":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._apply("anything");v=this._apply("trans");return [n,"=",v].join("")}).call(this)},
    "Not":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._not(",x,")"].join("")}).call(this)},
    "Lookahead":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._lookahead(",x,")"].join("")}).call(this)},
    "Form":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._form(",x,")"].join("")}).call(this)},
    "ConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._consumedBy(",x,")"].join("")}).call(this)},
    "IdxConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("transFn");return ["this._idxConsumedBy(",x,")"].join("")}).call(this)},
    "JumpTable":function(){var $elf=this,_fromIdx=this.input.idx,cases;return (function(){cases=this._many((function(){return this._apply("jtCase")}));return this.jumpTableCode(cases)}).call(this)},
    "Interleave":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("intPart")}));return ["this._interleave(",xs.join(","),")"].join("")}).call(this)},
    "Rule":function(){var $elf=this,_fromIdx=this.input.idx,name,ls,body;return (function(){name=this._apply("anything");(this["rName"]=name);ls=this._apply("locals");body=this._apply("trans");return ["\n\"",name,"\":function(){",ls,"return ",body,"}"].join("")}).call(this)},
    "Grammar":function(){var $elf=this,_fromIdx=this.input.idx,name,sName,rules;return (function(){name=this._apply("anything");sName=this._apply("anything");(this["name"]=name);(this["sName"]=sName);rules=this._many((function(){return this._apply("trans")}));return [name,"=objectThatDelegatesTo(",sName,",{",rules.join(","),"})"].join("")}).call(this)},
    "intPart":function(){var $elf=this,_fromIdx=this.input.idx,mode,part;return (function(){this._form((function(){return (function(){mode=this._apply("anything");return part=this._apply("transFn")}).call(this)}));return ((mode.toProgramString() + ",") + part)}).call(this)},
    "jtCase":function(){var $elf=this,_fromIdx=this.input.idx,x,e;return (function(){this._form((function(){return (function(){x=this._apply("anything");return e=this._apply("trans")}).call(this)}));return [x.toProgramString(),e]}).call(this)},
    "locals":function(){var $elf=this,_fromIdx=this.input.idx,vs;return this._or((function(){return (function(){this._form((function(){return vs=this._many1((function(){return this._apply("string")}))}));return ["var ",vs.join(","),";"].join("")}).call(this)}),(function(){return (function(){this._form((function(){return undefined}));return ""}).call(this)}))},
    "trans":function(){var $elf=this,_fromIdx=this.input.idx,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
    "transFn":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["(function(){return ",x,"})"].join("")}).call(this)}});(BSOMetaTranslator["jumpTableCode"]=(function (cases){var buf=new StringBuffer();buf.nextPutAll("(function(){switch(this._apply(\'anything\')){");for(var i=(0);(i < cases["length"]);(i+=(1))){buf.nextPutAll((((("case " + cases[i][(0)]) + ":return ") + cases[i][(1)]) + ";"))};buf.nextPutAll("default: throw fail}}).call(this)");return buf.contents()}))}


















{BSJSParser=objectThatDelegatesTo(OMeta,{
    "space":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return OMeta._superApplyWithArgs(this,'space')}),(function(){return this._applyWithArgs("fromTo","//","\n")}),(function(){return this._applyWithArgs("fromTo","/*","*/")}))},
    "nameFirst":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("letter")}),(function(){return (function(){switch(this._apply('anything')){case "$":return "$";case "_":return "_";default: throw fail}}).call(this)}))},
    "nameRest":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("nameFirst")}),(function(){return this._apply("digit")}))},
    "iName":function(){var $elf=this,_fromIdx=this.input.idx;return this._consumedBy((function(){return (function(){this._apply("nameFirst");return this._many((function(){return this._apply("nameRest")}))}).call(this)}))},
    "isKeyword":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return this._pred(BSJSParser._isKeyword(x))}).call(this)},
    "name":function(){var $elf=this,_fromIdx=this.input.idx,n;return (function(){n=this._apply("iName");this._not((function(){return this._applyWithArgs("isKeyword",n)}));return ["name",((n == "self")?"$elf":n)]}).call(this)},
    "keyword":function(){var $elf=this,_fromIdx=this.input.idx,k;return (function(){k=this._apply("iName");this._applyWithArgs("isKeyword",k);return [k,k]}).call(this)},
    "hexDigit":function(){var $elf=this,_fromIdx=this.input.idx,x,v;return (function(){x=this._apply("char");v=this["hexDigits"].indexOf(x.toLowerCase());this._pred((v >= (0)));return v}).call(this)},
    "hexLit":function(){var $elf=this,_fromIdx=this.input.idx,n,d;return this._or((function(){return (function(){n=this._apply("hexLit");d=this._apply("hexDigit");return ((n * (16)) + d)}).call(this)}),(function(){return this._apply("hexDigit")}))},
    "number":function(){var $elf=this,_fromIdx=this.input.idx,n,f;return this._or((function(){return (function(){switch(this._apply('anything')){case "0":return (function(){this._applyWithArgs("exactly","x");"0x";n=this._apply("hexLit");return ["number",n]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){f=this._consumedBy((function(){return (function(){this._many1((function(){return this._apply("digit")}));return this._opt((function(){return (function(){this._applyWithArgs("exactly",".");return this._many1((function(){return this._apply("digit")}))}).call(this)}))}).call(this)}));return ["number",parseFloat(f)]}).call(this)}))},
    "escapeChar":function(){var $elf=this,_fromIdx=this.input.idx,s;return (function(){s=this._consumedBy((function(){return (function(){this._applyWithArgs("exactly","\\");return this._or((function(){return (function(){switch(this._apply('anything')){case "u":return (function(){this._apply("hexDigit");this._apply("hexDigit");this._apply("hexDigit");return this._apply("hexDigit")}).call(this);case "x":return (function(){this._apply("hexDigit");return this._apply("hexDigit")}).call(this);default: throw fail}}).call(this)}),(function(){return this._apply("char")}))}).call(this)}));return unescape(s)}).call(this)},
    "str":function(){var $elf=this,_fromIdx=this.input.idx,cs,n;return this._or((function(){return (function(){switch(this._apply('anything')){case "\"":return this._or((function(){return (function(){switch(this._apply('anything')){case "\"":return (function(){this._applyWithArgs("exactly","\"");"\"\"\"";cs=this._many((function(){return (function(){this._not((function(){return (function(){this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");return "\"\"\""}).call(this)}));return this._apply("char")}).call(this)}));this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");"\"\"\"";return ["string",cs.join("")]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\"")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\"");return ["string",cs.join("")]}).call(this)}));case "\'":return (function(){cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\'")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\'");return ["string",cs.join("")]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){(function(){switch(this._apply('anything')){case "#":return "#";case "`":return "`";default: throw fail}}).call(this);n=this._apply("iName");return ["string",n]}).call(this)}))},
    "special":function(){var $elf=this,_fromIdx=this.input.idx,s;return (function(){s=(function(){switch(this._apply('anything')){case "(":return "(";case ")":return ")";case "{":return "{";case "}":return "}";case "[":return "[";case "]":return "]";case ",":return ",";case ";":return ";";case "?":return "?";case ":":return ":";case "!":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "!==";default: throw fail}}).call(this)}),(function(){return "!="}));default: throw fail}}).call(this)}),(function(){return "!"}));case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "===";default: throw fail}}).call(this)}),(function(){return "=="}));default: throw fail}}).call(this)}),(function(){return "="}));case ">":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return ">=";default: throw fail}}).call(this)}),(function(){return ">"}));case "<":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "<=";default: throw fail}}).call(this)}),(function(){return "<"}));case "+":return this._or((function(){return (function(){switch(this._apply('anything')){case "+":return "++";case "=":return "+=";default: throw fail}}).call(this)}),(function(){return "+"}));case "-":return this._or((function(){return (function(){switch(this._apply('anything')){case "-":return "--";case "=":return "-=";default: throw fail}}).call(this)}),(function(){return "-"}));case "*":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "*=";default: throw fail}}).call(this)}),(function(){return "*"}));case "/":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "/=";default: throw fail}}).call(this)}),(function(){return "/"}));case "%":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "%=";default: throw fail}}).call(this)}),(function(){return "%"}));case "&":return (function(){switch(this._apply('anything')){case "&":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "&&=";default: throw fail}}).call(this)}),(function(){return "&&"}));default: throw fail}}).call(this);case "|":return (function(){switch(this._apply('anything')){case "|":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "||=";default: throw fail}}).call(this)}),(function(){return "||"}));default: throw fail}}).call(this);case ".":return ".";default: throw fail}}).call(this);return [s,s]}).call(this)},
    "tok":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._or((function(){return this._apply("name")}),(function(){return this._apply("keyword")}),(function(){return this._apply("number")}),(function(){return this._apply("str")}),(function(){return this._apply("special")}))}).call(this)},
    "toks":function(){var $elf=this,_fromIdx=this.input.idx,ts;return (function(){ts=this._many((function(){return this._apply("token")}));this._apply("spaces");this._apply("end");return ts}).call(this)},
    "token":function(){var $elf=this,_fromIdx=this.input.idx,tt,t;return (function(){tt=this._apply("anything");t=this._apply("tok");this._pred((t[(0)] == tt));return t[(1)]}).call(this)},
    "spacesNoNl":function(){var $elf=this,_fromIdx=this.input.idx;return this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\n")}));return this._apply("space")}).call(this)}))},
    "expr":function(){var $elf=this,_fromIdx=this.input.idx,e,t,f,rhs;return (function(){e=this._apply("orExpr");return this._or((function(){return (function(){this._applyWithArgs("token","?");t=this._apply("expr");this._applyWithArgs("token",":");f=this._apply("expr");return ["condExpr",e,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","=");rhs=this._apply("expr");return ["set",e,rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","+=");rhs=this._apply("expr");return ["mset",e,"+",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","-=");rhs=this._apply("expr");return ["mset",e,"-",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","*=");rhs=this._apply("expr");return ["mset",e,"*",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","/=");rhs=this._apply("expr");return ["mset",e,"/",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","%=");rhs=this._apply("expr");return ["mset",e,"%",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","&&=");rhs=this._apply("expr");return ["mset",e,"&&",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","||=");rhs=this._apply("expr");return ["mset",e,"||",rhs]}).call(this)}),(function(){return (function(){this._apply("empty");return e}).call(this)}))}).call(this)},
    "orExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("orExpr");this._applyWithArgs("token","||");y=this._apply("andExpr");return ["binop","||",x,y]}).call(this)}),(function(){return this._apply("andExpr")}))},
    "andExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("andExpr");this._applyWithArgs("token","&&");y=this._apply("eqExpr");return ["binop","&&",x,y]}).call(this)}),(function(){return this._apply("eqExpr")}))},
    "eqExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("eqExpr");return this._or((function(){return (function(){this._applyWithArgs("token","==");y=this._apply("relExpr");return ["binop","==",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!=");y=this._apply("relExpr");return ["binop","!=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","===");y=this._apply("relExpr");return ["binop","===",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!==");y=this._apply("relExpr");return ["binop","!==",x,y]}).call(this)}))}).call(this)}),(function(){return this._apply("relExpr")}))},
    "relExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("relExpr");return this._or((function(){return (function(){this._applyWithArgs("token",">");y=this._apply("addExpr");return ["binop",">",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",">=");y=this._apply("addExpr");return ["binop",">=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<");y=this._apply("addExpr");return ["binop","<",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<=");y=this._apply("addExpr");return ["binop","<=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","instanceof");y=this._apply("addExpr");return ["binop","instanceof",x,y]}).call(this)}))}).call(this)}),(function(){return this._apply("addExpr")}))},
    "addExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("addExpr");this._applyWithArgs("token","+");y=this._apply("mulExpr");return ["binop","+",x,y]}).call(this)}),(function(){return (function(){x=this._apply("addExpr");this._applyWithArgs("token","-");y=this._apply("mulExpr");return ["binop","-",x,y]}).call(this)}),(function(){return this._apply("mulExpr")}))},
    "mulExpr":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return this._or((function(){return (function(){x=this._apply("mulExpr");this._applyWithArgs("token","*");y=this._apply("unary");return ["binop","*",x,y]}).call(this)}),(function(){return (function(){x=this._apply("mulExpr");this._applyWithArgs("token","/");y=this._apply("unary");return ["binop","/",x,y]}).call(this)}),(function(){return (function(){x=this._apply("mulExpr");this._applyWithArgs("token","%");y=this._apply("unary");return ["binop","%",x,y]}).call(this)}),(function(){return this._apply("unary")}))},
    "unary":function(){var $elf=this,_fromIdx=this.input.idx,p;return this._or((function(){return (function(){this._applyWithArgs("token","-");p=this._apply("postfix");return ["unop","-",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","+");p=this._apply("postfix");return ["unop","+",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","++");p=this._apply("postfix");return ["preop","++",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","--");p=this._apply("postfix");return ["preop","--",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!");p=this._apply("unary");return ["unop","!",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","void");p=this._apply("unary");return ["unop","void",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","delete");p=this._apply("unary");return ["unop","delete",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","typeof");p=this._apply("unary");return ["unop","typeof",p]}).call(this)}),(function(){return this._apply("postfix")}))},
    "postfix":function(){var $elf=this,_fromIdx=this.input.idx,p;return (function(){p=this._apply("primExpr");return this._or((function(){return (function(){this._apply("spacesNoNl");this._applyWithArgs("token","++");return ["postop","++",p]}).call(this)}),(function(){return (function(){this._apply("spacesNoNl");this._applyWithArgs("token","--");return ["postop","--",p]}).call(this)}),(function(){return (function(){this._apply("empty");return p}).call(this)}))}).call(this)},
    "primExpr":function(){var $elf=this,_fromIdx=this.input.idx,p,i,m,as,f;return this._or((function(){return (function(){p=this._apply("primExpr");return this._or((function(){return (function(){this._applyWithArgs("token","[");i=this._apply("expr");this._applyWithArgs("token","]");return ["getp",i,p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");m=this._applyWithArgs("token","name");this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["send",m,p].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");f=this._applyWithArgs("token","name");return ["getp",["string",f],p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["call",p].concat(as)}).call(this)}))}).call(this)}),(function(){return this._apply("primExprHd")}))},
    "primExprHd":function(){var $elf=this,_fromIdx=this.input.idx,e,n,s,as,es;return this._or((function(){return (function(){this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token","this");return ["this"]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","name");return ["get",n]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","number");return ["number",n]}).call(this)}),(function(){return (function(){s=this._applyWithArgs("token","string");return ["string",s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","function");return this._apply("funcRest")}).call(this)}),(function(){return (function(){this._applyWithArgs("token","new");n=this._applyWithArgs("token","name");this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["new",n].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");es=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token","]");return ["arr"].concat(es)}).call(this)}),(function(){return this._apply("json")}),(function(){return this._apply("re")}))},
    "json":function(){var $elf=this,_fromIdx=this.input.idx,bs;return (function(){this._applyWithArgs("token","{");bs=this._applyWithArgs("listOf","jsonBinding",",");this._applyWithArgs("token","}");return ["json"].concat(bs)}).call(this)},
    "jsonBinding":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._apply("jsonPropName");this._applyWithArgs("token",":");v=this._apply("expr");return ["binding",n,v]}).call(this)},
    "jsonPropName":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._applyWithArgs("token","name")}),(function(){return this._applyWithArgs("token","number")}),(function(){return this._applyWithArgs("token","string")}))},
    "re":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){this._apply("spaces");x=this._consumedBy((function(){return (function(){this._applyWithArgs("exactly","/");this._apply("reBody");this._applyWithArgs("exactly","/");return this._many((function(){return this._apply("reFlag")}))}).call(this)}));return ["regExpr",x]}).call(this)},
    "reBody":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("re1stChar");return this._many((function(){return this._apply("reChar")}))}).call(this)},
    "re1stChar":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return (function(){this._not((function(){return (function(){switch(this._apply('anything')){case "*":return "*";case "\\":return "\\";case "/":return "/";case "[":return "[";default: throw fail}}).call(this)}));return this._apply("reNonTerm")}).call(this)}),(function(){return this._apply("escapeChar")}),(function(){return this._apply("reClass")}))},
    "reChar":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return this._apply("re1stChar")}),(function(){return (function(){switch(this._apply('anything')){case "*":return "*";default: throw fail}}).call(this)}))},
    "reNonTerm":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._not((function(){return (function(){switch(this._apply('anything')){case "\n":return "\n";case "\r":return "\r";default: throw fail}}).call(this)}));return this._apply("char")}).call(this)},
    "reClass":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._applyWithArgs("exactly","[");this._many((function(){return this._apply("reClassChar")}));return this._applyWithArgs("exactly","]")}).call(this)},
    "reClassChar":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._not((function(){return (function(){switch(this._apply('anything')){case "[":return "[";case "]":return "]";default: throw fail}}).call(this)}));return this._apply("reChar")}).call(this)},
    "reFlag":function(){var $elf=this,_fromIdx=this.input.idx;return this._apply("nameFirst")},
    "formal":function(){var $elf=this,_fromIdx=this.input.idx;return (function(){this._apply("spaces");return this._applyWithArgs("token","name")}).call(this)},
    "funcRest":function(){var $elf=this,_fromIdx=this.input.idx,fs,body;return (function(){this._applyWithArgs("token","(");fs=this._applyWithArgs("listOf","formal",",");this._applyWithArgs("token",")");this._applyWithArgs("token","{");body=this._apply("srcElems");this._applyWithArgs("token","}");return ["func",fs,body]}).call(this)},
    "sc":function(){var $elf=this,_fromIdx=this.input.idx;return this._or((function(){return (function(){this._apply("spacesNoNl");return this._or((function(){return (function(){switch(this._apply('anything')){case "\n":return "\n";default: throw fail}}).call(this)}),(function(){return this._lookahead((function(){return this._applyWithArgs("exactly","}")}))}),(function(){return this._apply("end")}))}).call(this)}),(function(){return this._applyWithArgs("token",";")}))},
    "binding":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._applyWithArgs("token","name");v=this._or((function(){return (function(){this._applyWithArgs("token","=");return this._apply("expr")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["var",n,v]}).call(this)},
    "block":function(){var $elf=this,_fromIdx=this.input.idx,ss;return (function(){this._applyWithArgs("token","{");ss=this._apply("srcElems");this._applyWithArgs("token","}");return ss}).call(this)},
    "stmt":function(){var $elf=this,_fromIdx=this.input.idx,bs,c,t,f,s,i,u,n,v,e,cs,x;return this._or((function(){return this._apply("block")}),(function(){return (function(){this._applyWithArgs("token","var");bs=this._applyWithArgs("listOf","binding",",");this._apply("sc");return ["begin"].concat(bs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","if");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");t=this._apply("stmt");f=this._or((function(){return (function(){this._applyWithArgs("token","else");return this._apply("stmt")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["if",c,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["while",c,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","do");s=this._apply("stmt");this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");this._apply("sc");return ["doWhile",s,c]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");i=this._or((function(){return (function(){this._applyWithArgs("token","var");return this._apply("binding")}).call(this)}),(function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._applyWithArgs("token",";");c=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","true"]}).call(this)}));this._applyWithArgs("token",";");u=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._applyWithArgs("token",")");s=this._apply("stmt");return ["for",i,c,u,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");v=this._or((function(){return (function(){this._applyWithArgs("token","var");n=this._applyWithArgs("token","name");return ["var",n,["get","undefined"]]}).call(this)}),(function(){return this._apply("expr")}));this._applyWithArgs("token","in");e=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["forIn",v,e,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","switch");this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");this._applyWithArgs("token","{");cs=this._many((function(){return this._or((function(){return (function(){this._applyWithArgs("token","case");c=this._apply("expr");this._applyWithArgs("token",":");cs=this._apply("srcElems");return ["case",c,cs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","default");this._applyWithArgs("token",":");cs=this._apply("srcElems");return ["default",cs]}).call(this)}))}));this._applyWithArgs("token","}");return ["switch",e].concat(cs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","break");this._apply("sc");return ["break"]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","continue");this._apply("sc");return ["continue"]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","throw");this._apply("spacesNoNl");e=this._apply("expr");this._apply("sc");return ["throw",e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","try");t=this._apply("block");this._applyWithArgs("token","catch");this._applyWithArgs("token","(");e=this._applyWithArgs("token","name");this._applyWithArgs("token",")");c=this._apply("block");f=this._or((function(){return (function(){this._applyWithArgs("token","finally");return this._apply("block")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["try",t,e,c,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","return");e=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._apply("sc");return ["return",e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","with");this._applyWithArgs("token","(");x=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["with",x,s]}).call(this)}),(function(){return (function(){e=this._apply("expr");this._apply("sc");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token",";");return ["get","undefined"]}).call(this)}))},
    "srcElem":function(){var $elf=this,_fromIdx=this.input.idx,n,f;return this._or((function(){return (function(){this._applyWithArgs("token","function");n=this._applyWithArgs("token","name");f=this._apply("funcRest");return ["var",n,f]}).call(this)}),(function(){return this._apply("stmt")}))},
    "srcElems":function(){var $elf=this,_fromIdx=this.input.idx,ss;return (function(){ss=this._many((function(){return this._apply("srcElem")}));return ["begin"].concat(ss)}).call(this)},
    "topLevel":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._apply("srcElems");this._apply("spaces");this._apply("end");return r}).call(this)}});(BSJSParser["hexDigits"]="0123456789abcdef");(BSJSParser["keywords"]=({}));(keywords=["break","case","catch","continue","default","delete","do","else","finally","for","function","if","in","instanceof","new","return","switch","this","throw","try","typeof","var","void","while","with","ometa"]);for(var idx=(0);(idx < keywords["length"]);idx++){(BSJSParser["keywords"][keywords[idx]]=true)}(BSJSParser["_isKeyword"]=(function (k){return this["keywords"].hasOwnProperty(k)}));BSSemActionParser=objectThatDelegatesTo(BSJSParser,{
    "curlySemAction":function(){var $elf=this,_fromIdx=this.input.idx,r,s,ss;return this._or((function(){return (function(){this._applyWithArgs("token","{");r=this._apply("expr");this._apply("sc");this._applyWithArgs("token","}");this._apply("spaces");return r}).call(this)}),(function(){return (function(){this._applyWithArgs("token","{");ss=this._many((function(){return (function(){s=this._apply("srcElem");this._lookahead((function(){return this._apply("srcElem")}));return s}).call(this)}));s=this._or((function(){return (function(){r=this._apply("expr");this._apply("sc");return ["return",r]}).call(this)}),(function(){return this._apply("srcElem")}));ss.push(s);this._applyWithArgs("token","}");this._apply("spaces");return ["send","call",["func",[],["begin"].concat(ss)],["this"]]}).call(this)}))},
    "semAction":function(){var $elf=this,_fromIdx=this.input.idx,r;return this._or((function(){return this._apply("curlySemAction")}),(function(){return (function(){r=this._apply("primExpr");this._apply("spaces");return r}).call(this)}))}});BSJSTranslator=objectThatDelegatesTo(OMeta,{
    "trans":function(){var $elf=this,_fromIdx=this.input.idx,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
    "curlyTrans":function(){var $elf=this,_fromIdx=this.input.idx,r,rs;return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","begin");return r=this._apply("curlyTrans")}).call(this)}));return r}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","begin");return rs=this._many((function(){return this._apply("trans")}))}).call(this)}));return (("{" + rs.join(";")) + "}")}).call(this)}),(function(){return (function(){r=this._apply("trans");return (("{" + r) + "}")}).call(this)}))},
    "this":function(){var $elf=this,_fromIdx=this.input.idx;return "this"},
    "break":function(){var $elf=this,_fromIdx=this.input.idx;return "break"},
    "continue":function(){var $elf=this,_fromIdx=this.input.idx;return "continue"},
    "number":function(){var $elf=this,_fromIdx=this.input.idx,n;return (function(){n=this._apply("anything");return (("(" + n) + ")")}).call(this)},
    "string":function(){var $elf=this,_fromIdx=this.input.idx,s;return (function(){s=this._apply("anything");return s.toProgramString()}).call(this)},
    "regExpr":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return x}).call(this)},
    "arr":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return (("[" + xs.join(",")) + "]")}).call(this)},
    "unop":function(){var $elf=this,_fromIdx=this.input.idx,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return (((("(" + op) + " ") + x) + ")")}).call(this)},
    "getp":function(){var $elf=this,_fromIdx=this.input.idx,fd,x;return (function(){fd=this._apply("trans");x=this._apply("trans");return (((x + "[") + fd) + "]")}).call(this)},
    "get":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("anything");return x}).call(this)},
    "set":function(){var $elf=this,_fromIdx=this.input.idx,lhs,rhs;return (function(){lhs=this._apply("trans");rhs=this._apply("trans");return (((("(" + lhs) + "=") + rhs) + ")")}).call(this)},
    "mset":function(){var $elf=this,_fromIdx=this.input.idx,lhs,op,rhs;return (function(){lhs=this._apply("trans");op=this._apply("anything");rhs=this._apply("trans");return ((((("(" + lhs) + op) + "=") + rhs) + ")")}).call(this)},
    "binop":function(){var $elf=this,_fromIdx=this.input.idx,op,x,y;return (function(){op=this._apply("anything");x=this._apply("trans");y=this._apply("trans");return (((((("(" + x) + " ") + op) + " ") + y) + ")")}).call(this)},
    "preop":function(){var $elf=this,_fromIdx=this.input.idx,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return (op + x)}).call(this)},
    "postop":function(){var $elf=this,_fromIdx=this.input.idx,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return (x + op)}).call(this)},
    "return":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ("return " + x)}).call(this)},
    "with":function(){var $elf=this,_fromIdx=this.input.idx,x,s;return (function(){x=this._apply("trans");s=this._apply("curlyTrans");return ((("with(" + x) + ")") + s)}).call(this)},
    "if":function(){var $elf=this,_fromIdx=this.input.idx,cond,t,e;return (function(){cond=this._apply("trans");t=this._apply("curlyTrans");e=this._apply("curlyTrans");return ((((("if(" + cond) + ")") + t) + "else") + e)}).call(this)},
    "condExpr":function(){var $elf=this,_fromIdx=this.input.idx,cond,t,e;return (function(){cond=this._apply("trans");t=this._apply("trans");e=this._apply("trans");return (((((("(" + cond) + "?") + t) + ":") + e) + ")")}).call(this)},
    "while":function(){var $elf=this,_fromIdx=this.input.idx,cond,body;return (function(){cond=this._apply("trans");body=this._apply("curlyTrans");return ((("while(" + cond) + ")") + body)}).call(this)},
    "doWhile":function(){var $elf=this,_fromIdx=this.input.idx,body,cond;return (function(){body=this._apply("curlyTrans");cond=this._apply("trans");return (((("do" + body) + "while(") + cond) + ")")}).call(this)},
    "for":function(){var $elf=this,_fromIdx=this.input.idx,init,cond,upd,body;return (function(){init=this._apply("trans");cond=this._apply("trans");upd=this._apply("trans");body=this._apply("curlyTrans");return ((((((("for(" + init) + ";") + cond) + ";") + upd) + ")") + body)}).call(this)},
    "forIn":function(){var $elf=this,_fromIdx=this.input.idx,x,arr,body;return (function(){x=this._apply("trans");arr=this._apply("trans");body=this._apply("curlyTrans");return ((((("for(" + x) + " in ") + arr) + ")") + body)}).call(this)},
    "begin":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");return x}).call(this)}),(function(){return (function(){xs=this._many((function(){return (function(){x=this._apply("trans");return this._or((function(){return (function(){this._or((function(){return this._pred((x[(x["length"] - (1))] == "}"))}),(function(){return this._apply("end")}));return x}).call(this)}),(function(){return (function(){this._apply("empty");return (x + ";")}).call(this)}))}).call(this)}));return (("{" + xs.join("")) + "}")}).call(this)}))},
    "func":function(){var $elf=this,_fromIdx=this.input.idx,args,body;return (function(){args=this._apply("anything");body=this._apply("curlyTrans");return (((("(function (" + args.join(",")) + ")") + body) + ")")}).call(this)},
    "call":function(){var $elf=this,_fromIdx=this.input.idx,fn,args;return (function(){fn=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return (((fn + "(") + args.join(",")) + ")")}).call(this)},
    "send":function(){var $elf=this,_fromIdx=this.input.idx,msg,recv,args;return (function(){msg=this._apply("anything");recv=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return (((((recv + ".") + msg) + "(") + args.join(",")) + ")")}).call(this)},
    "new":function(){var $elf=this,_fromIdx=this.input.idx,cls,args;return (function(){cls=this._apply("anything");args=this._many((function(){return this._apply("trans")}));return (((("new " + cls) + "(") + args.join(",")) + ")")}).call(this)},
    "var":function(){var $elf=this,_fromIdx=this.input.idx,name,val;return (function(){name=this._apply("anything");val=this._apply("trans");return ((("var " + name) + "=") + val)}).call(this)},
    "throw":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ("throw " + x)}).call(this)},
    "try":function(){var $elf=this,_fromIdx=this.input.idx,x,name,c,f;return (function(){x=this._apply("curlyTrans");name=this._apply("anything");c=this._apply("curlyTrans");f=this._apply("curlyTrans");return ((((((("try " + x) + "catch(") + name) + ")") + c) + "finally") + f)}).call(this)},
    "json":function(){var $elf=this,_fromIdx=this.input.idx,props;return (function(){props=this._many((function(){return this._apply("trans")}));return (("({" + props.join(",")) + "})")}).call(this)},
    "binding":function(){var $elf=this,_fromIdx=this.input.idx,name,val;return (function(){name=this._apply("anything");val=this._apply("trans");return ((name.toProgramString() + ": ") + val)}).call(this)},
    "switch":function(){var $elf=this,_fromIdx=this.input.idx,x,cases;return (function(){x=this._apply("trans");cases=this._many((function(){return this._apply("trans")}));return (((("switch(" + x) + "){") + cases.join(";")) + "}")}).call(this)},
    "case":function(){var $elf=this,_fromIdx=this.input.idx,x,y;return (function(){x=this._apply("trans");y=this._apply("trans");return ((("case " + x) + ": ") + y)}).call(this)},
    "default":function(){var $elf=this,_fromIdx=this.input.idx,y;return (function(){y=this._apply("trans");return ("default: " + y)}).call(this)}})}

















{BSOMetaJSParser=objectThatDelegatesTo(BSJSParser,{
    "srcElem":function(){var $elf=this,_fromIdx=this.input.idx,r;return this._or((function(){return (function(){this._apply("spaces");r=this._applyWithArgs("foreign",BSOMetaParser,'grammar');this._apply("sc");return r}).call(this)}),(function(){return BSJSParser._superApplyWithArgs(this,'srcElem')}))}});BSOMetaJSTranslator=objectThatDelegatesTo(BSJSTranslator,{
    "Grammar":function(){var $elf=this,_fromIdx=this.input.idx;return this._applyWithArgs("foreign",BSOMetaTranslator,'Grammar')}})}















{BSNullOptimization=objectThatDelegatesTo(OMeta,{
    "setHelped":function(){var $elf=this,_fromIdx=this.input.idx;return (this["_didSomething"]=true)},
    "helped":function(){var $elf=this,_fromIdx=this.input.idx;return this._pred(this["_didSomething"])},
    "trans":function(){var $elf=this,_fromIdx=this.input.idx,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");this._pred((this[t] != undefined));return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
    "optimize":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");this._apply("helped");return x}).call(this)},
    "App":function(){var $elf=this,_fromIdx=this.input.idx,rule,args;return (function(){rule=this._apply("anything");args=this._many((function(){return this._apply("anything")}));return ["App",rule].concat(args)}).call(this)},
    "Act":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return ["Act",expr]}).call(this)},
    "Pred":function(){var $elf=this,_fromIdx=this.input.idx,expr;return (function(){expr=this._apply("anything");return ["Pred",expr]}).call(this)},
    "Or":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return ["Or"].concat(xs)}).call(this)},
    "XOr":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return ["XOr"].concat(xs)}).call(this)},
    "And":function(){var $elf=this,_fromIdx=this.input.idx,xs;return (function(){xs=this._many((function(){return this._apply("trans")}));return ["And"].concat(xs)}).call(this)},
    "Opt":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Opt",x]}).call(this)},
    "Many":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Many",x]}).call(this)},
    "Many1":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Many1",x]}).call(this)},
    "Set":function(){var $elf=this,_fromIdx=this.input.idx,n,v;return (function(){n=this._apply("anything");v=this._apply("trans");return ["Set",n,v]}).call(this)},
    "Not":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Not",x]}).call(this)},
    "Lookahead":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Lookahead",x]}).call(this)},
    "Form":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["Form",x]}).call(this)},
    "ConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["ConsBy",x]}).call(this)},
    "IdxConsBy":function(){var $elf=this,_fromIdx=this.input.idx,x;return (function(){x=this._apply("trans");return ["IdxConsBy",x]}).call(this)},
    "JumpTable":function(){var $elf=this,_fromIdx=this.input.idx,c,e,ces;return (function(){ces=this._many((function(){return (function(){this._form((function(){return (function(){c=this._apply("anything");return e=this._apply("trans")}).call(this)}));return [c,e]}).call(this)}));return ["JumpTable"].concat(ces)}).call(this)},
    "Interleave":function(){var $elf=this,_fromIdx=this.input.idx,m,p,xs;return (function(){xs=this._many((function(){return (function(){this._form((function(){return (function(){m=this._apply("anything");return p=this._apply("trans")}).call(this)}));return [m,p]}).call(this)}));return ["Interleave"].concat(xs)}).call(this)},
    "Rule":function(){var $elf=this,_fromIdx=this.input.idx,name,ls,body;return (function(){name=this._apply("anything");ls=this._apply("anything");body=this._apply("trans");return ["Rule",name,ls,body]}).call(this)}});(BSNullOptimization["initialize"]=(function (){(this["_didSomething"]=false)}));BSAssociativeOptimization=objectThatDelegatesTo(BSNullOptimization,{
    "And":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");this._apply("setHelped");return x}).call(this)}),(function(){return (function(){xs=this._applyWithArgs("transInside","And");return ["And"].concat(xs)}).call(this)}))},
    "Or":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");this._apply("setHelped");return x}).call(this)}),(function(){return (function(){xs=this._applyWithArgs("transInside","Or");return ["Or"].concat(xs)}).call(this)}))},
    "XOr":function(){var $elf=this,_fromIdx=this.input.idx,x,xs;return this._or((function(){return (function(){x=this._apply("trans");this._apply("end");this._apply("setHelped");return x}).call(this)}),(function(){return (function(){xs=this._applyWithArgs("transInside","XOr");return ["XOr"].concat(xs)}).call(this)}))},
    "transInside":function(){var $elf=this,_fromIdx=this.input.idx,t,xs,ys,x;return (function(){t=this._apply("anything");return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly",t);return xs=this._applyWithArgs("transInside",t)}).call(this)}));ys=this._applyWithArgs("transInside",t);this._apply("setHelped");return xs.concat(ys)}).call(this)}),(function(){return (function(){x=this._apply("trans");xs=this._applyWithArgs("transInside",t);return [x].concat(xs)}).call(this)}),(function(){return []}))}).call(this)}});BSSeqInliner=objectThatDelegatesTo(BSNullOptimization,{
    "App":function(){var $elf=this,_fromIdx=this.input.idx,s,cs,rule,args;return this._or((function(){return (function(){switch(this._apply('anything')){case "seq":return (function(){s=this._apply("anything");this._apply("end");cs=this._applyWithArgs("seqString",s);this._apply("setHelped");return ["And"].concat(cs).concat([["Act",s]])}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){rule=this._apply("anything");args=this._many((function(){return this._apply("anything")}));return ["App",rule].concat(args)}).call(this)}))},
    "inlineChar":function(){var $elf=this,_fromIdx=this.input.idx,c;return (function(){c=this._applyWithArgs("foreign",BSOMetaParser,'eChar');this._not((function(){return this._apply("end")}));return ["App","exactly",c.toProgramString()]}).call(this)},
    "seqString":function(){var $elf=this,_fromIdx=this.input.idx,s,cs;return (function(){this._lookahead((function(){return (function(){s=this._apply("anything");return this._pred(((typeof s) === "string"))}).call(this)}));return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","\"");cs=this._many((function(){return this._apply("inlineChar")}));return this._applyWithArgs("exactly","\"")}).call(this)}));return cs}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","\'");cs=this._many((function(){return this._apply("inlineChar")}));return this._applyWithArgs("exactly","\'")}).call(this)}));return cs}).call(this)}))}).call(this)}});(JumpTable=(function (choiceOp,choice){(this["choiceOp"]=choiceOp);(this["choices"]=({}));this.add(choice)}));(JumpTable["prototype"]["add"]=(function (choice){{var c=choice[(0)];var t=choice[(1)]};if(this["choices"][c]){if((this["choices"][c][(0)] == this["choiceOp"])){this["choices"][c].push(t)}else{(this["choices"][c]=[this["choiceOp"],this["choices"][c],t])}}else{(this["choices"][c]=t)}}));(JumpTable["prototype"]["toTree"]=(function (){{var r=["JumpTable"];var choiceKeys=ownPropertyNames(this["choices"])};for(var i=(0);(i < choiceKeys["length"]);(i+=(1))){r.push([choiceKeys[i],this["choices"][choiceKeys[i]]])};return r}));BSJumpTableOptimization=objectThatDelegatesTo(BSNullOptimization,{
    "Or":function(){var $elf=this,_fromIdx=this.input.idx,cs;return (function(){cs=this._many((function(){return this._or((function(){return this._applyWithArgs("jtChoices","Or")}),(function(){return this._apply("trans")}))}));return ["Or"].concat(cs)}).call(this)},
    "XOr":function(){var $elf=this,_fromIdx=this.input.idx,cs;return (function(){cs=this._many((function(){return this._or((function(){return this._applyWithArgs("jtChoices","XOr")}),(function(){return this._apply("trans")}))}));return ["XOr"].concat(cs)}).call(this)},
    "quotedString":function(){var $elf=this,_fromIdx=this.input.idx,c,cs;return (function(){this._lookahead((function(){return this._apply("string")}));this._form((function(){return (function(){switch(this._apply('anything')){case "\"":return (function(){cs=this._many((function(){return (function(){c=this._applyWithArgs("foreign",BSOMetaParser,'eChar');this._not((function(){return this._apply("end")}));return c}).call(this)}));return this._applyWithArgs("exactly","\"")}).call(this);case "\'":return (function(){cs=this._many((function(){return (function(){c=this._applyWithArgs("foreign",BSOMetaParser,'eChar');this._not((function(){return this._apply("end")}));return c}).call(this)}));return this._applyWithArgs("exactly","\'")}).call(this);default: throw fail}}).call(this)}));return cs.join("")}).call(this)},
    "jtChoice":function(){var $elf=this,_fromIdx=this.input.idx,x,rest;return this._or((function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","And");this._form((function(){return (function(){this._applyWithArgs("exactly","App");this._applyWithArgs("exactly","exactly");return x=this._apply("quotedString")}).call(this)}));return rest=this._many((function(){return this._apply("anything")}))}).call(this)}));return [x,["And"].concat(rest)]}).call(this)}),(function(){return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","App");this._applyWithArgs("exactly","exactly");return x=this._apply("quotedString")}).call(this)}));return [x,["Act",x.toProgramString()]]}).call(this)}))},
    "jtChoices":function(){var $elf=this,_fromIdx=this.input.idx,op,c,jt;return (function(){op=this._apply("anything");c=this._apply("jtChoice");jt=new JumpTable(op,c);this._many((function(){return (function(){c=this._apply("jtChoice");return jt.add(c)}).call(this)}));this._apply("setHelped");return jt.toTree()}).call(this)}});BSOMetaOptimizer=objectThatDelegatesTo(OMeta,{
    "optimizeGrammar":function(){var $elf=this,_fromIdx=this.input.idx,n,sn,rs;return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","Grammar");n=this._apply("anything");sn=this._apply("anything");return rs=this._many((function(){return this._apply("optimizeRule")}))}).call(this)}));return ["Grammar",n,sn].concat(rs)}).call(this)},
    "optimizeRule":function(){var $elf=this,_fromIdx=this.input.idx,r;return (function(){r=this._apply("anything");this._or((function(){return r=this._applyWithArgs("foreign",BSSeqInliner,'optimize',r)}),(function(){return this._apply("empty")}));this._many((function(){return this._or((function(){return r=this._applyWithArgs("foreign",BSAssociativeOptimization,'optimize',r)}),(function(){return r=this._applyWithArgs("foreign",BSJumpTableOptimization,'optimize',r)}))}));return r}).call(this)}})}











LKJSParser=objectThatDelegatesTo(BSJSParser,{
    "regexp":function(){var $elf=this,cs,fs,flag;return (function(){this._applyWithArgs("exactly","/");cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","/")}));this._not((function(){return this._applyWithArgs("exactly","\n")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","/");flag=this._or((function(){return (function(){fs=this._many1((function(){return (function(){switch(this._apply('anything')){case "m":return "m";case "g":return "g";case "i":return "i";case "y":return "y";default: throw fail}}).call(this)}));return fs.join("")}).call(this)}),(function(){return (function(){this._apply("empty");return ""}).call(this)}));return ["regexp",((("/" + cs.join("")) + "/") + flag)]}).call(this)},
    "tok":function(){var $elf=this;return (function(){this._apply("spaces");return this._or((function(){return this._apply("name")}),(function(){return this._apply("keyword")}),(function(){return this._apply("number")}),(function(){return this._apply("str")}),(function(){return this._apply("regexp")}),(function(){return this._apply("special")}))}).call(this)},
    "relExpr":function(){var $elf=this,x,y,y,y,y,y,y;return this._or((function(){return (function(){x=this._apply("relExpr");return this._or((function(){return (function(){this._applyWithArgs("token",">");y=this._apply("addExpr");return ["binop",">",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",">=");y=this._apply("addExpr");return ["binop",">=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<");y=this._apply("addExpr");return ["binop","<",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<=");y=this._apply("addExpr");return ["binop","<=",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","instanceof");y=this._apply("addExpr");return ["binop","instanceof",x,y]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","in");y=this._apply("addExpr");return ["binop","in",x,y]}).call(this)}))}).call(this)}),(function(){return this._apply("addExpr")}))},
    "primExprHd":function(){var $elf=this,e,n,n,s,r,n,f,n,name,as,newExpr,as,es;return this._or((function(){return (function(){this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token","this");return ["this"]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","name");return ["get",n]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","number");return ["number",n]}).call(this)}),(function(){return (function(){s=this._applyWithArgs("token","string");return ["string",s]}).call(this)}),(function(){return (function(){r=this._applyWithArgs("token","regexp");return ["regexp",r]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","function");return this._apply("funcRest")}).call(this)}),(function(){return (function(){this._applyWithArgs("token","function");n=this._applyWithArgs("token","name");f=this._apply("funcRest");return ["var",n,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","new");name=this._many((function(){return (function(){n=this._applyWithArgs("token","name");this._or((function(){return (function(){switch(this._apply('anything')){case ".":return ".";default: throw fail}}).call(this)}),(function(){return this._apply("empty")}));return n}).call(this)}));this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["new",name.join(".")].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","new");this._applyWithArgs("token","(");newExpr=this._apply("expr");this._applyWithArgs("token",")");this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","expr",",");this._applyWithArgs("token",")");return ["newExpr",newExpr].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");es=this._applyWithArgs("listOf","expr",",");this._or((function(){return (function(){switch(this._apply('anything')){case ",":return ",";default: throw fail}}).call(this)}),(function(){return this._apply("empty")}));this._applyWithArgs("token","]");return ["arr"].concat(es)}).call(this)}),(function(){return this._apply("json")}))},
    "json":function(){var $elf=this,bs;return (function(){this._applyWithArgs("token","{");bs=this._applyWithArgs("listOf","jsonBinding",",");this._or((function(){return (function(){switch(this._apply('anything')){case ",":return ",";default: throw fail}}).call(this)}),(function(){return this._apply("empty")}));this._applyWithArgs("token","}");return ["json"].concat(bs)}).call(this)},
    "varBinding":function(){var $elf=this,n,v;return (function(){n=this._applyWithArgs("token","name");v=this._or((function(){return (function(){this._applyWithArgs("token","=");return this._apply("expr")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["var",n,v]}).call(this)},
    "stmt":function(){var $elf=this,bs,c,t,f,c,s,s,c,vars,i,c,u,s,n,v,e,s,e,c,cs,cs,cs,e,t,e,c,ca,f,e,x,s,e;return this._or((function(){return this._apply("block")}),(function(){return (function(){this._applyWithArgs("token","var");bs=this._applyWithArgs("listOf","varBinding",",");this._apply("sc");return ["begin"].concat(bs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","if");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");t=this._apply("stmt");f=this._or((function(){return (function(){this._applyWithArgs("token","else");return this._apply("stmt")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["if",c,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["while",c,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","do");s=this._apply("stmt");this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");this._apply("sc");return ["doWhile",s,c]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");i=this._or((function(){return (function(){this._applyWithArgs("token","var");vars=this._applyWithArgs("listOf","varBinding",",");return ["multiVar",vars]}).call(this)}),(function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._applyWithArgs("token",";");c=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","true"]}).call(this)}));this._applyWithArgs("token",";");u=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._applyWithArgs("token",")");s=this._apply("stmt");return ["for",i,c,u,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");v=this._or((function(){return (function(){this._applyWithArgs("token","var");n=this._applyWithArgs("token","name");return ["var",n,["get","undefined"]]}).call(this)}),(function(){return this._apply("expr")}));this._applyWithArgs("token","in");e=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["forIn",v,e,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","switch");this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");this._applyWithArgs("token","{");cs=this._many((function(){return this._or((function(){return (function(){this._applyWithArgs("token","case");c=this._apply("expr");this._applyWithArgs("token",":");cs=this._apply("srcElems");return ["case",c,cs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","default");this._applyWithArgs("token",":");cs=this._apply("srcElems");return ["default",cs]}).call(this)}))}));this._applyWithArgs("token","}");return ["switch",e].concat(cs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","break");this._apply("sc");return ["break"]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","continue");this._apply("sc");return ["continue"]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","throw");this._apply("spacesNoNl");e=this._apply("expr");this._apply("sc");return ["throw",e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","try");t=this._apply("block");ca=this._or((function(){return (function(){this._applyWithArgs("token","catch");this._applyWithArgs("token","(");e=this._applyWithArgs("token","name");this._applyWithArgs("token",")");c=this._apply("block");return [e,c]}).call(this)}),(function(){return (function(){this._apply("empty");return ["",["get","undefined"]]}).call(this)}));f=this._or((function(){return (function(){this._applyWithArgs("token","finally");return this._apply("block")}).call(this)}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));return ["try",t].concat(ca).concat([f])}).call(this)}),(function(){return (function(){this._applyWithArgs("token","return");e=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");return ["get","undefined"]}).call(this)}));this._apply("sc");return ["return",e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","with");this._applyWithArgs("token","(");x=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");return ["with",x,s]}).call(this)}),(function(){return (function(){e=this._apply("expr");this._apply("sc");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token",";");return ["get","undefined"]}).call(this)}))}});LKJSTranslator=objectThatDelegatesTo(BSJSTranslator,{
    "regexp":function(){var $elf=this,re;return (function(){re=this._apply("anything");return re}).call(this)},
    "preopSpace":function(){var $elf=this,op,x;return (function(){op=this._apply("anything");x=this._apply("trans");return ((op + " ") + x)}).call(this)},
    "newExpr":function(){var $elf=this,newExpr,args;return (function(){newExpr=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return (((((("new " + "(") + newExpr) + ")") + "(") + args.join(",")) + ")")}).call(this)},
    "singleVar":function(){var $elf=this,name,val;return (function(){this._form((function(){return (function(){this._applyWithArgs("exactly","var");name=this._apply("anything");return val=this._apply("trans")}).call(this)}));return ((name + "=") + val)}).call(this)},
    "multiVar":function(){var $elf=this,xs;return (function(){this._form((function(){return xs=this._many((function(){return this._apply("singleVar")}))}));return ("var " + xs.join(","))}).call(this)},
    "try":function(){var $elf=this,x,name,c,f;return (function(){x=this._apply("curlyTrans");name=this._apply("anything");c=this._apply("curlyTrans");f=this._apply("curlyTrans");return (((("try " + x) + (name?((("catch(" + name) + ")") + c):"")) + "finally") + f)}).call(this)}});LKOMetaParser=objectThatDelegatesTo(BSOMetaParser,{
    "hostExpr":function(){var $elf=this,r;return (function(){r=this._applyWithArgs("foreign",LKJSParser,'expr');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
    "atomicHostExpr":function(){var $elf=this,r;return (function(){r=this._applyWithArgs("foreign",LKJSParser,'semAction');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)},
    "curlyHostExpr":function(){var $elf=this,r;return (function(){r=this._applyWithArgs("foreign",LKJSParser,'curlySemAction');return this._applyWithArgs("foreign",BSJSTranslator,'trans',r)}).call(this)}});LKOMetaJSParser=objectThatDelegatesTo(LKJSParser,{
    "srcElem":function(){var $elf=this,r;return this._or((function(){return (function(){this._apply("spaces");r=this._applyWithArgs("foreign",LKOMetaParser,'grammar');this._apply("sc");return r}).call(this)}),(function(){return LKJSParser._superApplyWithArgs(this,'srcElem')}))}});LKOMetaJSTranslator=objectThatDelegatesTo(LKJSTranslator,{
    "Grammar":function(){var $elf=this;return this._applyWithArgs("foreign",BSOMetaTranslator,'Grammar')}});










/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 * Copyright (c) 2008-2011 Hasso Plattner Institute
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


module('lively.Ometa').requires('lively.Network', 'ometa.lively').toRun(function() {

    /*
     An OMeta Workspace like http://www.cs.ucla.edu/~awarth/ometa/.
     Uses Alessandro Warth OMeta-js 2 to evalute text.
     */
    Object.subclass('OMetaSupport');

    Object.extend(OMetaSupport, {

        ometaGrammarDir: URL.codeBase,

        fromFile: function(fileName) {
            var src = OMetaSupport.fileContent(fileName),
                grammar = OMetaSupport.ometaEval(src);
            return grammar;
        },

        translateAndWrite: function(sourceFileName, destFileName, additionalRequirements) {
            var requirementsString = additionalRequirements ? ",'" + additionalRequirements.join("','") + "'" : "",
                str = Strings.format('module(\'%s\').requires(\'ometa.lively\'%s).toRun(function() {\n%s\n});',
                    destFileName.replace(/\.js$/, '').replace(/\//g, '.'),
                    requirementsString,
                    OMetaSupport.translateToJs(OMetaSupport.fileContent(sourceFileName)));
            OMetaSupport.writeGrammar(destFileName, str);
            lively.morphic.World.current().setStatusMessage(
                Strings.format('Successfully compiled OMeta grammar %s to %s', sourceFileName, destFileName),
                Color.green, 3);
        },
        translate: function(source, additionalRequirements, destFileName) {
            destFileName = destFileName || 'anonymousOMetaModule';
            var requirementsString = additionalRequirements ? ",'" + additionalRequirements.join("','") + "'" : "",
                str = Strings.format('module(\'%s\').requires(\'ometa.lively\'%s).toRun(function() {\n%s\n});',
                    destFileName.replace(/\.js$/, '').replace(/\//g, '.'),
                    requirementsString,
                    OMetaSupport.translateToJs(source));
            lively.morphic.World.current().setStatusMessage(
                Strings.format('Successfully compiled OMeta grammar %s', source.truncate(300)),
                Color.green, 3);
            return str;
        },


        ometaEval: function(src) {
            var jsSrc = OMetaSupport.translateToJs(src);
            return eval(jsSrc);
        },

        translateToJs: function(src) {
            var ometaSrc = OMetaSupport.matchAllWithGrammar(BSOMetaJSParser, "topLevel", src);
            if (!ometaSrc) throw new Error('Problem in translateToJs: Cannot create OMeta Ast from source');
            var jsSrc = OMetaSupport.matchWithGrammar(BSOMetaJSTranslator, "trans", ometaSrc);
            return jsSrc;
        },

        matchAllWithGrammar: function(grammar, rule, src, errorHandling) {
            // errorHandling can be undefined or a callback or true (own error handle is used)
            var errorFunc;
            if (!errorHandling) errorFunc = OMetaSupport.handleErrorDebug;
            else if (errorHandling instanceof Function) errorFunc = errorHandling
            else errorFunc = OMetaSupport.handleErrorDebug;
            return grammar.matchAll(src, rule, null, errorFunc.curry(src, rule));
        },

        matchWithGrammar: function(grammar, rule, src, errorHandling) {
            // errorHandling can be undefined or a callback or true (own error handle is used)
            var errorFunc;
            if (!errorHandling) errorFunc = OMetaSupport.handleErrorDebug;
            else if (errorHandling instanceof Function) errorFunc = errorHandling
            else errorFunc = OMetaSupport.handleErrorDebug;
            return grammar.match(src, rule, null, errorFunc.curry(src, rule));
        },

        handleErrorDebug: function(src, rule, grammarInstance, errorIndex) {
            var charsBefore = 500,
                charsAfter = 250,
                msg = 'OMeta Error -- ' + rule + '\n',
                startIndex = Math.max(0, errorIndex - charsBefore),
                stopIndex = Math.min(src.length, errorIndex + charsAfter);

            //console.log('Last twenty Rules: ' + grammarInstance._ruleStack && grammarInstance._ruleStack.slice(grammarInstance._ruleStack.length-20));
            msg += src.constructor === Array ?
            'src = [' + src.toString() + ']' :
            src.substring(startIndex, errorIndex) + '<--Error-->' + src.substring(errorIndex, stopIndex);
            console.log(msg);
            return msg;
        },

        handleError: function(src, rule, grammarInstance, errorIndex) {},

        fileContent: function(fileName) {
            var url = URL.root.withFilename(fileName);
            return new WebResource(url).get().content;
        },

        writeGrammar: function(fileName, src) {
            var url = URL.root.withFilename(fileName);
            return new WebResource(url).put(src);
        }
    });

});










module('users.timfelgentreff.jsinterpreter.generated.Nodes').requires().toRun(function() {
    Object.subclass('users.timfelgentreff.jsinterpreter.Node');

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Sequence',
        'testing', {
            isSequence: true,
        },
        'initializing', {
            initialize: function($super, pos, children) {
                this.pos = pos;
                this.children = children;
                children.forEach(function(node) { node.setParent(this) }, this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.children) },
            toString: function () {
                return Strings.format(
                    '%s(%s)',
                    this.constructor.name, this.children.join(','))
            },
        },
        'conversion', {
            asJS: function (depth) {
                var indent = this.indent(depth || 0);
                depth = depth || -1;
                return this.children.invoke('asJS', depth + 1).join(';\n' + indent);
            },
        },
        'insertion', {
            insertBefore: function (newNode, existingNode) {
                for (var i = 0; i < this.children.length; i++)
                    if (this.children[i].nodesMatching(function(node) {
                            return node === existingNode }).length > 0)
                        break;
                if (!this.children[i])
                    throw dbgOn(new Error('insertBefore: ' + existingNode + ' not in ' + this));
                return this.insertAt(newNode, i);
            },
            insertAt: function (newNode, idx) {
                this.children.pushAt(newNode, idx);
                newNode.setParent(this);
                return newNode;
            },
        },
        'accessing', {
            parentSequence: function () { return this },
        },
        'stepping', {
            firstStatement: function () {
                return this.children.length > 0
                    ? this.children[0].firstStatement()
                    : this;
            },
            nextStatement: function ($super, node) {
                var idx = this.children.indexOf(node);
                if (idx >= 0 && idx < this.children.length - 1)
                    return this.children[idx + 1];
                return $super(this);
            },
            isComposite: function () {
                return true;
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitSequence(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Number',
        'testing', {
            isNumber: true,
        },
        'initializing', {
            initialize: function($super, pos, value) {
                this.pos = pos;
                this.value = value;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.pos, this.value) },
            toString: function () { return Strings.format('%s(%s)', this.constructor.name, this.value) },
        },
        'conversion', {
            asJS: function (depth) { return this.value },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitNumber(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.String',
        'testing', {
            isString: true,
        },
        'initializing', {
            initialize: function($super, pos, value) {
                this.pos = pos;
                this.value = value;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"' + this.value + '"') },
            toString: function () { return Strings.format('%s(%s)', this.constructor.name, this.value) },
        },
        'conversion', {
            asJS: function (depth) { return '"' + this.value + '"' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitString(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Cond',
        'testing', {
            isCond: true,
        },
        'initializing', {
            initialize: function($super, pos, condExpr, trueExpr, falseExpr) {
                this.pos = pos;
                this.condExpr = condExpr;
                this.trueExpr = trueExpr;
                this.falseExpr = falseExpr;
                condExpr.setParent(this);
                trueExpr.setParent(this);
                falseExpr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr) },
            toString: function () { return Strings.format(
                '%s(%s?%s:%s)',
                this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format(
                    '(%s) ? (%s) : (%s)',
                    this.condExpr.asJS(depth), this.trueExpr.asJS(depth), this.falseExpr.asJS(depth));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitCond(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.If',
        'testing', {
            isIf: true,
        },
        'initializing', {
            initialize: function ($super, pos, condExpr, trueExpr, falseExpr) {
                this.pos = pos;
                this.condExpr = condExpr;
                // FIXME actually this could be done with OMeta
                this.trueExpr = trueExpr.isSequence || this.isUndefined(trueExpr) ?
                    trueExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [trueExpr]);
                this.falseExpr = falseExpr.isSequence || this.isUndefined(falseExpr) ?
                    falseExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [falseExpr]);
                condExpr.setParent(this);
                this.trueExpr.setParent(this);
                this.falseExpr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr) },
            toString: function () { return Strings.format(
                '%s(%s?%s:%s)',
                this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr) },
        },
        'conversion', {
            asJS: function (depth) {
                var str = Strings.format(
                    'if (%s) {%s}',
                    this.condExpr.asJS(depth), this.trueExpr.asJS(depth));
                if (!this.isUndefined(this.falseExpr))
                    str += ' else {' + this.falseExpr.asJS(depth) + '}';
                return str;
            },
        },
        'stepping', {
            firstStatement: function () {
                return this.condExpr.firstStatement();
            },
            nextStatement: function ($super, node) {
                return node === this.condExpr ? this.trueExpr : $super(this);
            },
            isComposite: function () { return true; },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitIf(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.While',
        'testing', {
            isWhile: true,
        },
        'initializing', {
            initialize: function($super, pos, condExpr, body) {
                this.pos = pos;
                this.condExpr = condExpr;
                this.body = body;
                condExpr.setParent(this);
                body.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.condExpr, this.body) },
            toString: function () { return Strings.format(
                '%s(%s?%s)',
                this.constructor.name, this.condExpr, this.body) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format(
                    'while (%s) {%s}',
                    this.condExpr.asJS(depth), this.body.asJS(depth));
            },
        },
        'stepping', {
            firstStatement: function () {
                return this.condExpr.firstStatement();
            },
            nextStatement: function ($super, node) {
                if (node === this.condExpr) {
                    return this.body;
                } else if (node === this.body) {
                    return this.condExpr;
                } else {
                    return $super(this);
                }
            },
            isComposite: function () {
                return true;
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitWhile(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.DoWhile',
        'testing', {
            isDoWhile: true,
        },
        'initializing', {
            initialize: function($super, pos, body, condExpr) {
                this.pos = pos;
                this.body = body;
                this.condExpr = condExpr;
                body.setParent(this);
                condExpr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.body, this.condExpr) },
            toString: function () { return Strings.format(
                '%s(%s while%s)',
                this.constructor.name, this.body, this.condExpr) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format(
                    'do {%s} while (%s);',
                    this.body.asJS(depth), this.condExpr.asJS(depth));
            },
        },
        'stepping', {
            firstStatement: function () {
                return this.body.firstStatement();
            },
            nextStatement: function ($super, node) {
                if (node === this.condExpr) {
                    return this.body;
                } else if (node === this.body) {
                    return this.condExpr;
                } else {
                    return $super(this);
                }
            },
            isComposite: function () {
                return true;
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitDoWhile(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.For',
        'testing', {
            isFor: true,
        },
        'initializing', {
            initialize: function($super, pos, init, condExpr, body, upd) {
                this.pos = pos;
                this.init = init;
                this.condExpr = condExpr;
                this.body = body;
                this.upd = upd;
                init.setParent(this);
                condExpr.setParent(this);
                body.setParent(this);
                upd.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.init, this.condExpr, this.body, this.upd) },
            toString: function () { return Strings.format(
                '%s(%s;%s;%s do %s)',
                this.constructor.name, this.init, this.condExpr, this.upd, this.body) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format(
                    'for (%s; %s; %s) {%s}',
                    this.init.asJS(depth), this.condExpr.asJS(depth), this.upd.asJS(depth), this.body.asJS(depth));
            },
        },
        'stepping', {
            firstStatement: function () {
                return this.init.firstStatement();
            },
            nextStatement: function ($super, node) {
                if (node === this.init || node === this.upd) {
                    return this.condExpr;
                } else if (node === this.condExpr) {
                    return this.body;
                } else if (node === this.body) {
                    return this.upd;
                } else {
                    return $super(this);
                }
            },
            isComposite: function () {
                return true;
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitFor(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ForIn',
        'testing', {
            isForIn: true,
        },
        'initializing', {
            initialize: function($super, pos, name, obj, body) {
                this.pos = pos;
                this.name = name;
                this.obj = obj;
                this.body = body;
                name.setParent(this);
                obj.setParent(this);
                body.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.name, this.obj, this.body) },
            toString: function () {
                return Strings.format(
                    '%s(%s in %s do %s)',
                    this.constructor.name, this.name, this.obj, this.body);
            },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format(
                    'for (%s in %s) {%s}',
                    this.name.asJS(depth), this.obj.asJS(depth), this.body.asJS(depth));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitForIn(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Set',
        'testing', {
            isSet: true,
        },
        'initializing', {
            initialize: function($super, pos, left, right) {
                this.pos = pos;
                this.left = left;
                this.right = right;
                left.setParent(this);
                right.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.left, this.right) },
            toString: function () { return Strings.format(
                '%s(%s = %s)',
                this.constructor.name, this.left, this.right) },
        },
        'conversion', {
            asJS: function (depth) { return this.left.asJS(depth) + ' = ' + this.right.asJS(depth) },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitSet(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ModifyingSet',
        'testing', {
            isModifyingSet: true,
        },
        'initializing', {
            initialize: function($super, pos, left, name, right) {
                this.pos = pos;
                this.left = left;
                this.name = name;
                this.right = right;
                left.setParent(this);
                right.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.left, '"' + this.name + '"', this.right) },
            toString: function () { return Strings.format(
                '%s(%s %s %s)',
                this.constructor.name, this.left, this.name, this.right) },
        },
        'conversion', {
            asJS: function (depth) { return this.left.asJS(depth) + ' ' + this.name + '= ' + this.right.asJS(depth) },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitModifyingSet(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.BinaryOp',
        'testing', {
            isBinaryOp: true,
        },
        'initializing', {
            initialize: function($super, pos, name, left, right) {
                this.pos = pos;
                this.name = name;
                this.left = left;
                this.right = right;
                left.setParent(this);
                right.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"' + this.name + '"', this.left, this.right) },
            toString: function () { return Strings.format(
                '%s(%s %s %s)',
                this.constructor.name, this.left, this.name, this.right) },
        },
        'conversion', {
            asJS: function (depth) { return '(' + this.left.asJS(depth) + ') ' + this.name + ' (' + this.right.asJS(depth) + ')' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitBinaryOp(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.UnaryOp',
        'testing', {
            isUnaryOp: true,
        },
        'initializing', {
            initialize: function($super, pos, name, expr) {
                this.pos = pos;
                this.name = name;
                this.expr = expr;
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr) },
            toString: function () { return Strings.format(
                '%s(%s%s)',
                this.constructor.name, this.name, this.expr) },
        },
        'conversion', {
            asJS: function (depth) { return '(' + this.name + this.expr.asJS(depth) + ')'},
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitUnaryOp(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.PreOp',
        'testing', {
            isPreOp: true,
        },
        'initializing', {
            initialize: function($super, pos, name, expr) {
                this.pos = pos;
                this.name = name;
                this.expr = expr;
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"' + this.name+'"', this.expr) },
            toString: function () { return Strings.format(
                '%s(%s%s)',
                this.constructor.name, this.name, this.expr) },
        },
        'conversion', {
            asJS: function (depth) { return '(' + this.name + this.expr.asJS(depth) + ')' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitPreOp(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.PostOp',
        'testing', {
            isPostOp: true,
        },
        'initializing', {
            initialize: function($super, pos, name, expr) {
                this.pos = pos;
                this.name = name;
                this.expr = expr;
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.expr) },
            toString: function () { return Strings.format(
                '%s(%s%s)',
                this.constructor.name, this.expr, this.name) },
        },
        'conversion', {
            asJS: function (depth) { return '(' + this.expr.asJS(depth) + this.name + ')'},
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitPostOp(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.This',
        'testing', {
            isThis: true,
        },
        'initializing', {
            initialize: function($super, pos) {
                this.pos = pos;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos) },
            toString: function () { return this.constructor.name },
        },
        'conversion', {
            asJS: function (depth) { return 'this' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitThis(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Variable',
        'testing', {
            isVariable: true,
        },
        'initializing', {
            initialize: function($super, pos, name) {
                this.pos = pos;
                this.name = name;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"'+this.name+'"') },
            toString: function () { return Strings.format(
                '%s(%s)',
                this.constructor.name, this.name) },
        },
        'conversion', {
            asJS: function (depth) { return this.name },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitVariable(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.GetSlot',
        'testing', {
            isGetSlot: true,
        },
        'initializing', {
            initialize: function($super, pos, slotName, obj) {
                this.pos = pos;
                this.slotName = slotName;
                this.obj = obj;
                slotName.setParent(this);
                obj.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.slotName, this.obj) },
            toString: function () { return Strings.format(
                '%s(%s[%s])',
                this.constructor.name, this.obj, this.slotName) },
        },
        'conversion', {
            asJS: function (depth) {
                var objJS = this.obj.asJS(depth);
                if (this.obj.isFunction) objJS = '(' + objJS + ')';
                return objJS + '[' + this.slotName.asJS(depth) + ']';
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitGetSlot(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Break',
        'testing', {
            isBreak: true,
        },
        'initializing', {
            initialize: function ($super, pos, label) {
                this.pos = pos;
                this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], '');
                this.label.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.label) },
        },
        'conversion', {
            asJS: function (depth) { return 'break' + this.label.asJS(); },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitBreak(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Debugger',
        'testing', {
            isDebugger: true,
        },
        'initializing', {
            initialize: function($super, pos) {
                this.pos = pos;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos) },
        },
        'conversion', {
            asJS: function (depth) { return 'debugger' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitDebugger(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Continue',
        'testing', {
            isContinue: true,
        },
        'initializing', {
            initialize: function ($super, pos, label) {
                this.pos = pos;
                this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], '');
                this.label.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.label) },
        },
        'conversion', {
            asJS: function (depth) { return 'continue' + this.label.asJS(); },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitContinue(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ArrayLiteral',
        'testing', {
            isArrayLiteral: true,
        },
        'initializing', {
            initialize: function($super, pos, elements) {
                this.pos = pos;
                this.elements = elements;
                elements.forEach(function(node) { node.setParent(this) }, this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.elements) },
            toString: function () { return Strings.format(
                '%s(%s)',
                this.constructor.name, this.elements.join(',')) },
        },
        'conversion', {
            asJS: function (depth) { return '[' + this.elements.invoke('asJS').join(',') + ']' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitArrayLiteral(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Return',
        'testing', {
            isReturn: true,
        },
        'initializing', {
            initialize: function($super, pos, expr) {
                this.pos = pos;
                this.expr = expr;
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.expr) },
            toString: function () { return Strings.format(
                '%s(%s)',
                this.constructor.name, this.expr) },
        },
        'conversion', {
            asJS: function (depth) { return 'return ' + this.expr.asJS(depth) },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitReturn(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.With',
        'testing', {
            isWith: true,
        },
        'initializing', {
            initialize: function($super, pos, obj, body) {
                this.pos = pos;
                this.obj = obj;
                this.body = body;
                obj.setParent(this);
                body.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.obj, this.body) },
            toString: function () { return Strings.format(
                '%s(%s %s)',
                this.constructor.name, this.obj, this.body) },
        },
        'conversion', {
            asJS: function (depth) { return 'with (' + this.obj.asJS(depth) + ') {' + this.body.asJS(depth) + '}' },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitWith(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Send',
        'testing', {
            isSend: true,
        },
        'initializing', {
            initialize: function($super, pos, property, recv, args) {
                this.pos = pos;
                this.property = property;
                this.recv = recv;
                this.args = args;
                args.forEach(function(node) { node.setParent(this) }, this);
                property.setParent(this);
                recv.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () {
                return this.printConstructorCall(this.pos, this.property, this.recv, this.args)
            },
            toString: function () {
                return Strings.format('%s(%s[%s](%s))',
                    this.constructor.name, this.recv, this.property, this.args.join(','))
            },
        },
        'conversion', {
            asJS: function (depth) {
                var recvJS = this.recv.asJS(depth);
                if (this.recv.isFunction) recvJS = '(' + recvJS + ')';
                return Strings.format(
                    '%s[%s](%s)',
                    recvJS, this.property.asJS(depth), this.args.invoke('asJS').join(','));
            },
        },
        'accessing', {
            getName: function () { return this.property },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitSend(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Call',
        'testing', {
            isCall: true,
        },
        'initializing', {
            initialize: function($super, pos, fn, args) {
                this.pos = pos;
                this.fn = fn;
                this.args = args;
                args.forEach(function(node) { node.setParent(this) }, this);
                fn.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.fn, this.args) },
            toString: function () { return Strings.format(
                '%s(%s(%s))',
                this.constructor.name, this.fn, this.args.join(',')) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('%s(%s)',
                    this.fn.asJS(depth), this.args.invoke('asJS').join(','));
            },
        },
        'accessing', {
            getName: function () { return this.fn.name },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitCall(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.New',
        'testing', {
            isNew: true,
        },
        'initializing', {
            initialize: function($super, pos, clsExpr) {
                this.pos = pos;
                this.clsExpr = clsExpr;
                clsExpr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.clsExpr) },
            toString: function () { return Strings.format(
                '%s(%s)',
                this.constructor.name, this.clsExpr) },
        },
        'conversion', {
            asJS: function (depth) {
                return 'new ' + this.clsExpr.asJS(depth);
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitNew(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.VarDeclaration',
        'testing', {
            isVarDeclaration: true,
        },
        'initializing', {
            initialize: function($super, pos, name, val) {
                this.pos = pos;
                this.name = name;
                this.val = val;
                val.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.val) },
            toString: function () { return Strings.format(
                '%s(%s = %s)',
                this.constructor.name, this.name, this.val) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('var %s = %s', this.name, this.val.asJS(depth));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitVarDeclaration(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Throw',
        'testing', {
            isThrow: true,
        },
        'initializing', {
            initialize: function($super, pos, expr) {
                this.pos = pos;
                this.expr = expr;
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.expr) },
            toString: function () {
                return Strings.format(
                    '%s(%s)',
                    this.constructor.name, this.expr)
            },
        },
        'conversion', {
            asJS: function (depth) { return 'throw ' + this.expr.asJS(depth) },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitThrow(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.TryCatchFinally',
        'testing', {
            isTryCatchFinally: true,
        },
        'initializing', {
            initialize: function($super, pos, trySeq, err, catchSeq, finallySeq) {
                this.pos = pos;
                this.trySeq = trySeq;
                this.err = err;
                this.catchSeq = catchSeq;
                this.finallySeq = finallySeq;
                trySeq.setParent(this);
                err.setParent(this);
                catchSeq.setParent(this);
                finallySeq.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.trySeq, '"'+this.err.name+'"', this.catchSeq, this.finallySeq) },
            toString: function () {
                return Strings.format(
                    '%s(%s %s %s)',
                    this.constructor.name, this.trySeq, this.catchSeq, this.finallySeq)
            },
        },
        'conversion', {
            asJS: function (depth) {
                var baseIndent = this.indent(depth-1),
                    indent = this.indent(depth),
                    str = 'try {\n' + indent + this.trySeq.asJS(depth) + '\n' + baseIndent + '}';
                if (!this.isUndefined(this.catchSeq))
                    str += ' catch(' + this.err.name + ') {\n' +
                        indent + this.catchSeq.asJS(depth) + '\n' + baseIndent + '}';
                if (!this.isUndefined(this.finallySeq))
                    str += ' finally {\n' + indent + this.finallySeq.asJS(depth) + '\n' + baseIndent + '}';
                return str;
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitTryCatchFinally(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Function',
        'testing', {
            isFunction: true,
        },
        'initializing', {
            initialize: function($super, pos, body, args) {
                this.pos = pos;
                this.body = body;
                this.args = args;
                args.forEach(function(node) { node.setParent(this) }, this);
                body.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.body, this.args.collect(function(ea) { return '"' + ea.name + '"' })) },
            toString: function () {
                return Strings.format(
                    '%s(function %s(%s) %s)',
                    this.constructor.name, this.name(), this.argNames().join(','), this.body)
            },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('function%s(%s) {\n%s\n}',
                    this.name() ? ' ' + this.name() : '', this.argNames().join(','),
                    this.indent(depth+1) + this.body.asJS(depth+1));
            },
        },
        'accessing', {
            name: function () {
                if (this._parent && this._parent.isVarDeclaration) {
                    return this._parent.name;
                }
                return undefined;
            },
            parentFunction: function () { return this },
            argNames: function () { return this.args.collect(function(a){ return a.name }); },
            statements: function () { return this.body.children },
        },
        'stepping', {
            firstStatement: function () { return this.body.firstStatement(); },
            nextStatement: function (node) { return null; },
            isComposite: function () { return true; },
        },
        'evaluation', {
            eval: function () {
                return new Function(this.argNames().join(","), this.body.asJS());
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitFunction(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ObjectLiteral',
        'testing', {
            isObjectLiteral: true,
        },
        'initializing', {
            initialize: function($super, pos, properties) {
                this.pos = pos;
                this.properties = properties;
                properties.forEach(function(node) { node.setParent(this) }, this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.properties) },
            toString: function () {
                return Strings.format(
                    '%s({%s})',
                    this.constructor.name, this.properties.join(','))
            },
        },
        'conversion', {
            asJS: function (depth) {
                return '{' + this.properties.invoke('asJS').join(',') + '}';
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitObjectLiteral(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ObjProperty',
        'testing', {
            isObjProperty: true,
        },
        'initializing', {
            initialize: function($super, pos, name, property) {
                this.pos = pos;
                this.name = name;
                this.property = property;
                property.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.property) },
            toString: function () {
                return Strings.format(
                    '%s(%s: %s)',
                    this.constructor.name, this.name, this.property) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('"%s": %s', this.name, this.property.asJS(depth));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitObjProperty(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ObjPropertyGet',
        'testing', {
            isObjPropertyGet: true,
        },
        'initializing', {
            initialize: function($super, pos, name, body) {
                this.pos = pos;
                this.name = name;
                this.body = body;
                body.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.body) },
            toString: function () {
                return Strings.format(
                    '%s(%s() { %s })',
                    this.constructor.name, this.name, this.body) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('get "%s"() { %s }', this.name, this.body.asJS(depth));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitObjPropertyGet(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.ObjPropertySet',
        'testing', {
            isObjPropertySet: true,
        },
        'initializing', {
            initialize: function($super, pos, name, body, arg) {
                this.pos = pos;
                this.name = name;
                this.body = body;
                this.arg = arg;
                body.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.body, this.arg) },
            toString: function () {
                return Strings.format(
                    '%s(%s(%s) { %s })',
                    this.constructor.name, this.name, this.arg, this.body) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('set "%s"(%s) { %s }', this.name, this.arg, this.body.asJS(depth));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitObjPropertySet(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Switch',
        'testing', {
            isSwitch: true,
        },
        'initializing', {
            initialize: function($super, pos, expr, cases) {
                this.pos = pos;
                this.expr = expr;
                this.cases = cases;
                cases.forEach(function(node) { node.setParent(this) }, this);
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.expr, this.cases) },
            toString: function () { return Strings.format('%s(%s %s)',
                this.constructor.name, this.expr, this.cases.join('\n')) },
        },
        'conversion', {
            asJS: function (depth) {
                return Strings.format('switch (%s) {%s}',
                    this.expr.asJS(depth), this.cases.invoke('asJS').join('\n'));
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitSwitch(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Case',
        'testing', {
            isCase: true,
        },
        'initializing', {
            initialize: function($super, pos, condExpr, thenExpr) {
                this.pos = pos;
                this.condExpr = condExpr;
                this.thenExpr = thenExpr;
                condExpr.setParent(this);
                thenExpr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.condExpr, this.thenExpr) },
            toString: function () {
                return Strings.format(
                    '%s(%s: %s)',
                    this.constructor.name, this.condExpr, this.thenExpr) },
        },
        'conversion', {
            asJS: function (depth) {
                return 'case ' + this.condExpr.asJS(depth) + ': ' + this.thenExpr.asJS(depth);
            },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitCase(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Default',
        'testing', {
            isDefault: true,
        },
        'initializing', {
            initialize: function($super, pos, defaultExpr) {
                this.pos = pos;
                this.defaultExpr = defaultExpr;
                defaultExpr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.defaultExpr) },
            toString: function () { return Strings.format(
                '%s(default: %s)',
                this.constructor.name,  this.defaultExpr) },
        },
        'conversion', {
            asJS: function (depth) { return 'default: ' + this.defaultExpr.asJS(depth) },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitDefault(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Regex',
        'testing', {
            isRegex: true,
        },
        'initializing', {
            initialize: function($super, pos, exprString, flags) {
                this.pos = pos;
                this.exprString = exprString;
                this.flags = flags;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, this.exprString, this.flags) },
            toString: function () { return Strings.format('(/%s/%s)', this.exprString, this.flags) },
        },
        'conversion', {
            asJS: function (depth) { return '/' + this.exprString + '/' + this.flags},
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitRegex(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.Label',
        'testing', {
            isLabel: true,
        },
        'initializing', {
            initialize: function($super, pos, name) {
                this.pos = pos;
                this.name = name;

            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"' + this.name + '"') },
            toString: function () { return Strings.format('%s(%s)', this.constructor.name, this.name) },
        },
        'conversion', {
            asJS: function (depth) { return this.name; },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitLabel(this);
            }
        });

    users.timfelgentreff.jsinterpreter.Node.subclass('users.timfelgentreff.jsinterpreter.LabelDeclaration',
        'testing', {
            isLabelDeclaration: true,
        },
        'initializing', {
            initialize: function($super, pos, name, expr) {
                this.pos = pos;
                this.name = name;
                this.expr = expr;
                expr.setParent(this);
            },
        },
        'debugging', {
            printConstruction: function () { return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr) },
            toString: function () { return Strings.format('%s(%s is %s)', this.constructor.name, this.name, this.expr) },
        },
        'conversion', {
            asJS: function (depth) { return this.name + ': ' + this.expr.asJS(depth) },
        },
        'visiting', {
            accept: function(visitor) {
                return visitor.visitLabelDeclaration(this);
            }
        });

    Object.subclass('users.timfelgentreff.jsinterpreter.Visitor',
        'visiting', {
            visit: function(node) { return node.accept(this) },
            visitSequence: function(node) {},
            visitNumber: function(node) {},
            visitString: function(node) {},
            visitCond: function(node) {},
            visitIf: function(node) {},
            visitWhile: function(node) {},
            visitDoWhile: function(node) {},
            visitFor: function(node) {},
            visitForIn: function(node) {},
            visitSet: function(node) {},
            visitModifyingSet: function(node) {},
            visitBinaryOp: function(node) {},
            visitUnaryOp: function(node) {},
            visitPreOp: function(node) {},
            visitPostOp: function(node) {},
            visitThis: function(node) {},
            visitVariable: function(node) {},
            visitGetSlot: function(node) {},
            visitBreak: function(node) {},
            visitDebugger: function(node) {},
            visitContinue: function(node) {},
            visitArrayLiteral: function(node) {},
            visitReturn: function(node) {},
            visitWith: function(node) {},
            visitSend: function(node) {},
            visitCall: function(node) {},
            visitNew: function(node) {},
            visitVarDeclaration: function(node) {},
            visitThrow: function(node) {},
            visitTryCatchFinally: function(node) {},
            visitFunction: function(node) {},
            visitObjectLiteral: function(node) {},
            visitObjProperty: function(node) {},
            visitObjPropertyGet: function(node) {},
            visitObjPropertySet: function(node) {},
            visitSwitch: function(node) {},
            visitCase: function(node) {},
            visitDefault: function(node) {},
            visitRegex: function(node) {},
            visitLabel: function(node) {},
            visitLabelDeclaration: function(node) {},

        })
});













module('users.timfelgentreff.jsinterpreter.generated.Translator').requires('ometa.lively').toRun(function() {
    JSTranslator=objectThatDelegatesTo(Parser,{
        "trans":function(){var $elf=this,t,ans;return (function(){this._form((function(){return (function(){t=this._apply("anything");return ans=this._applyWithArgs("apply",t)}).call(this)}));return ans}).call(this)},
        "begin":function(){var $elf=this,pos,children;return (function(){pos=this._apply("anything");children=this._many((function(){return this._apply("trans")}));this._apply("end");return new users.timfelgentreff.jsinterpreter.Sequence(pos,children)}).call(this)},
        "number":function(){var $elf=this,pos,value;return (function(){pos=this._apply("anything");value=this._apply("anything");return new users.timfelgentreff.jsinterpreter.Number(pos,value)}).call(this)},
        "string":function(){var $elf=this,pos,value;return (function(){pos=this._apply("anything");value=this._apply("anything");return new users.timfelgentreff.jsinterpreter.String(pos,value)}).call(this)},
        "condExpr":function(){var $elf=this,pos,condExpr,trueExpr,falseExpr;return (function(){pos=this._apply("anything");condExpr=this._apply("trans");trueExpr=this._apply("trans");falseExpr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.Cond(pos,condExpr,trueExpr,falseExpr)}).call(this)},
        "if":function(){var $elf=this,pos,condExpr,trueExpr,falseExpr;return (function(){pos=this._apply("anything");condExpr=this._apply("trans");trueExpr=this._apply("trans");falseExpr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.If(pos,condExpr,trueExpr,falseExpr)}).call(this)},
        "while":function(){var $elf=this,pos,condExpr,body;return (function(){pos=this._apply("anything");condExpr=this._apply("trans");body=this._apply("trans");return new users.timfelgentreff.jsinterpreter.While(pos,condExpr,body)}).call(this)},
        "doWhile":function(){var $elf=this,pos,body,condExpr;return (function(){pos=this._apply("anything");body=this._apply("trans");condExpr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.DoWhile(pos,body,condExpr)}).call(this)},
        "for":function(){var $elf=this,pos,init,condExpr,body,upd;return (function(){pos=this._apply("anything");init=this._apply("trans");condExpr=this._apply("trans");body=this._apply("trans");upd=this._apply("trans");return new users.timfelgentreff.jsinterpreter.For(pos,init,condExpr,body,upd)}).call(this)},
        "forIn":function(){var $elf=this,pos,name,obj,body;return (function(){pos=this._apply("anything");name=this._apply("trans");obj=this._apply("trans");body=this._apply("trans");return new users.timfelgentreff.jsinterpreter.ForIn(pos,name,obj,body)}).call(this)},
        "set":function(){var $elf=this,pos,left,right;return (function(){pos=this._apply("anything");left=this._apply("trans");right=this._apply("trans");return new users.timfelgentreff.jsinterpreter.Set(pos,left,right)}).call(this)},
        "mset":function(){var $elf=this,pos,left,name,right;return (function(){pos=this._apply("anything");left=this._apply("trans");name=this._apply("anything");right=this._apply("trans");return new users.timfelgentreff.jsinterpreter.ModifyingSet(pos,left,name,right)}).call(this)},
        "binop":function(){var $elf=this,pos,name,left,right;return (function(){pos=this._apply("anything");name=this._apply("anything");left=this._apply("trans");right=this._apply("trans");return new users.timfelgentreff.jsinterpreter.BinaryOp(pos,name,left,right)}).call(this)},
        "unop":function(){var $elf=this,pos,name,expr;return (function(){pos=this._apply("anything");name=this._apply("anything");expr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.UnaryOp(pos,name,expr)}).call(this)},
        "preop":function(){var $elf=this,pos,name,expr;return (function(){pos=this._apply("anything");name=this._apply("anything");expr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.PreOp(pos,name,expr)}).call(this)},
        "postop":function(){var $elf=this,pos,name,expr;return (function(){pos=this._apply("anything");name=this._apply("anything");expr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.PostOp(pos,name,expr)}).call(this)},
        "this":function(){var $elf=this,pos;return (function(){pos=this._apply("anything");return new users.timfelgentreff.jsinterpreter.This(pos)}).call(this)},
        "get":function(){var $elf=this,pos,name;return (function(){pos=this._apply("anything");name=this._apply("anything");return new users.timfelgentreff.jsinterpreter.Variable(pos,name)}).call(this)},
        "getp":function(){var $elf=this,pos,slotName,obj;return (function(){pos=this._apply("anything");slotName=this._apply("trans");obj=this._apply("trans");return new users.timfelgentreff.jsinterpreter.GetSlot(pos,slotName,obj)}).call(this)},
        "break":function(){var $elf=this,pos;return (function(){pos=this._apply("anything");return new users.timfelgentreff.jsinterpreter.Break(pos)}).call(this)},
        "debugger":function(){var $elf=this,pos;return (function(){pos=this._apply("anything");return new users.timfelgentreff.jsinterpreter.Debugger(pos)}).call(this)},
        "continue":function(){var $elf=this,pos;return (function(){pos=this._apply("anything");return new users.timfelgentreff.jsinterpreter.Continue(pos)}).call(this)},
        "arr":function(){var $elf=this,pos,elements;return (function(){pos=this._apply("anything");elements=this._many((function(){return this._apply("trans")}));return new users.timfelgentreff.jsinterpreter.ArrayLiteral(pos,elements)}).call(this)},
        "return":function(){var $elf=this,pos,expr;return (function(){pos=this._apply("anything");expr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.Return(pos,expr)}).call(this)},
        "with":function(){var $elf=this,pos,obj,body;return (function(){pos=this._apply("anything");obj=this._apply("trans");body=this._apply("trans");return new users.timfelgentreff.jsinterpreter.With(pos,obj,body)}).call(this)},
        "send":function(){var $elf=this,pos,property,recv,args;return (function(){pos=this._apply("anything");property=this._apply("trans");recv=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return new users.timfelgentreff.jsinterpreter.Send(pos,property,recv,args)}).call(this)},
        "call":function(){var $elf=this,pos,fn,args;return (function(){pos=this._apply("anything");fn=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return new users.timfelgentreff.jsinterpreter.Call(pos,fn,args)}).call(this)},
        "new":function(){var $elf=this,pos,clsExpr;return (function(){pos=this._apply("anything");clsExpr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.New(pos,clsExpr)}).call(this)},
        "var":function(){var $elf=this,pos,name,val;return (function(){pos=this._apply("anything");name=this._apply("anything");val=this._apply("trans");return new users.timfelgentreff.jsinterpreter.VarDeclaration(pos,name,val)}).call(this)},
        "throw":function(){var $elf=this,pos,expr;return (function(){pos=this._apply("anything");expr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.Throw(pos,expr)}).call(this)},
        "try":function(){var $elf=this,pos,trySeq,err,catchSeq,finallySeq;return (function(){pos=this._apply("anything");trySeq=this._apply("trans");err=this._apply("trans");catchSeq=this._apply("trans");finallySeq=this._apply("trans");return new users.timfelgentreff.jsinterpreter.TryCatchFinally(pos,trySeq,err,catchSeq,finallySeq)}).call(this)},
        "func":function(){var $elf=this,pos,body,args;return (function(){pos=this._apply("anything");body=this._apply("trans");args=this._many((function(){return this._apply("trans")}));return new users.timfelgentreff.jsinterpreter.Function(pos,body,args)}).call(this)},
        "json":function(){var $elf=this,pos,properties;return (function(){pos=this._apply("anything");properties=this._many((function(){return this._apply("trans")}));return new users.timfelgentreff.jsinterpreter.ObjectLiteral(pos,properties)}).call(this)},
        "binding":function(){var $elf=this,pos,name,property;return (function(){pos=this._apply("anything");name=this._apply("anything");property=this._apply("trans");return new users.timfelgentreff.jsinterpreter.ObjProperty(pos,name,property)}).call(this)},
        "jsonGetter":function(){var $elf=this,pos,name,body;return (function(){pos=this._apply("anything");name=this._apply("anything");body=this._apply("trans");return new users.timfelgentreff.jsinterpreter.ObjPropertyGet(pos,name,body)}).call(this)},
        "jsonSetter":function(){var $elf=this,pos,name,body,arg;return (function(){pos=this._apply("anything");name=this._apply("anything");body=this._apply("trans");arg=this._apply("anything");return new users.timfelgentreff.jsinterpreter.ObjPropertySet(pos,name,body,arg)}).call(this)},
        "switch":function(){var $elf=this,pos,expr,cases;return (function(){pos=this._apply("anything");expr=this._apply("trans");cases=this._many((function(){return this._apply("trans")}));return new users.timfelgentreff.jsinterpreter.Switch(pos,expr,cases)}).call(this)},
        "case":function(){var $elf=this,pos,condExpr,thenExpr;return (function(){pos=this._apply("anything");condExpr=this._apply("trans");thenExpr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.Case(pos,condExpr,thenExpr)}).call(this)},
        "default":function(){var $elf=this,pos,defaultExpr;return (function(){pos=this._apply("anything");defaultExpr=this._apply("trans");return new users.timfelgentreff.jsinterpreter.Default(pos,defaultExpr)}).call(this)},
        "regex":function(){var $elf=this,pos,exprString,flags;return (function(){pos=this._apply("anything");exprString=this._apply("anything");flags=this._apply("anything");return new users.timfelgentreff.jsinterpreter.Regex(pos,exprString,flags)}).call(this)}})
});















module('users.timfelgentreff.jsinterpreter.LivelyJSParser').requires('ometa.lively').toRun(function() {
    LivelyJSParser=objectThatDelegatesTo(Parser,{
        "whereAreYou":function(){var $elf=this;return (function (){{var charsBefore=(120);var charsAfter=(120);var src=this["_originalInput"]["arr"];var startIndex=Math.max((0),(this.pos() - charsBefore));var stopIndex=Math.min(src["length"],(this.pos() + charsAfter));var msg=((src.substring(startIndex,this.pos()) + "<--I am here-->") + src.substring(this.pos(),stopIndex))};(msg+=("\nRules: " + this["_ruleStack"]));(msg+=("\nStack: " + this["stack"]));alert(msg);return true}).call(this)},
        "fromTo":function(){var $elf=this,x,y;return (function(){x=this._apply("anything");y=this._apply("anything");this._applyWithArgs("seq",x);this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("seq",y)}));return this._apply("char")}).call(this)}));return this._applyWithArgs("seq",y)}).call(this)},
        "fromToWithout":function(){var $elf=this,x,y;return (function(){x=this._apply("anything");y=this._apply("anything");this._applyWithArgs("seq",x);return this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("seq",y)}));return this._apply("char")}).call(this)}))}).call(this)},
        "space":function(){var $elf=this;return this._or((function(){return Parser._superApplyWithArgs(this,'space')}),(function(){return this._applyWithArgs("fromToWithout","//","\n")}),(function(){return this._applyWithArgs("fromTo","//","end")}),(function(){return this._applyWithArgs("fromTo","/*","*/")}))},
        "nameFirst":function(){var $elf=this;return this._or((function(){return this._apply("letter")}),(function(){return (function(){switch(this._apply('anything')){case "$":return "$";case "_":return "_";default: throw fail}}).call(this)}))},
        "nameRest":function(){var $elf=this;return this._or((function(){return this._apply("nameFirst")}),(function(){return this._apply("digit")}))},
        "iName":function(){var $elf=this,r;return (function(){r=this._applyWithArgs("firstAndRest","nameFirst","nameRest");return r.join("")}).call(this)},
        "isKeyword":function(){var $elf=this,x;return (function(){x=this._apply("anything");return this._pred(LivelyJSParser._isKeyword(x))}).call(this)},
        "name":function(){var $elf=this,p1,n,p2;return (function(){p1=this._apply("pos");n=this._apply("iName");this._not((function(){return this._applyWithArgs("isKeyword",n)}));p2=this._apply("pos");return ["name",[p1,p2],n]}).call(this)},
        "keyword":function(){var $elf=this,p1,k,p2;return (function(){p1=this._apply("pos");k=this._apply("iName");this._applyWithArgs("isKeyword",k);p2=this._apply("pos");return [k,[p1,p2],k]}).call(this)},
        "hexDigit":function(){var $elf=this,x,v;return (function(){x=this._apply("char");v=this["hexDigits"].indexOf(x.toLowerCase());this._pred((v >= (0)));return v}).call(this)},
        "hexLit":function(){var $elf=this,n,d;return this._or((function(){return (function(){n=this._apply("hexLit");d=this._apply("hexDigit");return ((n * (16)) + d)}).call(this)}),(function(){return this._apply("hexDigit")}))},
        "number":function(){var $elf=this,p1,n,p2,fs,p2,ws,fs,sig,exp,p2;return (function(){p1=this._apply("pos");return this._or((function(){return (function(){switch(this._apply('anything')){case "0":return (function(){this._applyWithArgs("exactly","x");"0x";n=this._apply("hexLit");p2=this._apply("pos");return ["number",[p1,p2],n]}).call(this);case ".":return (function(){fs=this._many1((function(){return this._apply("digit")}));p2=this._apply("pos");return ["number",[p1,p2],parseFloat(("." + fs.join("")))]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){ws=this._many1((function(){return this._apply("digit")}));fs=this._or((function(){return (function(){switch(this._apply('anything')){case ".":return this._many1((function(){return this._apply("digit")}));default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return []}).call(this)}));exp=this._or((function(){return (function(){switch(this._apply('anything')){case "e":return (function(){sig=this._or((function(){return (function(){switch(this._apply('anything')){case "+":return "+";case "-":return "-";default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return ""}).call(this)}));return this._many1((function(){return this._apply("digit")}))}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){this._apply("empty");return []}).call(this)}));p2=this._apply("pos");return ["number",[p1,p2],parseFloat((((((ws.join("") + ".") + fs.join("")) + "e") + sig) + exp.join("")))]}).call(this)}))}).call(this)},
        "escapeChar":function(){var $elf=this,c;return (function(){this._applyWithArgs("exactly","\\");c=this._apply("char");return ometaUnescape(("\\" + c))}).call(this)},
        "str":function(){var $elf=this,p1,cs,p2,cs,p2,cs,p2,n,p2;return (function(){p1=this._apply("pos");return this._or((function(){return (function(){switch(this._apply('anything')){case "\"":return this._or((function(){return (function(){switch(this._apply('anything')){case "\"":return (function(){this._applyWithArgs("exactly","\"");"\"\"\"";cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return (function(){this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");return "\"\"\""}).call(this)}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");this._applyWithArgs("exactly","\"");"\"\"\"";p2=this._apply("pos");return ["string",[p1,p2],cs.join("")]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\"")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\"");p2=this._apply("pos");return ["string",[p1,p2],cs.join("")]}).call(this)}));case "\'":return (function(){cs=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\'")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("exactly","\'");p2=this._apply("pos");return ["string",[p1,p2],cs.join("")]}).call(this);default: throw fail}}).call(this)}),(function(){return (function(){(function(){switch(this._apply('anything')){case "#":return "#";case "`":return "`";default: throw fail}}).call(this);n=this._apply("iName");p2=this._apply("pos");return ["string",[p1,p2],n]}).call(this)}))}).call(this)},
        "special":function(){var $elf=this,p1,s,p2;return (function(){p1=this._apply("pos");s=(function(){switch(this._apply('anything')){case "(":return "(";case ")":return ")";case "{":return "{";case "}":return "}";case "[":return "[";case "]":return "]";case ",":return ",";case ";":return ";";case "?":return "?";case ":":return ":";case "!":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "!==";default: throw fail}}).call(this)}),(function(){return "!="}));default: throw fail}}).call(this)}),(function(){return "!"}));case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "===";default: throw fail}}).call(this)}),(function(){return "=="}));default: throw fail}}).call(this)}),(function(){return "="}));case ">":return this._or((function(){return (function(){switch(this._apply('anything')){case ">":return this._or((function(){return (function(){switch(this._apply('anything')){case ">":return ">>>";case "=":return ">>=";default: throw fail}}).call(this)}),(function(){return ">>"}));case "=":return ">=";default: throw fail}}).call(this)}),(function(){return ">"}));case "<":return this._or((function(){return (function(){switch(this._apply('anything')){case "<":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "<<=";default: throw fail}}).call(this)}),(function(){return "<<"}));case "=":return "<=";default: throw fail}}).call(this)}),(function(){return "<"}));case "+":return this._or((function(){return (function(){switch(this._apply('anything')){case "+":return "++";case "=":return "+=";default: throw fail}}).call(this)}),(function(){return "+"}));case "-":return this._or((function(){return (function(){switch(this._apply('anything')){case "-":return "--";case "=":return "-=";default: throw fail}}).call(this)}),(function(){return "-"}));case "*":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "*=";default: throw fail}}).call(this)}),(function(){return "*"}));case "~":return "~";case "/":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "/=";default: throw fail}}).call(this)}),(function(){return "/"}));case "%":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "%=";default: throw fail}}).call(this)}),(function(){return "%"}));case "&":return this._or((function(){return (function(){switch(this._apply('anything')){case "&":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "&&=";default: throw fail}}).call(this)}),(function(){return "&&"}));default: throw fail}}).call(this)}),(function(){return "&"}));case "|":return this._or((function(){return (function(){switch(this._apply('anything')){case "|":return this._or((function(){return (function(){switch(this._apply('anything')){case "=":return "||=";default: throw fail}}).call(this)}),(function(){return "||"}));default: throw fail}}).call(this)}),(function(){return "|"}));case ".":return ".";case "^":return "^";default: throw fail}}).call(this);p2=this._apply("pos");return [s,[p1,p2],s]}).call(this)},
        "tok":function(){var $elf=this;return (function(){this._apply("spaces");return this._or((function(){return this._apply("name")}),(function(){return this._apply("keyword")}),(function(){return this._apply("number")}),(function(){return this._apply("str")}),(function(){return this._apply("special")}))}).call(this)},
        "toks":function(){var $elf=this,ts;return (function(){ts=this._many((function(){return this._apply("token")}));this._apply("spaces");this._apply("end");return ts}).call(this)},
        "token":function(){var $elf=this,tt,t;return (function(){tt=this._apply("anything");t=this._apply("tok");this._pred((t[(0)] == tt));return t[(2)]}).call(this)},
        "spacesNoNl":function(){var $elf=this;return this._many((function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","\n")}));return this._apply("space")}).call(this)}))},
        "expr":function(){var $elf=this,p1,f,s,p2;return this._or((function(){return (function(){p1=this._apply("pos");f=this._apply("exprPart");this._applyWithArgs("token",",");s=this._apply("expr");p2=this._apply("pos");return ["begin",[p1,p2],f,s]}).call(this)}),(function(){return this._apply("exprPart")}))},
        "exprPart":function(){var $elf=this,p1,e,t,f,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2,rhs,p2;return (function(){p1=this._apply("pos");e=this._apply("ternaryExpr");return this._or((function(){return (function(){this._applyWithArgs("token","?");t=this._apply("exprPart");this._applyWithArgs("token",":");f=this._apply("exprPart");p2=this._apply("pos");return ["condExpr",[p1,p2],e,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["set",[p1,p2],e,rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","+=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"+",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","-=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"-",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","*=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"*",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","/=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"/",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","%=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"%",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","&=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"&",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","&&=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"&&",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","|=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"|",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","||=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"||",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","^=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"^",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",">>=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,">>",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","<<=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,"<<",rhs]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",">>>=");rhs=this._apply("exprPart");p2=this._apply("pos");return ["mset",[p1,p2],e,">>>",rhs]}).call(this)}),(function(){return (function(){this._apply("empty");return e}).call(this)}))}).call(this)},
        "ternaryExpr":function(){var $elf=this,p1,e,t,f,p2;return (function(){p1=this._apply("pos");e=this._apply("orExpr");return this._or((function(){return (function(){this._applyWithArgs("token","?");t=this._apply("orExpr");this._applyWithArgs("token",":");f=this._apply("orExpr");p2=this._apply("pos");return ["condExpr",[p1,p2],e,t,f]}).call(this)}),(function(){return (function(){this._apply("empty");return e}).call(this)}))}).call(this)},
        "orExpr":function(){var $elf=this,p1,x,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("orExpr");this._applyWithArgs("token","||");y=this._apply("andExpr");p2=this._apply("pos");return ["binop",[p1,p2],"||",x,y]}).call(this)}),(function(){return this._apply("andExpr")}))},
        "andExpr":function(){var $elf=this,p1,x,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("andExpr");this._applyWithArgs("token","&&");y=this._apply("bitOrExpr");p2=this._apply("pos");return ["binop",[p1,p2],"&&",x,y]}).call(this)}),(function(){return this._apply("bitOrExpr")}))},
        "bitOrExpr":function(){var $elf=this,p1,x,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("bitXorExpr");this._applyWithArgs("token","|");y=this._apply("bitOrExpr");p2=this._apply("pos");return ["binop",[p1,p2],"|",x,y]}).call(this)}),(function(){return this._apply("bitXorExpr")}))},
        "bitXorExpr":function(){var $elf=this,p1,x,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("bitAndExpr");this._applyWithArgs("token","^");y=this._apply("bitXorExpr");p2=this._apply("pos");return ["binop",[p1,p2],"^",x,y]}).call(this)}),(function(){return this._apply("bitAndExpr")}))},
        "bitAndExpr":function(){var $elf=this,p1,x,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("eqExpr");this._applyWithArgs("token","&");y=this._apply("bitAndExpr");p2=this._apply("pos");return ["binop",[p1,p2],"&",x,y]}).call(this)}),(function(){return this._apply("eqExpr")}))},
        "eqExpr":function(){var $elf=this,p1,x,op,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("eqExpr");op=this._or((function(){return this._applyWithArgs("token","==")}),(function(){return this._applyWithArgs("token","!=")}),(function(){return this._applyWithArgs("token","===")}),(function(){return this._applyWithArgs("token","!==")}));y=this._apply("relExpr");p2=this._apply("pos");return ["binop",[p1,p2],op,x,y]}).call(this)}),(function(){return this._apply("relExpr")}))},
        "relExpr":function(){var $elf=this,p1,x,op,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("relExpr");op=this._or((function(){return this._applyWithArgs("token",">")}),(function(){return this._applyWithArgs("token",">=")}),(function(){return this._applyWithArgs("token","<")}),(function(){return this._applyWithArgs("token","<=")}),(function(){return this._applyWithArgs("token","instanceof")}),(function(){return this._applyWithArgs("token","in")}));y=this._apply("shiftExpr");p2=this._apply("pos");return ["binop",[p1,p2],op,x,y]}).call(this)}),(function(){return this._apply("shiftExpr")}))},
        "shiftExpr":function(){var $elf=this,p1,x,op,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("shiftExpr");op=this._or((function(){return this._applyWithArgs("token",">>")}),(function(){return this._applyWithArgs("token","<<")}),(function(){return this._applyWithArgs("token",">>>")}));y=this._apply("addExpr");p2=this._apply("pos");return ["binop",[p1,p2],op,x,y]}).call(this)}),(function(){return this._apply("addExpr")}))},
        "addExpr":function(){var $elf=this,p1,x,op,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("addExpr");op=this._or((function(){return this._applyWithArgs("token","+")}),(function(){return this._applyWithArgs("token","-")}));y=this._apply("mulExpr");p2=this._apply("pos");return ["binop",[p1,p2],op,x,y]}).call(this)}),(function(){return this._apply("mulExpr")}))},
        "mulExpr":function(){var $elf=this,p1,x,op,y,p2;return this._or((function(){return (function(){p1=this._apply("pos");x=this._apply("mulExpr");op=this._or((function(){return this._applyWithArgs("token","*")}),(function(){return this._applyWithArgs("token","/")}),(function(){return this._applyWithArgs("token","%")}));y=this._apply("unary");p2=this._apply("pos");return ["binop",[p1,p2],op,x,y]}).call(this)}),(function(){return this._apply("unary")}))},
        "unary":function(){var $elf=this,p1,p,p2,p,p2,p,p2,p,p2,p,p2,p,p2,p,p2,p,p2,p,p2;return this._or((function(){return (function(){p1=this._apply("pos");return this._or((function(){return (function(){this._applyWithArgs("token","-");p=this._apply("postfix");p2=this._apply("pos");return ["unop",[p1,p2],"-",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","+");p=this._apply("postfix");p2=this._apply("pos");return ["unop",[p1,p2],"+",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","++");p=this._apply("postfix");p2=this._apply("pos");return ["preop",[p1,p2],"++",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","--");p=this._apply("postfix");p2=this._apply("pos");return ["preop",[p1,p2],"--",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","!");p=this._apply("unary");p2=this._apply("pos");return ["unop",[p1,p2],"!",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","~");p=this._apply("unary");p2=this._apply("pos");return ["unop",[p1,p2],"~",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","void");p=this._apply("unary");p2=this._apply("pos");return ["unop",[p1,p2],"void",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","delete");p=this._apply("unary");p2=this._apply("pos");return ["unop",[p1,p2],"delete",p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","typeof");p=this._apply("unary");p2=this._apply("pos");return ["unop",[p1,p2],"typeof",p]}).call(this)}))}).call(this)}),(function(){return this._apply("postfix")}))},
        "postfix":function(){var $elf=this,p1,p,p2,p2;return (function(){p1=this._apply("pos");p=this._apply("callExpr");return this._or((function(){return (function(){this._apply("spacesNoNl");this._applyWithArgs("token","++");p2=this._apply("pos");return ["postop",[p1,p2],"++",p]}).call(this)}),(function(){return (function(){this._apply("spacesNoNl");this._applyWithArgs("token","--");p2=this._apply("pos");return ["postop",[p1,p2],"--",p]}).call(this)}),(function(){return (function(){this._apply("empty");return p}).call(this)}))}).call(this)},
        "args":function(){var $elf=this,as;return (function(){this._applyWithArgs("token","(");as=this._applyWithArgs("listOf","exprPart",",");this._applyWithArgs("token",")");return as}).call(this)},
        "callExpr":function(){var $elf=this,p1,p,as,p2,p3,m,p4,as,p2,i,as,p2,i,p2,p3,f,p2;return this._or((function(){return (function(){p1=this._apply("pos");p=this._apply("callExpr");return this._or((function(){return (function(){as=this._apply("args");p2=this._apply("pos");return ["call",[p1,p2],p].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");p3=this._apply("pos");m=this._applyWithArgs("token","name");p4=this._apply("pos");as=this._apply("args");p2=this._apply("pos");return ["send",[p1,p2],["string",[p3,p4],m],p].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");i=this._apply("expr");this._applyWithArgs("token","]");as=this._apply("args");p2=this._apply("pos");return ["send",[p1,p2],i,p].concat(as)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");i=this._apply("expr");this._applyWithArgs("token","]");p2=this._apply("pos");return ["getp",[p1,p2],i,p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");p3=this._apply("pos");f=this._applyWithArgs("token","name");p2=this._apply("pos");return ["getp",[p1,p2],["string",[p3,p2],f],p]}).call(this)}))}).call(this)}),(function(){return this._apply("primExpr")}))},
        "memberExpr":function(){var $elf=this,p1,p,i,p2,p3,f,p2;return this._or((function(){return (function(){p1=this._apply("pos");p=this._apply("memberExpr");return this._or((function(){return (function(){this._applyWithArgs("token","[");i=this._apply("expr");this._applyWithArgs("token","]");p2=this._apply("pos");return ["getp",[p1,p2],i,p]}).call(this)}),(function(){return (function(){this._applyWithArgs("token",".");p3=this._apply("pos");f=this._applyWithArgs("token","name");p2=this._apply("pos");return ["getp",[p1,p2],["string",[p3,p2],f],p]}).call(this)}))}).call(this)}),(function(){return this._apply("primExpr")}))},
        "primExpr":function(){var $elf=this,e,p1,p2,p3,e,as,p2,n,p2,n,p2,s,p2,es,p2,e,f,p2;return this._or((function(){return (function(){this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");return e}).call(this)}),(function(){return (function(){this._apply("spaces");p1=this._apply("pos");return this._or((function(){return (function(){this._applyWithArgs("token","this");p2=this._apply("pos");return ["this",[p1,p2]]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","new");p3=this._apply("pos");e=this._apply("memberExpr");as=this._or((function(){return this._apply("args")}),(function(){return (function(){this._apply("empty");return []}).call(this)}));p2=this._apply("pos");return ["new",[p1,p2],["call",[p3,p2],e].concat(as)]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","name");p2=this._apply("pos");return ["get",[p1,p2],n]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","number");p2=this._apply("pos");return ["number",[p1,p2],n]}).call(this)}),(function(){return (function(){s=this._applyWithArgs("token","string");p2=this._apply("pos");return ["string",[p1,p2],s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","function");this._or((function(){return this._applyWithArgs("token","name")}),(function(){return this._apply("empty")}));return this._apply("funcRest")}).call(this)}),(function(){return (function(){this._applyWithArgs("token","[");es=this._applyWithArgs("listOf","exprPart",",");this._or((function(){return this._applyWithArgs("token",",")}),(function(){return this._apply("empty")}));this._applyWithArgs("token","]");p2=this._apply("pos");return ["arr",[p1,p2]].concat(es)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","/");e=this._many((function(){return this._or((function(){return this._apply("escapeChar")}),(function(){return (function(){this._not((function(){return this._applyWithArgs("exactly","/")}));return this._apply("char")}).call(this)}))}));this._applyWithArgs("token","/");f=this._many((function(){return this._apply("letter")}));p2=this._apply("pos");return ["regex",[p1,p2],e.join(""),f.join("")]}).call(this)}))}).call(this)}),(function(){return this._apply("json")}))},
        "json":function(){var $elf=this,p1,bs,p2;return (function(){p1=this._apply("pos");this._applyWithArgs("token","{");bs=this._applyWithArgs("listOf","jsonBinding",",");this._or((function(){return this._applyWithArgs("token",",")}),(function(){return this._apply("empty")}));this._applyWithArgs("token","}");p2=this._apply("pos");return ["json",[p1,p2]].concat(bs)}).call(this)},
        "jsonBinding":function(){var $elf=this,p1,n,v,p2;return this._or((function(){return this._apply("jsonGetter")}),(function(){return this._apply("jsonSetter")}),(function(){return (function(){p1=this._apply("pos");n=this._apply("jsonPropName");this._applyWithArgs("token",":");v=this._apply("exprPart");p2=this._apply("pos");return ["binding",[p1,p2],n,v]}).call(this)}))},
        "jsonGetter":function(){var $elf=this,p1,n,body,p2;return (function(){this._apply("spaces");p1=this._apply("pos");this._applyWithArgs("exactly","g");this._applyWithArgs("exactly","e");this._applyWithArgs("exactly","t");"get";n=this._apply("jsonPropName");this._applyWithArgs("token","(");this._applyWithArgs("token",")");this._applyWithArgs("token","{");body=this._apply("srcElems");this._applyWithArgs("token","}");p2=this._apply("pos");return ["jsonGetter",[p1,p2],n,body]}).call(this)},
        "jsonSetter":function(){var $elf=this,p1,n,arg,body,p2;return (function(){this._apply("spaces");p1=this._apply("pos");this._applyWithArgs("exactly","s");this._applyWithArgs("exactly","e");this._applyWithArgs("exactly","t");"set";n=this._apply("jsonPropName");this._applyWithArgs("token","(");arg=this._applyWithArgs("token","name");this._applyWithArgs("token",")");this._applyWithArgs("token","{");body=this._apply("srcElems");this._applyWithArgs("token","}");p2=this._apply("pos");return ["jsonSetter",[p1,p2],n,body,arg]}).call(this)},
        "jsonPropName":function(){var $elf=this;return this._or((function(){return this._applyWithArgs("token","name")}),(function(){return this._applyWithArgs("token","number")}),(function(){return this._applyWithArgs("token","string")}))},
        "memberFragment":function(){var $elf=this,jb;return (function(){this._apply("spaces");jb=this._apply("jsonBinding");this._or((function(){return (function(){switch(this._apply('anything')){case ",":return ",";default: throw fail}}).call(this)}),(function(){return this._apply("empty")}));this._apply("spaces");this._apply("end");return jb}).call(this)},
        "categoryFragment":function(){var $elf=this,p1,es,p2;return (function(){this._apply("spaces");p1=this._apply("pos");es=this._applyWithArgs("listOf","exprPart",",");p2=this._apply("pos");this._or((function(){return this._applyWithArgs("token",",")}),(function(){return this._apply("empty")}));this._apply("spaces");this._apply("end");return ["arr",[p1,p2]].concat(es)}).call(this)},
        "traitFragment":function(){var $elf=this,p1,es,p2;return (function(){this._apply("spaces");p1=this._apply("pos");this._applyWithArgs("token","name");this._applyWithArgs("token","(");this._apply("spaces");es=this._applyWithArgs("listOf","exprPart",",");this._apply("spaces");this._applyWithArgs("token",")");this._apply("spaces");this._apply("sc");p2=this._apply("pos");this._apply("spaces");this._apply("end");return ["arr",[p1,p2]].concat(es)}).call(this)},
        "formal":function(){var $elf=this,p1,n,p2;return (function(){this._apply("spaces");p1=this._apply("pos");n=this._applyWithArgs("token","name");p2=this._apply("pos");return ["get",[p1,p2],n]}).call(this)},
        "funcRest":function(){var $elf=this,p1,args,body,p2;return (function(){p1=this._apply("pos");this._applyWithArgs("token","(");args=this._applyWithArgs("listOf","formal",",");this._applyWithArgs("token",")");this._applyWithArgs("token","{");body=this._apply("srcElems");this._applyWithArgs("token","}");p2=this._apply("pos");return ["func",[p1,p2],body].concat(args)}).call(this)},
        "sc":function(){var $elf=this;return this._or((function(){return (function(){this._apply("spacesNoNl");return this._or((function(){return (function(){switch(this._apply('anything')){case "\n":return "\n";default: throw fail}}).call(this)}),(function(){return this._lookahead((function(){return this._applyWithArgs("exactly","}")}))}),(function(){return this._apply("end")}))}).call(this)}),(function(){return this._applyWithArgs("token",";")}))},
        "binding":function(){var $elf=this,p1,n,p,v,p2;return (function(){p1=this._apply("pos");n=this._applyWithArgs("token","name");v=this._or((function(){return (function(){this._applyWithArgs("token","=");return this._apply("exprPart")}).call(this)}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));p2=this._apply("pos");return ["var",[p1,p2],n,v]}).call(this)},
        "bindingList":function(){var $elf=this,p1,bs,p2;return (function(){p1=this._apply("pos");bs=this._applyWithArgs("listOf","binding",",");p2=this._apply("pos");return ["begin",[p1,p2]].concat(bs)}).call(this)},
        "block":function(){var $elf=this,ss;return (function(){this._applyWithArgs("token","{");ss=this._apply("srcElems");this._applyWithArgs("token","}");return ss}).call(this)},
        "stmt":function(){var $elf=this,p1,bs,p2,c,t,p,f,p2,c,s,p2,s,c,p2,p,i,p,c,p,u,s,p2,p3,n,p4,n,p4,v,e,s,p2,e,p3,c,cs,p4,p3,cs,p4,cs,p2,p2,p2,p2,e,p2,t,e,p,e,c,p,f,p2,p,e,p2,x,s,p2,e,p2;return this._or((function(){return this._apply("block")}),(function(){return (function(){this._apply("spaces");p1=this._apply("pos");return this._or((function(){return (function(){this._applyWithArgs("token","var");bs=this._apply("bindingList");this._apply("sc");p2=this._apply("pos");return bs}).call(this)}),(function(){return (function(){this._applyWithArgs("token","if");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");t=this._apply("stmt");f=this._or((function(){return (function(){this._applyWithArgs("token","else");return this._apply("stmt")}).call(this)}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));this._or((function(){return this._apply("sc")}),(function(){return this._apply("empty")}));p2=this._apply("pos");return ["if",[p1,p2],c,t,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");p2=this._apply("pos");return ["while",[p1,p2],c,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","do");s=this._apply("stmt");this._applyWithArgs("token","while");this._applyWithArgs("token","(");c=this._apply("expr");this._applyWithArgs("token",")");this._apply("sc");p2=this._apply("pos");return ["doWhile",[p1,p2],s,c]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");i=this._or((function(){return (function(){this._applyWithArgs("token","var");return this._apply("bindingList")}).call(this)}),(function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));this._applyWithArgs("token",";");c=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"true"]}).call(this)}));this._applyWithArgs("token",";");u=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));this._applyWithArgs("token",")");s=this._apply("stmt");p2=this._apply("pos");return ["for",[p1,p2],i,c,s,u]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","for");this._applyWithArgs("token","(");v=this._or((function(){return (function(){p3=this._apply("pos");this._applyWithArgs("token","var");n=this._applyWithArgs("token","name");p4=this._apply("pos");return ["var",[p3,p4],n,["get",[p3,p3],"undefined"]]}).call(this)}),(function(){return (function(){n=this._applyWithArgs("token","name");p4=this._apply("pos");return ["get",[p3,p4],n]}).call(this)}));this._applyWithArgs("token","in");e=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");p2=this._apply("pos");return ["forIn",[p1,p2],v,e,s]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","switch");this._applyWithArgs("token","(");e=this._apply("expr");this._applyWithArgs("token",")");this._applyWithArgs("token","{");cs=this._many((function(){return this._or((function(){return (function(){p3=this._apply("pos");this._applyWithArgs("token","case");c=this._apply("expr");this._applyWithArgs("token",":");cs=this._apply("srcElems");p4=this._apply("pos");return ["case",[p3,p4],c,cs]}).call(this)}),(function(){return (function(){p3=this._apply("pos");this._applyWithArgs("token","default");this._applyWithArgs("token",":");cs=this._apply("srcElems");p4=this._apply("pos");return ["default",[p3,p4],cs]}).call(this)}))}));this._applyWithArgs("token","}");p2=this._apply("pos");return ["switch",[p1,p2],e].concat(cs)}).call(this)}),(function(){return (function(){this._applyWithArgs("token","break");this._apply("sc");p2=this._apply("pos");return ["break",[p1,p2]]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","debugger");this._apply("sc");p2=this._apply("pos");return ["debugger",[p1,p2]]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","continue");this._apply("sc");p2=this._apply("pos");return ["continue",[p1,p2]]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","throw");this._apply("spacesNoNl");e=this._apply("expr");this._apply("sc");p2=this._apply("pos");return ["throw",[p1,p2],e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","try");t=this._apply("block");c=this._or((function(){return (function(){this._applyWithArgs("token","catch");this._applyWithArgs("token","(");e=this._apply("formal");this._applyWithArgs("token",")");return this._apply("block")}).call(this)}),(function(){return e=(function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));f=this._or((function(){return (function(){this._applyWithArgs("token","finally");return this._apply("block")}).call(this)}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));p2=this._apply("pos");return ["try",[p1,p2],t,e,c,f]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","return");e=this._or((function(){return this._apply("expr")}),(function(){return (function(){this._apply("empty");p=this._apply("pos");return ["get",[p,p],"undefined"]}).call(this)}));this._apply("sc");p2=this._apply("pos");return ["return",[p1,p2],e]}).call(this)}),(function(){return (function(){this._applyWithArgs("token","with");this._applyWithArgs("token","(");x=this._apply("expr");this._applyWithArgs("token",")");s=this._apply("stmt");p2=this._apply("pos");return ["with",[p1,p2],x,s]}).call(this)}),(function(){return (function(){e=this._apply("expr");this._apply("sc");return e}).call(this)}),(function(){return (function(){this._applyWithArgs("token",";");p2=this._apply("pos");return ["get",[p1,p2],"undefined"]}).call(this)}))}).call(this)}))},
        "functionDef":function(){var $elf=this,p1,n,f,p2;return (function(){p1=this._apply("pos");this._applyWithArgs("token","function");n=this._applyWithArgs("token","name");f=this._apply("funcRest");p2=this._apply("pos");return ["var",[p1,p2],n,f]}).call(this)},
        "functionDefFragment":function(){var $elf=this,f;return (function(){f=this._apply("functionDef");this._apply("spaces");this._apply("end");return f}).call(this)},
        "functionDefsFragment":function(){var $elf=this,p1,fs,p2;return (function(){p1=this._apply("pos");fs=this._many((function(){return this._apply("functionDef")}));p2=this._apply("pos");this._apply("spaces");this._apply("end");return ["arr",[p1,p2]].concat(fs)}).call(this)},
        "srcElem":function(){var $elf=this;return this._or((function(){return this._apply("functionDef")}),(function(){return this._apply("stmt")}))},
        "srcElems":function(){var $elf=this,p1,ss,p2;return (function(){p1=this._apply("pos");ss=this._many((function(){return this._apply("srcElem")}));p2=this._apply("pos");return ["begin",[p1,p2]].concat(ss)}).call(this)},
        "topLevel":function(){var $elf=this,r;return (function(){r=this._apply("srcElems");this._apply("spaces");this._apply("end");return r}).call(this)}})
});













module('users.timfelgentreff.jsinterpreter.Parser').requires('lively.Ometa', 'users.timfelgentreff.jsinterpreter.generated.Translator', 'users.timfelgentreff.jsinterpreter.generated.Nodes', 'users.timfelgentreff.jsinterpreter.LivelyJSParser').toRun(function() {


// LivelyJSParser is the OMeta parser defined in users.timfelgentreff.jsinterpreter.LivelyJSParser.ometa
// Here we add a few helper methods that are used in the parser rules
    Object.extend(LivelyJSParser, {

        hexDigits: "0123456789abcdef",

        keywords: (function() {
            var keywordWithIdx ={},
                keywords = ["break", "case", "catch", "continue", "default", "delete", "do", "else", "finally",
                    "for", "function", "if", "in", "instanceof", "new", "return", "switch", "this", "throw", "try",
                    "typeof", "var", "void", "while", "with", "ometa", "debugger"];
            for (var idx = 0; idx < keywords.length; idx++)
                keywordWithIdx[keywords[idx]] = true;
            return keywordWithIdx;
        })(),

        _isKeyword: function(k) {
            return this.keywords[k] === true;
        }

    });

    Object.extend(users.timfelgentreff.jsinterpreter.Parser, {

        jsParser: LivelyJSParser,
        astTranslator: JSTranslator,

        basicParse: function(source, rule) {
            // first call the LKJSParser. this will result in a synbolic AST tree.
            // translate this into real AST objects using JSTranslator
            var errorHandler = function() { throw Array.from(arguments) },
                intermediate = OMetaSupport.matchAllWithGrammar(this.jsParser, rule, source, errorHandler);
            if (!intermediate || Object.isString(intermediate)) {
                throw [source, rule, 'Could not parse JS source code', 0, intermediate];
            }
            var ast = OMetaSupport.matchWithGrammar(this.astTranslator, 'trans', intermediate);
            if (!ast || Object.isString(ast)) {
                throw [source, rule, 'Could not translate symbolic AST tree', 0, intermediate, ast];
            }
            ast.source = source;
            return ast;
        },

        parse: function(src, optRule) { return this.basicParse(src, optRule || 'topLevel') }
    });

    users.timfelgentreff.jsinterpreter.Node.addMethods(
        'accessing', {
            setParent: function(parentNode) { return this._parent = parentNode },
            getParent: function(parentNode) { return this._parent },
            hasParent: function(parentNode) { return this._parent != undefined },
            parentSequence: function() {
                return this.hasParent() && this.getParent().parentSequence();
            },
            parentFunction: function() {
                return this.hasParent() && this.getParent().parentFunction();
            },
            astIndex: function() {
                var parentFunc = this.parentFunction();
                if (!parentFunc) throw new Error('astIndex: cannot get parent fucntion of ' + this);
                return parentFunc.linearlyListNodesWithoutNestedFunctions().indexOf(this);
            },
            nodeForAstIndex: function(idx) {
                return this.linearlyListNodesWithoutNestedFunctions()[idx]
            }
        },
        'testing', {
            isASTNode: true,
            isUndefined: function(expr) {
                return expr.isVariable && expr.name === 'undefined';
            }
        },
        'enumerating', {
            withAllChildNodesDo: function(func, parent, nameInParent, depth) {
                // args of func: node, parent, nameInParent, depth; func returns true if recursive call should be made
                var node = this,
                    shouldContinue = func(node, parent, nameInParent, depth || 0);
                if (!shouldContinue) return;
                this.doForAllChildNodes(function(childNode, nameInParent) {
                    childNode.withAllChildNodesDo(func, node, nameInParent, depth ? depth + 1 : 1)
                });
            },
            withAllChildNodesDoPostOrder: function(func, stopFunc, parent, nameInParent, depth) {
                // args of func: node, parent, nameInParent, depth; func returns true if recursive call should be made
                var node = this,
                    shouldStop = stopFunc && stopFunc(node, parent, nameInParent, depth || 0);
                if (shouldStop) return;
                this.doForAllChildNodes(function(childNode, nameInParent) {
                    childNode.withAllChildNodesDoPostOrder(func, stopFunc, node, nameInParent, depth ? depth + 1 : 1)
                });
                func(node, parent, nameInParent, depth || 0);
            },

            doForAllChildNodes: function(func) {
                for (var name in this) {
                    if (!this.hasOwnProperty(name) || name == '_parent') continue;
                    var value = this[name];
                    if (value.isASTNode) {
                        func(value, name, null)
                    } else if (Object.isArray(value)) {
                        value.forEach(function(item, i) { if (item.isASTNode) func(item, name, i) });
                    }
                }
            },

            nodesMatching: function(matchFunc) {
                var result = [];
                this.withAllChildNodesDo(function(node, parent, nameInParent, depth) {
                    if (matchFunc(node, parent, nameInParent, depth)) result.push(node);
                    return true;
                });
                return result;
            },

            linearlyListNodes: function() {
                var nodes = [];
                this.withAllChildNodesDoPostOrder(function(node) { nodes.push(node) });
                return nodes;
            },

            linearlyListNodesWithoutNestedFunctions: function() {
                var root = this, nodes = [];
                this.withAllChildNodesDoPostOrder(
                    function(node) { nodes.push(node) },
                    function(node) { return node.isFunction && node !== root } // stopFunc
                );
                return nodes;
            },

            isAfter: function(other) {
                var that = this, first = null;
                this.parentFunction().body.withAllChildNodesDo(function(node) {
                    if (!first) {
                        if (node === that) first = that;
                        if (node === other) first = other;
                    }
                    return !first;
                });
                return first === other;
            }
        },
        'replacing', {

            replaceNodesMatching: function(testFunc, replacementNodeOrFunction) {
                var nodes = this.nodesMatching(testFunc);
                nodes.forEach(function(node) {
                    // Careful here! One could directly use node.replaceWith but if the replacement function
                    // reuses node and replaces it already then parent will be changed!
                    var parent = node.getParent();
                    if (!parent) throw new Error('No parent for node in replaceNodesMatching ' + node);
                    var replacementNode = (typeof replacementNodeOrFunction == 'function') ?
                        replacementNodeOrFunction(node) : replacementNodeOrFunction;
                    parent.replaceChildNode(node, replacementNode);
                })
                return this;
            },

            replaceWith: function(otherNode) {
                if (!this.hasParent())
                    throw new Error('Need parent node for replaceWith but cannot find it ' + this);
                this.getParent().replaceChildNode(this, otherNode);
                return otherNode;
            },

            replaceChildNode: function(childNode, newNode) {
                // find name if childNode in me
                var slotName, idx;
                this.doForAllChildNodes(function(node, nameInParent, i) {
                    if (node !== childNode) return;
                    slotName = nameInParent;
                    idx = i;
                });
                if (slotName === undefined) {
                    throw new Error('Cannot find childNode in me! (#replaceChildNode)');
                }
                if (idx === undefined || idx === null) {
                    this[slotName] = newNode;
                } else { // Array
                    this[slotName][idx] = newNode;
                }
                newNode.setParent(this);
            }
        },
        'evaluation', {

            eval: function() {
                var result, js;
                try {
                    js = this.asJS();
                    var src = '(' + js + ')';
                    result = eval(src);
                } catch(e) {
                    alert('Could not eval ' + js + ' because:\n' + e + '\n' + e.stack);
                }
                return result;
            }

        },
        'debugging', {

            error: function(msg) { throw new Error(msg) },
            indent: function(depth) { return Strings.indent('', ' ', depth) },
            toString: function() { return this.constructor.name },

            printTree: function(postOrder) {
                var nodeStrings = [], idx = 0,
                    enumFunc = postOrder ? 'withAllChildNodesDoPostOrder' : 'withAllChildNodesDo';
                this[enumFunc](function(node, parent, nameInParent, depth) {
                    nodeStrings.push(idx.toString() + ' ' +
                        Strings.indent(node.constructor.name + '(' + nameInParent + ')', ' ', depth));
                    idx++;
                    return true;
                })
                return nodeStrings.join('\n');
            },

            printConstructorCall: function(/* args */) {
                var call = 'new ' + this.constructor.type + '(', argCalls = [];
                for (var i = 0; i < arguments.length; i++) {
                    var arg = arguments[i], argCall = '';
                    if (Object.isArray(arg)) {
                        argCall += '[';
                        argCall += arg.collect(function(ea) {return ea.isASTNode ? ea.printConstruction() : ea}).join(',');
                        argCall += ']';
                    } else if (arg.isASTNode) {
                        argCall += arg.printConstruction();
                    } else {
                        argCall += arg;
                    }
                    argCalls.push(argCall);
                }
                call += argCalls.join(',');
                call += ')';
                return call;
            },

        },
        'stepping', {
            firstStatement: function() {
                return this;
            },
            nextStatement: function(node) {
                var stmt = this.getParent().nextStatement(this);
                return stmt ? stmt.firstStatement() : null;
            },
            isComposite: function() {
                return false;
            }
        },
        'matching', {
            match: function(patternAst) {
                var matchedPlaceholder = true;
                for (var key in patternAst) {
                    var result = this.matchVal(key, this[key], patternAst[key]);
                    if (result !== true) matchedPlaceholder = result;
                }
                return matchedPlaceholder;
            },
            matchVal: function(key, value, pattern) {
                if (pattern === users.timfelgentreff.jsinterpreter.Node.placeholder) return value;
                if (value == pattern) return true;
                if (Object.isString(pattern)) {
                    if (value.toString() == pattern) return true;
                    if (value.value == pattern) return true;
                    if (value.name == pattern) return true;
                }
                if (Object.isArray(pattern) && Object.isArray(value)) {
                    var matchedPlaceholder = true;
                    for (var i = 0; i < pattern.length; i++) {
                        var success = false,
                            lastError = null;
                        for (var j = 0; j < value.length; j++) {
                            try {
                                var res = this.matchVal(key, value[j], pattern[i]);
                                if (res !== true) matchedPlaceholder = res;
                                success = true;
                            } catch(e) { lastError = e; }
                        }
                        if (!success) throw lastError;
                    }
                    if (value.length !== pattern.length) {
                        throw {key: key, err: "count",
                            expected: pattern.length, actual: value.length};
                    }
                    return matchedPlaceholder;
                }
                if (Object.isObject(pattern) && value.isASTNode) {
                    return value.match(pattern);
                }
                throw {key: key, err: "missmatch", expected: String(pattern), actual: String(value)};
            }
        });

    Object.subclass('users.timfelgentreff.jsinterpreter.SourceGenerator',
        'documentation', {
            usage: 'gen = new users.timfelgentreff.jsinterpreter.SourceGenerator();\n\
gen.writeAndEvalTranslator();\n\
gen.evalAndWriteClasses();\n\
users.timfelgentreff.jsinterpreter.Parser.astTranslator = JSTranslator;\n\
users.timfelgentreff.jsinterpreter.Parser.jsParser = LivelyJSParser;',

            showUsage: function() {
                $world.addTextWindow({content: this.usage, title: "users.timfelgentreff.jsinterpreter.SourceGenerator usage"})
            }
        },
        'settings', {
            customRules: function() { return ['trans = [:t apply(t):ans] -> ans,'] },
            customClasses: function() { return ["Object.subclass('" + this.rootNodeClassName + "')"] },

            translatorRules: function() {
                var names = this.constructor.categories['translator rules'],
                    result = {};
                names.forEach(function(name) { result[name] = this[name] }, this);
                return result;
            },

            modulePath: 'users.timfelgentreff.jsinterpreter.',
            rootNodeClassName: 'users.timfelgentreff.jsinterpreter.Node',
            visitorClassName: 'users.timfelgentreff.jsinterpreter.Visitor'
        },
        'translator rules', {

            begin: {
                className: 'Sequence', rules: [':pos', 'trans*:children', 'end'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.children) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s)',
                            this.constructor.name, this.children.join(','))
                    },
                },
                conversion: {
                    asJS: function(depth) {
                        var indent = this.indent(depth || 0);
                        depth = depth || -1;
                        return this.children.invoke('asJS', depth + 1).join(';\n' + indent);
                    },
                },
                insertion: {
                    insertBefore: function(newNode, existingNode) {
                        for (var i = 0; i < this.children.length; i++)
                            if (this.children[i].nodesMatching(function(node) {
                                    return node === existingNode }).length > 0)
                                break;
                        if (!this.children[i])
                            throw dbgOn(new Error('insertBefore: ' + existingNode + ' not in ' + this));
                        return this.insertAt(newNode, i);
                    },
                    insertAt: function(newNode, idx) {
                        this.children.pushAt(newNode, idx);
                        newNode.setParent(this);
                        return newNode;
                    },
                },
                accessing: {
                    parentSequence: function() { return this },
                },
                stepping: {
                    firstStatement: function() {
                        return this.children.length > 0
                            ? this.children[0].firstStatement()
                            : this;
                    },
                    nextStatement: function($super, node) {
                        var idx = this.children.indexOf(node);
                        if (idx >= 0 && idx < this.children.length - 1)
                            return this.children[idx + 1];
                        return $super(this);
                    },
                    isComposite: function() {
                        return true;
                    }
                }
            },

            number: {
                className: 'Number', rules: [':pos', ':value'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.pos, this.value) },
                    toString: function() { return Strings.format('%s(%s)', this.constructor.name, this.value) },
                },
                conversion: {
                    asJS: function(depth) { return this.value },
                },
            },

            string: {
                className: 'String', rules: [':pos', ':value'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"' + this.value + '"') },
                    toString: function() { return Strings.format('%s(%s)', this.constructor.name, this.value) },
                },
                conversion: {
                    asJS: function(depth) { return '"' + this.value + '"' },
                },
            },

            condExpr: {
                className: 'Cond', rules: [':pos', 'trans:condExpr', 'trans:trueExpr', 'trans:falseExpr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr) },
                    toString: function() { return Strings.format(
                        '%s(%s?%s:%s)',
                        this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format(
                            '(%s) ? (%s) : (%s)',
                            this.condExpr.asJS(depth), this.trueExpr.asJS(depth), this.falseExpr.asJS(depth));
                    },
                },
            },

            'if': {
                className: 'If', rules: [':pos', 'trans:condExpr', 'trans:trueExpr', 'trans:falseExpr'],
                initializing: {
                    initialize: function($super, pos, condExpr, trueExpr, falseExpr) {
                        this.pos = pos;
                        this.condExpr = condExpr;
                        // FIXME actually this could be done with OMeta
                        this.trueExpr = trueExpr.isSequence || this.isUndefined(trueExpr) ?
                            trueExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [trueExpr]);
                        this.falseExpr = falseExpr.isSequence || this.isUndefined(falseExpr) ?
                            falseExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [falseExpr]);
                        condExpr.setParent(this);
                        this.trueExpr.setParent(this);
                        this.falseExpr.setParent(this);
                    },
                },
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr) },
                    toString: function() { return Strings.format(
                        '%s(%s?%s:%s)',
                        this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr) },
                },
                conversion: {
                    asJS: function(depth) {
                        var str = Strings.format(
                            'if (%s) {%s}',
                            this.condExpr.asJS(depth), this.trueExpr.asJS(depth));
                        if (!this.isUndefined(this.falseExpr))
                            str += ' else {' + this.falseExpr.asJS(depth) + '}';
                        return str;
                    },
                },
                stepping: {
                    firstStatement: function() {
                        return this.condExpr.firstStatement();
                    },
                    nextStatement: function($super, node) {
                        return node === this.condExpr ? this.trueExpr : $super(this);
                    },
                    isComposite: function() { return true; }
                }
            },

            'while': {
                className: 'While', rules: [':pos', 'trans:condExpr', 'trans:body'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.condExpr, this.body) },
                    toString: function() { return Strings.format(
                        '%s(%s?%s)',
                        this.constructor.name, this.condExpr, this.body) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format(
                            'while (%s) {%s}',
                            this.condExpr.asJS(depth), this.body.asJS(depth));
                    },
                },
                stepping: {
                    firstStatement: function() {
                        return this.condExpr.firstStatement();
                    },
                    nextStatement: function($super, node) {
                        if (node === this.condExpr) {
                            return this.body;
                        } else if (node === this.body) {
                            return this.condExpr;
                        } else {
                            return $super(this);
                        }
                    },
                    isComposite: function() {
                        return true;
                    }
                },
            },

            'doWhile': {
                className: 'DoWhile', rules: [':pos', 'trans:body', 'trans:condExpr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.body, this.condExpr) },
                    toString: function() { return Strings.format(
                        '%s(%s while%s)',
                        this.constructor.name, this.body, this.condExpr) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format(
                            'do {%s} while (%s);',
                            this.body.asJS(depth), this.condExpr.asJS(depth));
                    },
                },
                stepping: {
                    firstStatement: function() {
                        return this.body.firstStatement();
                    },
                    nextStatement: function($super, node) {
                        if (node === this.condExpr) {
                            return this.body;
                        } else if (node === this.body) {
                            return this.condExpr;
                        } else {
                            return $super(this);
                        }
                    },
                    isComposite: function() {
                        return true;
                    }
                },
            },

            'for': {
                className: 'For', rules: [':pos', 'trans:init', 'trans:condExpr', 'trans:body', 'trans:upd'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.init, this.condExpr, this.body, this.upd) },
                    toString: function() { return Strings.format(
                        '%s(%s;%s;%s do %s)',
                        this.constructor.name, this.init, this.condExpr, this.upd, this.body) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format(
                            'for (%s; %s; %s) {%s}',
                            this.init.asJS(depth), this.condExpr.asJS(depth), this.upd.asJS(depth), this.body.asJS(depth));
                    },
                },
                stepping: {
                    firstStatement: function() {
                        return this.init.firstStatement();
                    },
                    nextStatement: function($super, node) {
                        if (node === this.init || node === this.upd) {
                            return this.condExpr;
                        } else if (node === this.condExpr) {
                            return this.body;
                        } else if (node === this.body) {
                            return this.upd;
                        } else {
                            return $super(this);
                        }
                    },
                    isComposite: function() {
                        return true;
                    }
                }
            },

            forIn: {
                className: 'ForIn', rules: [':pos', 'trans:name', 'trans:obj', 'trans:body'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.name, this.obj, this.body) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s in %s do %s)',
                            this.constructor.name, this.name, this.obj, this.body);
                    },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format(
                            'for (%s in %s) {%s}',
                            this.name.asJS(depth), this.obj.asJS(depth), this.body.asJS(depth));
                    },
                },
            },

            set: {
                className: 'Set', rules: [':pos', 'trans:left', 'trans:right'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.left, this.right) },
                    toString: function() { return Strings.format(
                        '%s(%s = %s)',
                        this.constructor.name, this.left, this.right) },
                },
                conversion: {
                    asJS: function(depth) { return this.left.asJS(depth) + ' = ' + this.right.asJS(depth) },
                },
            },

            mset: {
                className: 'ModifyingSet', rules: [':pos', 'trans:left', ':name', 'trans:right'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.left, '"' + this.name + '"', this.right) },
                    toString: function() { return Strings.format(
                        '%s(%s %s %s)',
                        this.constructor.name, this.left, this.name, this.right) },
                },
                conversion: {
                    asJS: function(depth) { return this.left.asJS(depth) + ' ' + this.name + '= ' + this.right.asJS(depth) },
                },
            },

            binop: {
                className: 'BinaryOp', rules: [':pos', ':name', 'trans:left', 'trans:right'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"' + this.name + '"', this.left, this.right) },
                    toString: function() { return Strings.format(
                        '%s(%s %s %s)',
                        this.constructor.name, this.left, this.name, this.right) },
                },
                conversion: {
                    asJS: function(depth) { return '(' + this.left.asJS(depth) + ') ' + this.name + ' (' + this.right.asJS(depth) + ')' },
                },
            },

            unop: {
                className: 'UnaryOp', rules: [':pos', ':name', 'trans:expr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr) },
                    toString: function() { return Strings.format(
                        '%s(%s%s)',
                        this.constructor.name, this.name, this.expr) },
                },
                conversion: {
                    asJS: function(depth) { return '(' + this.name + this.expr.asJS(depth) + ')'},
                },
            },

            preop: {
                className: 'PreOp', rules: [':pos', ':name', 'trans:expr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"' + this.name+'"', this.expr) },
                    toString: function() { return Strings.format(
                        '%s(%s%s)',
                        this.constructor.name, this.name, this.expr) },
                },
                conversion: {
                    asJS: function(depth) { return '(' + this.name + this.expr.asJS(depth) + ')' },
                },
            },

            postop: {
                className: 'PostOp', rules: [':pos', ':name', 'trans:expr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.expr) },
                    toString: function() { return Strings.format(
                        '%s(%s%s)',
                        this.constructor.name, this.expr, this.name) },
                },
                conversion: {
                    asJS: function(depth) { return '(' + this.expr.asJS(depth) + this.name + ')'},
                },
            },

            'this': {
                className: 'This', rules: [':pos'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos) },
                    toString: function() { return this.constructor.name },
                },
                conversion: {
                    asJS: function(depth) { return 'this' },
                },
            },

            get: {
                className: 'Variable', rules: [':pos', ':name'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"'+this.name+'"') },
                    toString: function() { return Strings.format(
                        '%s(%s)',
                        this.constructor.name, this.name) },
                },
                conversion: {
                    asJS: function(depth) { return this.name },
                },
            },

            getp: {
                className: 'GetSlot', rules: [':pos', 'trans:slotName', 'trans:obj'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.slotName, this.obj) },
                    toString: function() { return Strings.format(
                        '%s(%s[%s])',
                        this.constructor.name, this.obj, this.slotName) },
                },
                conversion: {
                    asJS: function(depth) {
                        var objJS = this.obj.asJS(depth);
                        if (this.obj.isFunction) objJS = '(' + objJS + ')';
                        return objJS + '[' + this.slotName.asJS(depth) + ']';
                    },
                },
            },

            'break': {
                className: 'Break', rules: [':pos', 'trans:label'],
                initializing: {
                    initialize: function($super, pos, label) {
                        this.pos = pos;
                        this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], '');
                        this.label.setParent(this);
                    },
                },
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.label) },
                },
                conversion: {
                    asJS: function(depth) { return 'break' + this.label.asJS(); },
                },
            },

            'debugger': {
                className: 'Debugger', rules: [':pos'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos) },
                },
                conversion: {
                    asJS: function(depth) { return 'debugger' },
                },
            },

            'continue': {
                className: 'Continue', rules: [':pos', 'trans:label'],
                initializing: {
                    initialize: function($super, pos, label) {
                        this.pos = pos;
                        this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], '');
                        this.label.setParent(this);
                    },
                },
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.label) },
                },
                conversion: {
                    asJS: function(depth) { return 'continue' + this.label.asJS(); },
                },
            },

            arr: {
                className: 'ArrayLiteral', rules: [':pos', 'trans*:elements'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.elements) },
                    toString: function() { return Strings.format(
                        '%s(%s)',
                        this.constructor.name, this.elements.join(',')) },
                },
                conversion: {
                    asJS: function(depth) { return '[' + this.elements.invoke('asJS').join(',') + ']' },
                },
            },

            'return': {
                className: 'Return', rules: [':pos', 'trans:expr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.expr) },
                    toString: function() { return Strings.format(
                        '%s(%s)',
                        this.constructor.name, this.expr) },
                },
                conversion: {
                    asJS: function(depth) { return 'return ' + this.expr.asJS(depth) },
                },
            },

            'with': {
                className: 'With', rules: [':pos', 'trans:obj', 'trans:body'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.obj, this.body) },
                    toString: function() { return Strings.format(
                        '%s(%s %s)',
                        this.constructor.name, this.obj, this.body) },
                },
                conversion: {
                    asJS: function(depth) { return 'with (' + this.obj.asJS(depth) + ') {' + this.body.asJS(depth) + '}' },
                },
            },

            send: {
                className: 'Send', rules: [':pos', 'trans:property', 'trans:recv', 'trans*:args'],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.property, this.recv, this.args)
                    },
                    toString: function() {
                        return Strings.format('%s(%s[%s](%s))',
                            this.constructor.name, this.recv, this.property, this.args.join(','))
                    },
                },
                conversion: {
                    asJS: function(depth) {
                        var recvJS = this.recv.asJS(depth);
                        if (this.recv.isFunction) recvJS = '(' + recvJS + ')';
                        return Strings.format(
                            '%s[%s](%s)',
                            recvJS, this.property.asJS(depth), this.args.invoke('asJS').join(','));
                    },
                },
                accessing: {
                    getName: function() { return this.property },
                },
            },

            call: {
                className: 'Call', rules: [':pos', 'trans:fn', 'trans*:args'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.fn, this.args) },
                    toString: function() { return Strings.format(
                        '%s(%s(%s))',
                        this.constructor.name, this.fn, this.args.join(',')) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('%s(%s)',
                            this.fn.asJS(depth), this.args.invoke('asJS').join(','));
                    },
                },
                accessing: {
                    getName: function() { return this.fn.name },
                },
            },

            'new': {
                className: 'New', rules: [':pos', 'trans:clsExpr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.clsExpr) },
                    toString: function() { return Strings.format(
                        '%s(%s)',
                        this.constructor.name, this.clsExpr) },
                },
                conversion: {
                    asJS: function(depth) {
                        return 'new ' + this.clsExpr.asJS(depth);
                    }
                }
            },

            'var': {
                className: 'VarDeclaration', rules: [':pos', ':name', 'trans:val'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.val) },
                    toString: function() { return Strings.format(
                        '%s(%s = %s)',
                        this.constructor.name, this.name, this.val) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('var %s = %s', this.name, this.val.asJS(depth));
                    },
                },
            },

            'throw': {
                className: 'Throw', rules: [':pos', 'trans:expr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.expr) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s)',
                            this.constructor.name, this.expr)
                    },
                },
                conversion: {
                    asJS: function(depth) { return 'throw ' + this.expr.asJS(depth) },
                },
            },

            'try': {
                className: 'TryCatchFinally', rules: [':pos', 'trans:trySeq', 'trans:err', 'trans:catchSeq', 'trans:finallySeq'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.trySeq, '"'+this.err.name+'"', this.catchSeq, this.finallySeq) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s %s %s)',
                            this.constructor.name, this.trySeq, this.catchSeq, this.finallySeq)
                    },
                },
                conversion: {
                    asJS: function(depth) {
                        var baseIndent = this.indent(depth-1),
                            indent = this.indent(depth),
                            str = 'try {\n' + indent + this.trySeq.asJS(depth) + '\n' + baseIndent + '}';
                        if (!this.isUndefined(this.catchSeq))
                            str += ' catch(' + this.err.name + ') {\n' +
                                indent + this.catchSeq.asJS(depth) + '\n' + baseIndent + '}';
                        if (!this.isUndefined(this.finallySeq))
                            str += ' finally {\n' + indent + this.finallySeq.asJS(depth) + '\n' + baseIndent + '}';
                        return str;
                    },
                },
            },

            func: {
                className: 'Function', rules: [':pos', 'trans:body', 'trans*:args'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.body, this.args.collect(function(ea) { return '"' + ea.name + '"' })) },
                    toString: function() {
                        return Strings.format(
                            '%s(function %s(%s) %s)',
                            this.constructor.name, this.name(), this.argNames().join(','), this.body)
                    },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('function%s(%s) {\n%s\n}',
                            this.name() ? ' ' + this.name() : '', this.argNames().join(','),
                            this.indent(depth+1) + this.body.asJS(depth+1));
                    },
                },
                accessing: {
                    name: function() {
                        if (this._parent && this._parent.isVarDeclaration) {
                            return this._parent.name;
                        }
                        return undefined;
                    },
                    parentFunction: function() { return this },
                    argNames: function() { return this.args.collect(function(a){ return a.name }); },
                    statements: function() { return this.body.children },
                },
                stepping: {
                    firstStatement: function() { return this.body.firstStatement(); },
                    nextStatement: function(node) { return null; },
                    isComposite: function() { return true; }
                },
                evaluation: {
                    eval: function() {
                        return new Function(this.argNames().join(","), this.body.asJS());
                    },
                }
            },

            json: {
                className: 'ObjectLiteral', rules: [':pos', 'trans*:properties'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.properties) },
                    toString: function() {
                        return Strings.format(
                            '%s({%s})',
                            this.constructor.name, this.properties.join(','))
                    },
                },
                conversion: {
                    asJS: function(depth) {
                        return '{' + this.properties.invoke('asJS').join(',') + '}';
                    },
                },
            },

            binding: {
                className: 'ObjProperty', rules: [':pos', ':name', 'trans:property'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.property) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s: %s)',
                            this.constructor.name, this.name, this.property) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('"%s": %s', this.name, this.property.asJS(depth));
                    },
                },
            },
            jsonGetter: {
                className: 'ObjPropertyGet', rules: [':pos', ':name', 'trans:body'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.body) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s() { %s })',
                            this.constructor.name, this.name, this.body) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('get "%s"() { %s }', this.name, this.body.asJS(depth));
                    },
                },
            },
            jsonSetter: {
                className: 'ObjPropertySet', rules: [':pos', ':name', 'trans:body', ':arg'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"'+this.name+'"', this.body, this.arg) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s(%s) { %s })',
                            this.constructor.name, this.name, this.arg, this.body) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('set "%s"(%s) { %s }', this.name, this.arg, this.body.asJS(depth));
                    },
                },
            },


            'switch': {
                className: 'Switch', rules: [':pos', 'trans:expr', 'trans*:cases'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.expr, this.cases) },
                    toString: function() { return Strings.format('%s(%s %s)',
                        this.constructor.name, this.expr, this.cases.join('\n')) },
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('switch (%s) {%s}',
                            this.expr.asJS(depth), this.cases.invoke('asJS').join('\n'));
                    },
                },
            },

            'case': {
                className: 'Case', rules: [':pos',  'trans:condExpr', 'trans:thenExpr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.condExpr, this.thenExpr) },
                    toString: function() {
                        return Strings.format(
                            '%s(%s: %s)',
                            this.constructor.name, this.condExpr, this.thenExpr) },
                },
                conversion: {
                    asJS: function(depth) {
                        return 'case ' + this.condExpr.asJS(depth) + ': ' + this.thenExpr.asJS(depth);
                    },
                },
            },

            'default': {
                className: 'Default', rules: [':pos', 'trans:defaultExpr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.defaultExpr) },
                    toString: function() { return Strings.format(
                        '%s(default: %s)',
                        this.constructor.name,  this.defaultExpr) },
                },
                conversion: {
                    asJS: function(depth) { return 'default: ' + this.defaultExpr.asJS(depth) },
                },
            },

            'regex': {
                className: 'Regex', rules: [':pos', ':exprString', ':flags'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, this.exprString, this.flags) },
                    toString: function() { return Strings.format('(/%s/%s)', this.exprString, this.flags) },
                },
                conversion: {
                    asJS: function(depth) { return '/' + this.exprString + '/' + this.flags},
                },
            },

            label: {
                className: 'Label', rules: [':pos', ':name'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"' + this.name + '"') },
                    toString: function() { return Strings.format('%s(%s)', this.constructor.name, this.name) },
                },
                conversion: {
                    asJS: function(depth) { return this.name; },
                },
            },

            labelDcl: {
                className: 'LabelDeclaration', rules: [':pos', ':name', 'trans:expr'],
                debugging: {
                    printConstruction: function() { return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr) },
                    toString: function() { return Strings.format('%s(%s is %s)', this.constructor.name, this.name, this.expr) },
                },
                conversion: {
                    asJS: function(depth) { return this.name + ': ' + this.expr.asJS(depth) },
                },
            },
        },
        'rule helper', {

            rulesReturningSomething: function(ruleSpec) {
                if (!ruleSpec.rules) return [];
                return ruleSpec.rules.reject(function(ea) { return ea.startsWith(':') || !ea.include(':') });
            },

            forCollectionRulesDo: function(ruleSpec, func) {
                // rule "trans*:foo"
                var rules = this.rulesReturningSomething(ruleSpec),
                    collectionRules = rules.select(function(ea) {return ea.include('*:') });
                collectionRules.forEach(function(rule) {
                    var ruleParts = rule.split('*:');
                    func.apply(this, ruleParts);
                }, this);
                return collectionRules;
            },

            forSimpleRulesDo: function(ruleSpec, func) {
                // rule "trans:foo"
                var rules = this.rulesReturningSomething(ruleSpec),
                    collectionRules = rules.select(function(ea) {return ea.include('*:') }),
                    simpleRules = rules.without.apply(rules, collectionRules);
                simpleRules.forEach(function(rule) {
                    var ruleParts = rule.split(':');
                    func.apply(this, ruleParts);
                }, this);
                return simpleRules;
            },

        },
        'file handling', {

            writeToFile: function(fileName, content) {
                var baseURL = URL.codeBase.withFilename(this.modulePath.replace(/\./g, '/')),
                    url = baseURL.withFilename('generated/' + fileName);
                new WebResource(url).put(content);
            },

        },
        'rule creation', {

            createRule: function(name, spec) {
                var ownRules = spec.rules || [],
                    argNames = this.argsFromRules(ownRules),
                    className = this.modulePath + spec.className,
                    ruleAppString = ownRules.length > 0 ? ('\t' + ownRules.join(' ') + '\n') : '',
                    ruleStart = name + ' =\n',
                    ruleReturn = Strings.format('\t-> { new %s(%s) },', className, argNames.join(', '));
                return ruleStart + ruleAppString + ruleReturn;
            },

            argsFromRules: function(rules) {
                if (!rules) return [];
                return rules
                    .select(function(ea) { return ea.include(':') })
                    .collect(function(ea) { return ea.split(':').last() });
            },

            createJSTranslatorSource: function() {
                var rules = this.customRules();
                Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    rules.push(this.createRule(name, ruleSpec));
                }, this);

                var head = 'ometa JSTranslator <: Parser {\n',
                    body = rules.join('\n'),
                    end = '\n}';

                body = body.substring(0, body.length-1); // remove last ,

                return head + body + end;
            },

            writeAndEvalTranslator: function() {
                var source = this.createJSTranslatorSource(),
                    translated = OMetaSupport.translateToJs(source);
                eval(translated);
                var content = Strings.format(
                    'module(\'users.timfelgentreff.jsinterpreter.generated.Translator\').' +
                    'requires(\'ometa.lively\').toRun(function() {\n%s\n});', translated)
                this.writeToFile('Translator.ometa', source);
                this.writeToFile('Translator.js', content);
            },
        },

        'class creation', {

            assignmentsFromArgs: function(argNames) {
                return argNames.collect(function(ea) {
                    return Strings.format('\t\tthis.%s = %s;', ea, ea);
                }).join('\n');
            },

            parentCallsFromRules: function(ruleSpec) {
                // new users.timfelgentreff.jsinterpreter.SourceGenerator().parentCallsFromRules({rules: ['trans:foo', 'trans*:bar']})
                var parentCalls = [];
                this.forCollectionRulesDo(ruleSpec, function(rule, ruleVarName) {
                    var str = Strings.format('\t\t%s.forEach(function(node) { node.setParent(this) }, this);', ruleVarName);
                    parentCalls.push(str)
                });

                this.forSimpleRulesDo(ruleSpec, function(rule, ruleVarName) {
                    var str = Strings.format('\t\t%s.setParent(this);', ruleVarName);
                    parentCalls.push(str);
                });

                return parentCalls.join('\n');
            },

            createASTClass: function(ruleSpec) {
                var className = this.modulePath + ruleSpec.className,
                    superclassName = this.rootNodeClassName,
                    args = this.argsFromRules(ruleSpec.rules),
                    setParentCalls = this.parentCallsFromRules(ruleSpec),
                    assignments = this.assignmentsFromArgs(args),
                    categories = [];

                // testing category
                categories.push(Strings.format('\n\'testing\', {\n\t%s: true,\n}',
                    this.genTypeProperty(ruleSpec.className)));

                // intializer category
                if (args.length > 0 && !Properties.own(ruleSpec).include('initializing')) {
                    categories.push(Strings.format(
                        '\n\'initializing\', {\n\tinitialize: function($super, %s) {\n%s\n%s\n\t},\n}',
                        args.join(', '), assignments, setParentCalls));
                }

                // other categories
                Properties.own(ruleSpec).without('className', 'rules').forEach(function(catName) {
                    var src = '\n\'' + catName + '\', {\n',
                        category = ruleSpec[catName],
                        functionNames = Functions.own(category);
                    functionNames.forEach(function(name) {
                        src += Strings.format('\t%s: %s,\n', name, category[name])
                    });
                    src += '}';
                    categories.push(src);
                });

                categories.push(this.visitingCategoryForNode(ruleSpec));

                var body = categories.join(','),
                    def = Strings.format('%s.subclass(\'%s\',%s)', superclassName, className, body);

                return def
            },

            genTypeProperty: function(className) {
                return 'is' + className;
            },

            createASTClassSourcesFromRules: function() {
                var classDefs = this.customClasses();
                Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    classDefs.push(this.createASTClass(ruleSpec));
                }, this);
                return classDefs.join(';\n\n')
            },

            evalAndWriteClasses: function() {
                var src = this.createASTClassSourcesFromRules();
                src += ';\n\n';
                src += this.abstractVisitorClassSource();
                eval(src);

                var baseName = 'Nodes',
                    moduleName = this.modulePath + 'generated.' + baseName,
                    fileName = baseName + '.js',
                    content = Strings.format('module(\'%s\').requires().toRun(function() {\n%s\n});', moduleName, src);
                this.writeToFile(fileName, content);
            },

        },
        'visitor creation', {

            abstractVisitorClassSource: function() {
                var categories = [this.visitingCategoryForAbstractVisitor()/*, this.doubleDispatchCategoryForVisitor()*/];
                return Strings.format('Object.subclass(\'%s\',%s)', this.visitorClassName, categories.join(',\n'));
            },

            visitingCategoryForAbstractVisitor: function(ruleSpec) {
                var src = '\n\'visiting\', {\n';
                src += '\tvisit: function(node) { return node.accept(this) },\n';
                Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    src += Strings.format('\tvisit%s: function(node) {},\n', ruleSpec.className);
                });
                src += '\n}'
                return src;
            },

            doubleDispatchCategoryForVisitor: function() {
                // new users.timfelgentreff.jsinterpreter.SourceGenerator().doubleDispatchCategoryForVisitor()
                // currently not used
                var createVisitAndAcceptCalls = function(ruleSpec) {
                    var calls = [];
                    calls.push('\t\this.visit(node);')
                    this.forCollectionRulesDo(ruleSpec, function(rule, ruleVarName) {
                        var str = Strings.format('\t\tnode.%s.forEach(function(ea) { this.visit(ea) }, this);', ruleVarName);
                        calls.push(str)
                    });

                    this.forSimpleRulesDo(ruleSpec, function(rule, ruleVarName) {
                        var str = Strings.format('\t\tthis.visit(node.%s);', ruleVarName);
                        calls.push(str);
                    });
                    return calls.join('\n')

                }.bind(this)

                var src = '\n\'double dispatch\', {\n';
                Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    src += Strings.format('\taccept%s: function(node) {\n%s\n\t},\n', ruleSpec.className, createVisitAndAcceptCalls(ruleSpec));
                });

                src += '\n}'

                return src;
            },

            visitingCategoryForNode: function(ruleSpec) {
                return "\n'visiting', {\n"
                    + "    accept: function(visitor) {\n"
                    + "        return visitor.visit" + ruleSpec.className + "(this);\n"
                    + "    }\n"
                    + " }";
            }

        });


    Object.extend(users.timfelgentreff.jsinterpreter.Node, {
        placeholder: {}
    });

}) // end of module















module('users.timfelgentreff.jsinterpreter.Meta').requires('users.timfelgentreff.jsinterpreter.Parser').toRun(function() {

// Meta-Programming functions for displaying and saving functions
    Function.addMethods(
        'meta programming interface', {
            toSource: function() {
                if (!this.source) {
                    var name = this.methodName || this.name || "anonymous";
                    this.source = this.toString()
                        .replace(/^function[^\(]*/, "function " + name);
                }
                return this.source;
            },
            browse: function() {
                if (this.sourceModule && this.methodName && this.declaredClass) {
                    /*require('lively.ide.SystemCodeBrowser').toRun(function() {
                        return lively.ide.browse(
                            this.declaredClass,
                            this.methodName,
                            this.sourceModule.name());
                    }.bind(this));*/
                }
                //TODO: Add browse implementation for Morphic scripts with ObjectEditor
                throw new Error('Cannot browse anonymous function ' + this);
            },
            updateSource: function(source) {
                var ast = users.timfelgentreff.jsinterpreter.Parser.parse(source, "functionDef"),
                    newFun = ast.val.eval();
                newFun.declaredClass = this.declaredClass;
                newFun.methodName = this.methodName;
                newFun.sourceModule = this.sourceModule;
                newFun.source = source;
                newFun.locallyChanged = true;
                // TODO: This should probably use 'addMethods' instead
                this.getClass().prototype[this.methodName] = newFun;
                lively.bindings.signal(this, 'localSource', newFun);
                users.timfelgentreff.jsinterpreter.Meta.ChangeSet.getCurrent().addChange(newFun);
            },
            getClass: function() {
                return lively.Class.forName(this.declaredClass);
            }
        });

// Skeleton for ChangeSets support - still work in Progress
    Object.subclass('users.timfelgentreff.jsinterpreter.Meta.ChangeSet',
        'initializing', {
            initialize: function() {
                this.changes = [];
            }
        },
        'managing', {
            addChange: function(fun) {
                this.changes.push(fun);
                lively.bindings.signal(this.constructor, 'current', this);
            }
        },
        'persistence', {
            commit: function() {
                throw new Error('not implemented yet');
            }
        },
        'merging', {
            mergeWithCurrent: function() {
                throw new Error('not implemented yet');
            }
        });

    Object.extend(users.timfelgentreff.jsinterpreter.Meta.ChangeSet, {
        current: null,
        getCurrent: function() {
            if (!this.current) {
                this.current = new this();
            }
            return this.current;
        }
    });

}) // end of module














module('users.timfelgentreff.jsinterpreter.Rewriting').requires('users.timfelgentreff.jsinterpreter.Parser').toRun(function() {

    Object.extend(users.timfelgentreff.jsinterpreter, {
        oldEval: eval
    });

    Object.extend(users.timfelgentreff.jsinterpreter.Rewriting, {
        table: []
    });

    users.timfelgentreff.jsinterpreter.Visitor.subclass('users.timfelgentreff.jsinterpreter.Rewriting.Transformation',
        'helping', {
            visitNodes: function(nodes) {
                var result = [];
                for (var i = 0; i < nodes.length; i++) {
                    var res = this.visit(nodes[i]);
                    if (res) result.push(res);
                }
                return result;
            }
        },
        'visiting', {
            visitSequence: function(node) {
                return new users.timfelgentreff.jsinterpreter.Sequence(node.pos, this.visitNodes(node.children));
            },
            visitNumber: function(node) {
                return new users.timfelgentreff.jsinterpreter.Number(node.pos, node.value);
            },
            visitString: function(node) {
                return new users.timfelgentreff.jsinterpreter.String(node.pos, node.value);
            },
            visitCond: function(node) {
                return new users.timfelgentreff.jsinterpreter.Cond(node.pos,
                    this.visit(node.condExpr),
                    this.visit(node.trueExpr),
                    this.visit(node.falseExpr));
            },
            visitIf: function(node) {
                return new users.timfelgentreff.jsinterpreter.If(node.pos,
                    this.visit(node.condExpr),
                    this.visit(node.trueExpr),
                    this.visit(node.falseExpr));
            },
            visitWhile: function(node) {
                return new users.timfelgentreff.jsinterpreter.While(node.pos,
                    this.visit(node.condExpr),
                    this.visit(node.body));
            },
            visitDoWhile: function(node) {
                return new users.timfelgentreff.jsinterpreter.DoWhile(node.pos,
                    this.visit(node.body),
                    this.visit(node.condExpr));
            },
            visitFor: function(node) {
                return new users.timfelgentreff.jsinterpreter.For(node.pos,
                    this.visit(node.init),
                    this.visit(node.condExpr),
                    this.visit(node.body),
                    this.visit(node.upd));
            },
            visitForIn: function(node) {
                return new users.timfelgentreff.jsinterpreter.ForIn(node.pos,
                    this.visit(node.name),
                    this.visit(node.obj),
                    this.visit(node.body));
            },
            visitSet: function(node) {
                return new users.timfelgentreff.jsinterpreter.Set(node.pos,
                    this.visit(node.left),
                    this.visit(node.right));
            },
            visitModifyingSet: function(node) {
                return new users.timfelgentreff.jsinterpreter.ModifyingSet(node.pos,
                    this.visit(node.left),
                    node.name,
                    this.visit(node.right));
            },
            visitBinaryOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.BinaryOp(node.pos,
                    node.name,
                    this.visit(node.left),
                    this.visit(node.right));
            },
            visitUnaryOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.UnaryOp(node.pos,
                    node.name,
                    this.visit(node.expr));
            },
            visitPreOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.PreOp(node.pos,
                    node.name,
                    this.visit(node.expr));
            },
            visitPostOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.PostOp(node.pos,
                    node.name,
                    this.visit(node.expr));
            },
            visitThis: function(node) {
                return new users.timfelgentreff.jsinterpreter.This(node.pos);
            },
            visitVariable: function(node) {
                return new users.timfelgentreff.jsinterpreter.Variable(node.pos, node.name);
            },
            visitGetSlot: function(node) {
                return new users.timfelgentreff.jsinterpreter.GetSlot(node.pos,
                    this.visit(node.slotName),
                    this.visit(node.obj));
            },
            visitBreak: function(node) {
                return new users.timfelgentreff.jsinterpreter.Break(node.pos);
            },
            visitDebugger: function(node) {
                return new users.timfelgentreff.jsinterpreter.Debugger(node.pos);
            },
            visitContinue: function(node) {
                return new users.timfelgentreff.jsinterpreter.Continue(node.pos);
            },
            visitArrayLiteral: function(node) {
                return new users.timfelgentreff.jsinterpreter.ArrayLiteral(node.pos, this.visitNodes(node.elements));
            },
            visitReturn: function(node) {
                return new users.timfelgentreff.jsinterpreter.Return(node.pos,this.visit(node.expr));
            },
            visitWith: function(node) {
                throw new Error('with statement not supported');
            },
            visitSend: function(node) {
                return new users.timfelgentreff.jsinterpreter.Send(node.pos,
                    this.visit(node.property),
                    this.visit(node.recv),
                    this.visitNodes(node.args));
            },
            visitCall: function(node) {
                return new users.timfelgentreff.jsinterpreter.Call(node.pos,
                    this.visit(node.fn),
                    this.visitNodes(node.args));
            },
            visitNew: function(node) {
                return new users.timfelgentreff.jsinterpreter.New(node.pos, this.visit(node.clsExpr));
            },
            visitVarDeclaration: function(node) {
                return new users.timfelgentreff.jsinterpreter.VarDeclaration(node.pos, node.name, this.visit(node.val));
            },
            visitThrow: function(node) {
                return new users.timfelgentreff.jsinterpreter.Throw(node.pos, this.visit(node.expr));
            },
            visitTryCatchFinally: function(node) {
                return new users.timfelgentreff.jsinterpreter.TryCatchFinally(node.pos,
                    this.visit(node.trySeq),
                    node.err,
                    this.visit(node.catchSeq),
                    this.visit(node.finallySeq));
            },
            visitFunction: function(node) {
                return new users.timfelgentreff.jsinterpreter.Function(node.pos,
                    this.visit(node.body),
                    this.visitNodes(node.args));
            },
            visitObjectLiteral: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjectLiteral(node.pos, this.visitNodes(node.properties));
            },
            visitObjProperty: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjProperty(node.pos, node.name, this.visit(node.property));
            },
            visitSwitch: function(node) {
                return new users.timfelgentreff.jsinterpreter.Switch(node.pos,
                    this.visit(node.expr),
                    this.visitNodes(node.cases));
            },
            visitCase: function(node) {
                return new users.timfelgentreff.jsinterpreter.Case(node.pos,
                    this.visit(node.condExpr),
                    this.visit(node.thenExpr));
            },
            visitDefault: function(node) {
                return new users.timfelgentreff.jsinterpreter.Case(node.pos, this.visit(node.defaultExpr));
            },
            visitRegex: function(node) {
                return new users.timfelgentreff.jsinterpreter.Regex(node.pos, node.exprString, node.flags);
            },
            visitObjPropertyGet: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjPropertyGet(node.pos, node.name, this.visit(node.body));
            },
            visitObjPropertySet: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjPropertySet(node.pos,
                    node.name,
                    this.visit(node.body),
                    node.arg);
            }
        });

    users.timfelgentreff.jsinterpreter.Rewriting.Transformation.subclass('users.timfelgentreff.jsinterpreter.Rewriting.RemoveDebugger',
        'visiting', {
            visitDebugger: function(node) {
                return undefined;
            }
        });

    users.timfelgentreff.jsinterpreter.Rewriting.Transformation.subclass('users.timfelgentreff.jsinterpreter.Rewriting.Rewriter',
        'initializing', {
            initialize: function($super) {
                $super();
                this.scopes = [];
            }
        },
        'scoping', {
            enterScope: function() {
                this.scopes.push([]);
            },
            registerVar: function(name) {
                if (this.scopes.length == 0) return;
                this.scopes.last().push(name);
            },
            referenceVar: function(name) {
                for (var i = this.scopes.length - 1; i >= 0; i--) {
                    if (this.scopes[i].include(name)) return i;
                }
                return undefined;
            },
            exitScope: function() {
                this.scopes.pop();
            },
        },
        'helping', {
            computationFrame: function() {
                return new users.timfelgentreff.jsinterpreter.Variable([0,0], "_");
            },
            localFrame: function(i) {
                return new users.timfelgentreff.jsinterpreter.Variable([0,0], "_" + i);
            },
            frame: function(i) {
                if (i < 0) return new users.timfelgentreff.jsinterpreter.Variable([0,0], "Global");
                return new users.timfelgentreff.jsinterpreter.Variable([0,0], "__" + i);
            },
            storeComputationResult: function(node) {
                if (this.scopes.length == 0) return node; // dont store if there is no frame
                var name = new users.timfelgentreff.jsinterpreter.String(node.pos, node.position());
                var target = new users.timfelgentreff.jsinterpreter.GetSlot(node.pos, name, this.computationFrame());
                return new users.timfelgentreff.jsinterpreter.Set(node.pos, target, node);
            },
            registerArguments: function(func) {
                var args = [];
                for (var i = 0; i < func.args.length; i++) {
                    var arg = func.args[i];
                    this.registerVar(arg.name);
                    args.push(new users.timfelgentreff.jsinterpreter.Variable(arg.pos, arg.name));
                }
                return args;
            },
            registerLocals: function(func) {
                var that = this;
                func.body.withAllChildNodesDo(function(node) {
                    if (node.isFunction) return false;
                    if (node.isVarDeclaration) that.registerVar(node.name);
                    return true;
                });
            }
        },
        'rewriting', {
            wrapVar: function(pos, name) {
                var scope = this.referenceVar(name);
                if (scope === undefined) return new users.timfelgentreff.jsinterpreter.Variable(pos, name);
                return new users.timfelgentreff.jsinterpreter.GetSlot(pos,
                    new users.timfelgentreff.jsinterpreter.String(pos, name),
                    this.localFrame(scope));
            },
            rewriteVarDeclaration: function(pos, name, expr) {
                return new users.timfelgentreff.jsinterpreter.Set(pos, this.wrapVar(pos, name), expr);
            },
            emptyObj: function() {
                return new users.timfelgentreff.jsinterpreter.ObjectLiteral([0,0], []);
            },
            argsInitObj: function(args) {
                var properties = [];
                for (var i = 0; i < args.length; i++) {
                    var arg = args[i].name;
                    var argVal = new users.timfelgentreff.jsinterpreter.Variable([0,0], arg);
                    properties.push(new users.timfelgentreff.jsinterpreter.ObjProperty([0,0], arg, argVal));
                }
                return new users.timfelgentreff.jsinterpreter.ObjectLiteral([0,0], properties);
            },
            addPreamble: function(astIdx, body, args) {
                var p = body.pos;
                var level = this.scopes.length;
                var initComputationFrame = new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "_", this.emptyObj());
                var initLocalFrame = new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "_"+level, this.argsInitObj(args));
                var frame = new users.timfelgentreff.jsinterpreter.ArrayLiteral(p, [this.computationFrame(),
                    this.localFrame(level),
                    new users.timfelgentreff.jsinterpreter.Number(p, astIdx),
                    this.frame(level - 1)]);
                var initFrame = new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "__" + level, frame);
                return new users.timfelgentreff.jsinterpreter.Sequence(p, [initComputationFrame, initLocalFrame, initFrame, body]);
            },
            catchExceptions: function(astIdx, body) {
                var p = body.pos;
                var level = this.scopes.length;
                var parent = level == 0 ? "Global" : "__" + (level - 1);
                var throwStmt = new users.timfelgentreff.jsinterpreter.Throw(p, new users.timfelgentreff.jsinterpreter.Variable(p, "ex"));
                var shiftStmt = new users.timfelgentreff.jsinterpreter.Send(p,
                    new users.timfelgentreff.jsinterpreter.String(p,"shiftFrame"),
                    new users.timfelgentreff.jsinterpreter.Variable(p,"ex"),
                    [new users.timfelgentreff.jsinterpreter.This(p), new users.timfelgentreff.jsinterpreter.Variable(p, "__" + level)]);
                var isUnwind = new users.timfelgentreff.jsinterpreter.GetSlot(p,
                    new users.timfelgentreff.jsinterpreter.String(p, "isUnwindException"),
                    new users.timfelgentreff.jsinterpreter.Variable(p, "e"));
                var classExpr = new users.timfelgentreff.jsinterpreter.GetSlot(p,
                    new users.timfelgentreff.jsinterpreter.String(p,"UnwindExecption"),
                    new users.timfelgentreff.jsinterpreter.GetSlot(p,
                        new users.timfelgentreff.jsinterpreter.String(p,"Rewriting"),
                        new users.timfelgentreff.jsinterpreter.GetSlot(p,
                            new users.timfelgentreff.jsinterpreter.String(p,"ast"),
                            new users.timfelgentreff.jsinterpreter.Variable(p,"lively"))));
                var newUnwind = new users.timfelgentreff.jsinterpreter.New(p,
                    new users.timfelgentreff.jsinterpreter.Call(p, classExpr, [new users.timfelgentreff.jsinterpreter.Variable(p,"e")]));
                var cond = new users.timfelgentreff.jsinterpreter.Cond(p, isUnwind,
                    new users.timfelgentreff.jsinterpreter.Variable(p, "e"),
                    newUnwind);
                var catchSeq = new users.timfelgentreff.jsinterpreter.Sequence(p, [
                    new users.timfelgentreff.jsinterpreter.VarDeclaration(p,"ex",cond), shiftStmt, throwStmt])
                var noop = new users.timfelgentreff.jsinterpreter.Variable(body.pos, "undefined");
                var error = new users.timfelgentreff.jsinterpreter.Variable(body.pos, "e");
                return new users.timfelgentreff.jsinterpreter.TryCatchFinally(body.pos, body, error, catchSeq, noop);
            },
            wrapFunctionBody: function(astIdx, body, args) {
                return this.catchExceptions(astIdx, this.addPreamble(astIdx, body, args));
            },
            wrapClosure: function(idx, node) {
                var fn = new users.timfelgentreff.jsinterpreter.Variable(node.pos, "__createClosure");
                var scope = this.frame(this.scopes.length - 1);
                var astIdx = new users.timfelgentreff.jsinterpreter.Number([0,0], idx);
                return new users.timfelgentreff.jsinterpreter.Call(node.pos, fn, [astIdx, scope, node]);
            }
        },
        'visiting', {
            visitVarDeclaration: function(node) {
                this.registerVar(node.name.value);
                return this.storeComputationResult(
                    this.rewriteVarDeclaration(node.pos, node.name, this.visit(node.val)));
            },
            visitVariable: function(node) {
                return this.wrapVar(node.pos, node.name);
            },
            visitDebugger: function(node) {
                var ret = new users.timfelgentreff.jsinterpreter.Return(node.pos, new users.timfelgentreff.jsinterpreter.String(node.pos, "Debuggger"));
                var returnDebugger = new users.timfelgentreff.jsinterpreter.Function(node.pos,
                    new users.timfelgentreff.jsinterpreter.Sequence(node.pos, [ret]), []);
                var ast = this.storeComputationResult(returnDebugger);
                var toString = new users.timfelgentreff.jsinterpreter.ObjProperty(node.pos, "toString", ast);
                return new users.timfelgentreff.jsinterpreter.Throw(node.pos, new users.timfelgentreff.jsinterpreter.ObjectLiteral(node.pos, [toString]));
            },
            visitSet: function($super, node) {
                return this.storeComputationResult($super(node));
            },
            visitCall: function($super, node) {
                return this.storeComputationResult($super(node));
                //return this.storeComputationResult(new users.timfelgentreff.jsinterpreter.Call(node.pos,
                //   this.storeComputationResult(this.visit(node.fn)),
                //   this.visitNodes(node.args)));
            },
            visitSend: function($super, node) {
                return this.storeComputationResult($super(node));
            },
            visitModifyingSet: function($super, node) {
                return this.storeComputationResult($super(node));
            },

            visitPreOp: function($super, node) {
                return this.storeComputationResult($super(node));
            },
            visitPostOp: function($super, node) {
                return this.storeComputationResult($super(node));
            },
            visitNew: function(node) {
                var clsExpr = this.visit(node.clsExpr);
                if (clsExpr.isSet) clsExpr = clsExpr.right;
                return this.storeComputationResult(new users.timfelgentreff.jsinterpreter.New(node.pos, clsExpr));
            },
            visitFunction: function($super, node) {
                this.enterScope();
                var args = this.registerArguments(node);
                this.registerLocals(node);
                var rewritten = new users.timfelgentreff.jsinterpreter.Function(node.pos, this.visit(node.body), args);
                this.exitScope();
                users.timfelgentreff.jsinterpreter.Rewriting.table.push(node);
                var idx = users.timfelgentreff.jsinterpreter.Rewriting.table.length - 1;
                rewritten.body = this.wrapFunctionBody(idx, rewritten.body, rewritten.args);
                return this.storeComputationResult(this.wrapClosure(idx, rewritten));
            }
        });

    Object.subclass('users.timfelgentreff.jsinterpreter.Rewriting.UnwindExecption',
        'settings', {
            isUnwindException: true
        },
        'initializing', {
            initialize: function(error) {
                this.error = error;
            }
        },
        'printing', {
            toString: function() {
                return this.error.toString();
            }
        },
        'frames', {
            shiftFrame: function(thiz, frame) {
                var computationFrame = frame[0];
                var localFrame = frame[1];
                localFrame["this"] = thiz;
                var astIndex = frame[2];
                var scope = frame[3];
                var stackFrame = [computationFrame, localFrame, astIndex, Global, scope];
                if (!this.top) {
                    this.top = this.last = stackFrame;
                    return;
                }
                this.last[3] = stackFrame;
                this.last = stackFrame;
            }
        });

    Object.extend(Global, {
        __createClosure: function(idx, scope, f) {
            f._cachedAst = users.timfelgentreff.jsinterpreter.Rewriting.table[idx];
            f._cachedScope = scope;
            return f;
        },
        eval2: function(src) {
            var ast = users.timfelgentreff.jsinterpreter.Parser.parse(src, 'topLevel');
            var wrapped = new users.timfelgentreff.jsinterpreter.Function([0,0], ast, []);
            wrapped.source = src;
            var rewriter = new users.timfelgentreff.jsinterpreter.Rewriting.Rewriter();
            var rewrittenAst = rewriter.visit(wrapped);
            return users.timfelgentreff.jsinterpreter.oldEval(rewrittenAst.asJS())();
        }
    });

    Object.extend(JSLoader, {
        loadJs2: function (url, onLoadCb, loadSync, okToUseCache, cacheQuery) {
            var exactUrl = url;
            if ((exactUrl.indexOf('!svn') <= 0) && !okToUseCache) {
                exactUrl = this.makeUncached(exactUrl, cacheQuery);
            }
            $.ajax(exactUrl, {
                success: users.timfelgentreff.jsinterpreter.Rewriting.loadJS.bind(users.timfelgentreff.jsinterpreter.Rewriting, onLoadCb)
            });
        }
    });

    Object.extend(users.timfelgentreff.jsinterpreter.Rewriting, {
        loadJS: function(cb, src) {
            if (!src) { src = cb; cb = null; }
            eval(src);
            if (cb) cb();
        }
    });

}) // end of module











/*
 * Copyright (c) 2008-2011 Hasso Plattner Institute
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module('users.timfelgentreff.jsinterpreter.Interpreter').requires('users.timfelgentreff.jsinterpreter.Parser', 'users.timfelgentreff.jsinterpreter.Meta', 'users.timfelgentreff.jsinterpreter.Rewriting').toRun(function() {

    Object.subclass('users.timfelgentreff.jsinterpreter.Interpreter.Frame',
        'initialization', {
            initialize: function(func, mapping) {
                this.func = func;
                this.mapping = mapping || {};
                this.returnTriggered = false;
                this.breakTriggered = false;
                this.continueTriggered = false;
                this.findSetterMode = false;
                this.breakAtCalls = false;
                this.pc = null; // "program counter", actually an AST node
                this.bp = null; // "break point", actually an AST node
                this.values = {}; // stores the results of computed expressions and statements
            },
            newScope: function(mapping) {
                var newFrame = new users.timfelgentreff.jsinterpreter.Interpreter.Frame(mapping);
                newFrame.setContainingScope(this);
                return newFrame;
            },
            breakAtFirstStatement: function() {
                this.bp = this.func.ast().firstStatement();
            }
        },
        'accessing', {
            setContainingScope: function(frame) {
                return this.containingScope = frame;
            },
            getContainingScope: function() {
                return this.containingScope;
            },
            getCaller: function() {
                return this.caller;
            },
            setCaller: function(caller) {
                if (!caller) return;
                this.caller = caller;
                caller.callee = this;
                if (caller.breakAtCalls) this.breakAtFirstStatement();
            },
            setThis: function(thisObj) {
                this.addToMapping('this', thisObj);
                return thisObj;
            },
            getThis: function() {
                return this.mapping["this"] ? this.mapping["this"] : Global;
            },
            setArguments: function(argValues) {
                var argNames = this.func.ast().argNames();
                for (var i = 0; i < argNames.length; i++) {
                    this.addToMapping(argNames[i], argValues[i]);
                }
                return this.arguments = argValues;
            },
            getArguments: function(args) {
                return this.arguments;
            },
            getFuncName: function() {
                return this.func ?
                    this.func.getOriginal().qualifiedMethodName() :
                    'frame has no function!';
            },
            getFuncSource: function() {
                return this.func ?
                    this.func.getOriginal().toSource() :
                    'frame has no function!';
            },
            findFrame: function(name) {
                if (this.mapping.hasOwnProperty(name)) {
                    return {val: this.mapping[name], frame: this};
                }
                if (this.mapping === Global) { // reached global scope
                    throw new ReferenceError(name + " is not defined");
                }
                // lookup in my current function
                var mapping = this.func.getVarMapping();
                if (mapping) {
                    if (mapping.hasOwnProperty(name)) {
                        return {val: mapping[name], frame: this};
                    }
                }
                var containingScope = this.getContainingScope();
                return containingScope ? containingScope.findFrame(name) : null;
            },
            lookup: function(name) {
                if (name === 'undefined') return undefined;
                if (name === 'null') return null;
                if (name === 'true') return true;
                if (name === 'false') return false;
                if (name === 'NaN') return NaN;
                if (name === 'arguments') return this.getArguments();
                var frame = this.findFrame(name);
                if (frame) return frame.val;
                return undefined;
            },
            addToMapping: function(name, value) {
                return this.mapping[name] = value;
            },
            addAllToMapping: function(otherMapping) {
                for (var name in otherMapping) {
                    if (!otherMapping.hasOwnProperty(name)) continue;
                    this.mapping[name] = otherMapping[name];
                }
            },
            triggerReturn: function() {
                this.returnTriggered = true
            },
            triggerBreak: function() {
                this.breakTriggered = true
            },
            stopBreak: function() {
                this.breakTriggered = false
            },
            triggerContinue: function() {
                this.continueTriggered = true
            },
            stopContinue: function() {
                this.continueTriggered = false
            }
        },
        'accessing for UI', {
            listItemsForIntrospection: function() {
                var items = Properties.forEachOwn(this.mapping, function(name, value) {
                    return {
                        isListItem: true,
                        string: name + ': ' + String(value).truncate(50),
                        value: value
                    };
                });
                if (this.containingScope) {
                    items.push({isListItem: true, string: '[[containing scope]]'});
                    items.pushAll(this.containingScope.listItemsForIntrospection());
                }
                return items;
            }
        },
        'program counter', {
            halt: function() {
                this.unbreak();
                if (users.timfelgentreff.jsinterpreter.halt(this)) {
                    throw {
                        isUnwindException: true,
                        topFrame: this,
                        toString: function() {return "Debugger"}
                    };
                }
            },
            haltAtNextStatement: function(breakAtCalls) {
                if (this.pc === this.func.ast()) {
                    var caller = this.getCaller();
                    if (caller && caller.isResuming()) {
                        caller.haltAtNextStatement();
                    }
                } else {
                    var nextStmt = this.pc.nextStatement();
                    this.bp = nextStmt ? nextStmt : this.func.ast();
                }
            },
            stepToNextStatement: function(breakAtCalls) {
                this.haltAtNextStatement();
                return this.resume(breakAtCalls);
            },
            hasNextStatement: function() {
                return this.pc.nextStatement() != null;
            },
            restart: function() {
                this.initialize(this.func, this.mapping);
                this.breakAtFirstStatement();
                this.resume();
            }
        },
        'resuming', {
            isResuming: function() {
                return this.pc !== null || this.bp !== null;
            },
            resumesNow: function() {
                this.pc = null;
            },
            isBreakingAt: function(node) {
                if (this.bp === null) return false;
                if (this.bp === node) return true;
                if (this.bp == node.nextStatement()) return false;
                return node.isAfter(this.bp);
            },
            findPC: function() {
                if (Object.isEmpty(this.values)) return;
                // find the last computed value
                var last = Object.keys(this.values).max(function(k) {
                    var fromTo = k.split('-');
                    return (+fromTo[1]) << 23 - (+fromTo[0]);
                });
                // find the node corresponding to this value
                var node = this.func.ast().nodesMatching(function(node) {
                    return last == node.position();
                })[0];
                // if the node is a debugger just use it as PC
                if (node.isDebugger) return this.pc = node;
                // the pc should be the next MODIFYING node right after the last one
                var pc = null;
                var foundNode = false;
                this.func.ast().withAllChildNodesDoPostOrder(function(n) {
                    if (!foundNode) {
                        if (n === node) foundNode = true;
                    } else {
                        if (n.isCall || n.isSend || n.isSet || n.isModifyingSet || n.isPreOp || n.isPostOp) {
                            pc = n;
                            return false
                        }
                    }
                    return true;
                });
                this.pc = pc || this.func.ast();
            },
            setPC: function(node) {
                this.pc = node.isFunction ? node : node.firstStatement();
                if (this.isBreakingAt(node)) this.halt();
            },
            getValue: function(node) {
                var value = this.values[node.position()];
                // if no value was cached, set PC and compute normally
                return value ? value : this.setPC(node);
            },
            putValue: function(node, value) {
                return this.values[node.position()] = {
                    val: value
                };
            },
            removeValue: function(node) {
                var that = this;
                node.withAllChildNodesDo(function(child){
                    delete that.values[child.position()];
                    return true;
                });
            },
            resume: function(breakAtCalls) {
                this.breakAtCalls = breakAtCalls ? true : false;
                var result = this.func.ast().resume(this);
                if (this.getCaller() && this.getCaller().isResuming()) {
                    this.getCaller().putValue(this.getCaller().pc, result);
                }
                // break right after the last statement
                this.setPC(this.func.ast());
                if (this.getCaller() && this.getCaller().isResuming()) {
                    return this.getCaller().resume(breakAtCalls);
                }
                return result;
            },
            unbreak: function() {
                // remove all previous breakpoints in this and caller frames
                this.bp = null;
                if (this.getCaller()) {
                    this.getCaller().unbreak();
                }
            }
        },
        'debugging', {
            toString: function() {
                var mappings = [];
                for (var name in this.mapping) {
                    if (this.mapping.hasOwnProperty(name)) {
                        mappings.push(name + ': ' + this.mapping[name]);
                    }
                }
                var mappingString = '{' + mappings.join(',') + '}';
                return 'Frame(' + mappingString + ')';
            }
        });

    Object.extend(users.timfelgentreff.jsinterpreter.Interpreter.Frame, {
        create: function(func, mapping) {
            return new users.timfelgentreff.jsinterpreter.Interpreter.Frame(func, mapping || {});
        },
        global: function() {
            return this.create(null, Global);
        },
        fromTraceNode: function(trace) {
            var frame;
            if (trace.frame) {
                frame = trace.frame;
            } else {
                frame = users.timfelgentreff.jsinterpreter.Interpreter.Frame.create(trace.method);
                frame.setThis(trace.itsThis);
                frame.setArguments(trace.args);
            }
            if (trace.caller && !trace.caller.isRoot) {
                frame.setCaller(users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromTraceNode(trace.caller));
            }
            return frame;
        },
        fromScope: function(scope, callstack) {
            if (scope === Global) return users.timfelgentreff.jsinterpreter.Interpreter.Frame.global();
            var ast = users.timfelgentreff.jsinterpreter.Rewriting.table[scope[2]],
                frame = new users.timfelgentreff.jsinterpreter.Interpreter.Frame(ast.asFunction(), scope[1]),
                parent = users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromScope(scope[3], callstack);
            if (callstack) {
                frame.values = scope[0];
                frame.findPC();
                if (scope[3] !== Global) frame.setCaller(parent);
                if (scope[4] !== Global) frame.setContainingScope(
                    users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromScope(scope[4]));
            } else {
                frame.setContainingScope(parent);
            }
            return frame;
        }
    });

    users.timfelgentreff.jsinterpreter.Visitor.subclass('users.timfelgentreff.jsinterpreter.InterpreterVisitor',
        'interface', {
            run: function(node, optMapping) {
                return this.runWithFrame(node, users.timfelgentreff.jsinterpreter.Interpreter.Frame.create(null, optMapping));
            },
            runWithFrame: function(node, frame) {
                this.currentFrame = frame;
                return this.visit(node);
            }
        },
        'invoking', {
            isNative: function(func) {
                if (!this._nativeFuncRegex) this._nativeFuncRegex = /\{\s+\[native\scode\]\s+\}$/;
                return this._nativeFuncRegex.test(func.toString())
            },
            shouldInterpret: function(frame, func) {
                if (this.isNative(func)) return false;
                return func.hasOwnProperty("forInterpretation")
                    || frame.breakAtCalls
                    || func.containsDebugger();
            },
            invoke: function(node, recv, func, argValues) {
                var isNew = node._parent && node._parent.isNew;
                this.currentFrame.setPC(node);
                // if we send apply to a function (recv) we want to interpret it
                // although apply is a native function
                if (recv && Object.isFunction(recv) && func === Function.prototype.apply) {
                    func = recv; // The function object is what we want to run
                    recv = argValues.shift(); // thisObj is first parameter
                    argValues = argValues[0]; // the second arg are the arguments (as an array)
                }
                if (this.shouldInterpret(this.currentFrame, func)) {
                    func = func.forInterpretation();
                }
                if (isNew) {
                    if (this.isNative(func)) return new func();
                    recv = this.newObject(func)
                }
                var result = func.apply(recv, argValues);
                if (isNew) {// && !Object.isObject(result)) {
                    //FIXME: Cannot distinguish real result from (accidental) last result
                    //       which might also be an object but which should not be returned
                    // 13.2.2 ECMA-262 3rd. Ediion Specification:
                    return recv;
                }
                return result;
            },
            newObject: function(func) {
                var proto = func.prototype;
                function constructor() {};
                constructor.prototype = proto;
                var newObj = new constructor();
                newObj.constructor = func;
                return newObj;
            }
        },
        'visiting', {
            visit: function(node) {
                var value = this.currentFrame.getValue(node);
                if (!value) {
                    value = this.currentFrame.putValue(node, node.accept(this));
                }
                return value.val;
            },
            visitSequence: function(node) {
                var result, frame = this.currentFrame;
                for (var i = 0; i < node.children.length; i++) {
                    result = this.visit(node.children[i]);
                    if (frame.returnTriggered || frame.breakTriggered || frame.continueTriggered) {
                        return result;
                    }
                }
                return result;
            },
            visitNumber: function(node) {
                return node.value;
            },
            visitString: function(node) {
                return node.value;
            },
            visitCond: function(node) {
                var frame = this.currentFrame,
                    condVal = this.visit(node.condExpr);
                return condVal ? this.visit(node.trueExpr) : this.visit(node.falseExpr);
            },
            visitIf: function(node) {
                return this.visitCond(node);
            },
            visitWhile: function(node) {
                var result, frame = this.currentFrame;
                while (this.visit(node.condExpr)) {
                    result = this.visit(node.body);
                    if (frame.continueTriggered) {
                        frame.stopContinue()
                    };
                    if (frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    };
                    if (frame.returnTriggered) {
                        return result
                    };
                    frame.removeValue(node.condExpr);
                    frame.removeValue(node.body);
                }
                return result;
            },
            visitDoWhile: function(node) {
                var frame = this.currentFrame, result, condResult;
                do {
                    frame.removeValue(node.condExpr);
                    result = this.visit(node.body);
                    if (frame.continueTriggered) {
                        frame.stopContinue()
                    };
                    if (frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    };
                    if (frame.returnTriggered) {
                        return result
                    };
                    condResult = this.visit(node.condExpr);
                    frame.removeValue(node.body);
                } while (condResult);
                return result;
            },
            visitFor: function(node) {
                var frame = this.currentFrame, result;
                this.visit(node.init);
                while (this.visit(node.condExpr)) {
                    result = this.visit(node.body);
                    if (frame.continueTriggered) {
                        frame.stopContinue();
                    };
                    if (frame.breakTriggered) {
                        frame.stopBreak();
                        break;
                    };
                    if (frame.returnTriggered) {
                        return result;
                    };
                    this.visit(node.upd);
                    frame.removeValue(node.condExpr);
                    frame.removeValue(node.body);
                    frame.removeValue(node.upd);
                }
                return result;
            },
            visitForIn: function(node) {
                var frame = this.currentFrame,
                    varPart = node.name,
                    obj = this.visit(node.obj),
                    result;
                if (varPart.isVarDeclaration) {
                    varPart.val.name = varPart.name;
                }
                for (var name in obj) {
                    frame.addToMapping(varPart.name, name);
                    result = this.visit(node.body);
                    if (frame.continueTriggered) {
                        frame.stopContinue();
                    };
                    if (frame.breakTriggered) {
                        frame.stopBreak();
                        break;
                    };
                    if (frame.returnTriggered) {
                        return result;
                    };
                    frame.removeValue(node.body);
                }
                return result;
            },
            visitSet: function(node) {
                var frame = this.currentFrame;
                return node.left.set(this.visit(node.right), frame, this);
            },
            visitModifyingSet: function(node) {
                var frame = this.currentFrame,
                    op = node.name + '=',
                    oldValue = this.visit(node.left),
                    newValue;
                switch (op) {
                    case '+=':
                        newValue = oldValue + this.visit(node.right);
                        break;
                    case '-=':
                        newValue = oldValue - this.visit(node.right);
                        break;
                    case '*=':
                        newValue = oldValue * this.visit(node.right);
                        break;
                    case '/=':
                        newValue = oldValue / this.visit(node.right);
                        break;
                    case '>>=':
                        newValue = oldValue >>= this.visit(node.right);
                        break;
                    case '<<=':
                        newValue = oldValue <<= this.visit(node.right);
                        break;
                    case '>>>=':
                        newValue = oldValue >>> this.visit(node.right);
                        break;
                    case '&=':
                        newValue = oldValue & this.visit(node.right);
                        break;
                    case '|=':
                        newValue = oldValue | this.visit(node.right);
                        break;
                    case '&=':
                        newValue = oldValue & this.visit(node.right);
                        break;
                    case '^=':
                        newValue = oldValue ^ this.visit(node.right);
                        break;
                    case '||=':
                        newValue = oldValue || this.visit(node.right);
                        break;
                    case '&&=':
                        newValue = oldValue && this.visit(node.right);
                        break;
                    default:
                        throw new Error('Modifying set has unknown operation ' + op);
                }
                return node.left.set(newValue, frame, this);
            },
            visitBinaryOp: function(node) {
                var frame = this.currentFrame,
                    leftVal = this.visit(node.left);
                switch (node.name) {
                    case '||':
                        return leftVal || this.visit(node.right);
                    case '&&':
                        return leftVal && this.visit(node.right);
                }
                var rightVal = this.visit(node.right);
                switch (node.name) {
                    case '+':
                        return leftVal + rightVal;
                    case '-':
                        return leftVal - rightVal;
                    case '*':
                        return leftVal * rightVal;
                    case '/':
                        return leftVal / rightVal;
                    case '%':
                        return leftVal % rightVal;
                    case '<':
                        return leftVal < rightVal;
                    case '<=':
                        return leftVal <= rightVal;
                    case '>':
                        return leftVal > rightVal;
                    case '>=':
                        return leftVal >= rightVal;
                    case '==':
                        return leftVal == rightVal;
                    case '===':
                        return leftVal === rightVal;
                    case '!=':
                        return leftVal != rightVal;
                    case '!==':
                        return leftVal !== rightVal;
                    case '&':
                        return leftVal & rightVal;
                    case '|':
                        return leftVal | rightVal;
                    case '^':
                        return leftVal ^ rightVal;
                    case '>>':
                        return leftVal >> rightVal;
                    case '<<':
                        return leftVal << rightVal;
                    case '>>>':
                        return leftVal >>> rightVal;
                    case 'in':
                        return leftVal in rightVal;
                    case 'instanceof':
                        return leftVal instanceof rightVal;
                    default:
                        throw new Error('No semantics for binary op ' + node.name)
                }
            },
            visitUnaryOp: function(node) {
                var frame = this.currentFrame,
                    val = this.visit(node.expr);
                switch (node.name) {
                    case '-':
                        return -val;
                    case '!':
                        return !val;
                    case '~':
                        return~val;
                    case 'typeof':
                        return typeof val;
                    default:
                        throw new Error('No semantics for unary op ' + node.name)
                }
            },
            visitPreOp: function(node) {
                var frame = this.currentFrame,
                    setExpr = node.expr;
                if (!setExpr.isVariable && !setExpr.isGetSlot) {
                    throw new Error('Invalid expr in pre op ' + setExpr);
                }
                var value = this.visit(setExpr),
                    newValue;
                switch (node.name) {
                    case '++':
                        newValue = value + 1;
                        break;
                    case '--':
                        newValue = value - 1;
                        break;
                    default:
                        throw new Error('No semantics for pre op ' + node.name)
                }
                setExpr.set(newValue, frame, this);
                return newValue;
            },
            visitPostOp: function(node) {
                var frame = this.currentFrame,
                    setExpr = node.expr;
                if (!setExpr.isVariable && !setExpr.isGetSlot) {
                    throw dbgOn(new Error('Invalid expr in post op ' + setExpr));
                }
                var value = this.visit(setExpr), newValue;
                switch (node.name) {
                    case '++':
                        newValue = value + 1;
                        break;
                    case '--':
                        newValue = value - 1;
                        break;
                    default:
                        throw new Error('No semantics for post op ' + node.name)
                }
                setExpr.set(newValue, frame, this);
                return value;
            },
            visitThis: function(node) {
                return this.currentFrame.getThis();
            },
            visitVariable: function(node) {
                return this.currentFrame.lookup(node.name);
            },
            visitGetSlot: function(node) {
                var obj = this.visit(node.obj),
                    name = this.visit(node.slotName),
                    value = obj[name];
                return value;
            },
            visitBreak: function(node) {
                this.currentFrame.triggerBreak();
            },
            visitContinue: function(node) {
                this.currentFrame.triggerContinue();
            },
            visitDebugger: function($super, node) {
                this.currentFrame.putValue(node, 1); // mark this 'debugger' as visited
                this.currentFrame.halt(node, true);
            },
            visitArrayLiteral: function(node) {
                var result = new Array(node.elements.length);
                for (var i = 0; i < node.elements.length; i++) {
                    result[i] = this.visit(node.elements[i]);
                }
                return result;
            },
            visitReturn: function(node) {
                var frame = this.currentFrame,
                    val = this.visit(node.expr);
                frame.triggerReturn();
                return val;
            },
            visitWith: function(node) {
                throw new Error('with statement not yet supported');
            },
            visitSend: function(node) {
                var recv = this.visit(node.recv),
                    property = this.visit(node.property),
                    argValues = node.args.collect(function(ea) { return this.visit(ea) }, this);
                return this.invoke(node, recv, recv[property], argValues);
            },
            visitCall: function(node) {
                var func = this.visit(node.fn),
                    argValues = node.args.collect(function(ea) { return this.visit(ea) }, this);
                return this.invoke(node, undefined, func, argValues);
            },
            visitNew: function(node) {
                // No need to do anything because Send and Call
                // will look up _parent for New
                return this.visit(node.clsExpr);
            },
            visitVarDeclaration: function(node) {
                var frame = this.currentFrame,
                    val = this.visit(node.val);
                frame.addToMapping(node.name, val);
                return val;
            },
            visitThrow: function(node) {
                var frame = this.currentFrame,
                    exceptionObj = this.visit(node.expr);
                throw exceptionObj;
            },
            visitTryCatchFinally: function(node) {
                var frame = this.currentFrame, result;
                try {
                    result = this.visit(node.trySeq);
                } catch(e) {
                    frame.addToMapping(node.err.name, e);
                    result = this.visit(node.catchSeq);
                } finally {
                    if (node.finallySeq.isVariable && node.finallySeq.name == 'undefined') {
                        // do nothing, no finally block
                    } else {
                        result = this.visit(node.finallySeq);
                    }
                }
                return result;
            },
            visitFunction: function(node) {
                var frame = this.currentFrame;
                if (Object.isString(node.name)) frame.addToMapping(node.name, node);
                if (!node.prototype) node.prototype = {};
                node.lexicalScope = frame;
                return node.asFunction();
            },
            visitObjectLiteral: function(node) {
                var frame = this.currentFrame, obj = {};
                for (var i = 0; i < node.properties.length; i++) {
                    var name = node.properties[i].name,
                        prop = this.visit(node.properties[i].property);
                    obj[name] = prop;
                }
                return obj;
            },
            visitObjProperty: function(node) {
                throw new Error('?????');
            },
            visitSwitch: function(node) {
                var frame = this.currentFrame,
                    val = this.visit(node.expr),
                    caseMatched = false, result;
                for (var i = 0; i < node.cases.length; i++) {
                    node.cases[i].prevCaseMatched = caseMatched;
                    node.cases[i].switchValue = val;
                    result = this.visit(node.cases[i]);
                    caseMatched = result !== undefined; // FIXME what when case returns undefined?
                    if (frame.breakTriggered) {
                        frame.stopBreak();
                        break;
                    };
                }
                return result;
            },
            visitCase: function(node) {
                return node.prevCaseMatched || node.switchValue == this.visit(node.condExpr) ?
                    this.visit(node.thenExpr) : undefined;
            },
            visitDefault: function(node) {
                return node.prevCaseMatched ? undefined : this.visit(node.defaultExpr);
            },
            visitRegex: function(node) {
                return new RegExp(node.exprString, node.flags);
            }

        });

    users.timfelgentreff.jsinterpreter.Node.addMethods('interpretation', {
        position: function() {
            return this.pos[0] + "-" + this.pos[1];
        },
        startInterpretation: function(optMapping) {
            var interpreter = new users.timfelgentreff.jsinterpreter.InterpreterVisitor();
            return interpreter.run(this, optMapping);
        },
        toSource: function() { return this.toString(); },
        parentSource: function() {
            if (this.source) return this.source;
            if (this.hasParent()) return this.getParent().parentSource();
            return this.toSource();
        }
    });

    users.timfelgentreff.jsinterpreter.Variable.addMethods('interpretation', {
        set: function(value, frame, interpreter) {
            var search = frame.findFrame(this.name),
                scope = search ? search.frame : users.timfelgentreff.jsinterpreter.Interpreter.Frame.global();
            return scope.addToMapping(this.name, value);
        }
    });

    users.timfelgentreff.jsinterpreter.GetSlot.addMethods('interpretation', {
        set: function(value, frame, interpreter) {
            var obj = interpreter.visit(this.obj),
                name = interpreter.visit(this.slotName);
            return obj[name] = value;
        }
    });

    users.timfelgentreff.jsinterpreter.Function.addMethods('interpretation', {
            position: function() {
                //return (this.pos[1] - 1) + "-" + this.pos[1];
                return this.pos[0] + "-" + this.pos[1];
            },
            basicApply: function(frame) {
                var interpreter = new users.timfelgentreff.jsinterpreter.InterpreterVisitor();
                try {
                    users.timfelgentreff.jsinterpreter.Interpreter.Frame.top = frame;
                    // important: users.timfelgentreff.jsinterpreter.Interpreter.Frame.top is only valid
                    // during the native VM-execution time. When the execution
                    // of the interpreter is stopped, there is no top frame anymore.
                    return interpreter.runWithFrame(this.body, frame);
                } finally {
                    users.timfelgentreff.jsinterpreter.Interpreter.Frame.top = null;
                }
            },
            apply: function(thisObj, argValues, startHalted) {
                var calledFunction = this.asFunction(),
                    mapping = Object.extend({}, calledFunction.getVarMapping()),
                    argNames = this.argNames();
                // work-around for $super
                if (mapping["$super"] && argNames[0] == "$super") {
                    argValues.unshift(mapping["$super"]);
                }
                var scope = this.lexicalScope ? this.lexicalScope : users.timfelgentreff.jsinterpreter.Interpreter.Frame.global(),
                    newFrame = scope.newScope(calledFunction, mapping);
                if (thisObj !== undefined) newFrame.setThis(thisObj);
                newFrame.setArguments(argValues);
                newFrame.setCaller(users.timfelgentreff.jsinterpreter.Interpreter.Frame.top);
                if (startHalted) newFrame.breakAtFirstStatement();
                return this.basicApply(newFrame);
            },
            asFunction: function(optFunc) {
                if (this._chachedFunction) return this._chachedFunction;
                var that = this;
                function fn(/*args*/) {
                    return that.apply(this, Array.from(arguments));
                };
                fn.methodName = this.name();
                fn.forInterpretation = function() { return fn; };
                fn.ast = function() { return that; };
                fn.startHalted = function() {
                    return function(/*args*/) { return that.apply(this, Array.from(arguments), true); }
                };
                fn.evaluatedSource = function() { return that.parentSource(); };
                if (optFunc) {
                    fn.source = optFunc.toSource();
                    fn.varMapping = optFunc.getVarMapping();
                    fn.prototype = optFunc.prototype;
                    if (optFunc.declaredClass) fn.declaredClass = optFunc.declaredClass;
                    if (optFunc.methodName) fn.methodName = optFunc.methodName;
                    if (optFunc.sourceModule) fn.sourceModule = optFunc.sourceModule;
                    if (optFunc.declaredObject) fn.declaredObject = optFunc.declaredObject;
                    if (optFunc.name) fn.methodName = optFunc.name;
                }
                return this._chachedFunction = fn;
            }
        },
        'continued interpretation', {
            resume: function(frame) {
                return this.basicApply(frame);
            }
        });

    Object.extend(users.timfelgentreff.jsinterpreter, {
        halt: function(frame) {
            // overwrite this function, e.g. to open a debugger
            return false; // return true to actually stop execution
        },
        doWithHalt: function(func, halt) {
            var oldHalt = users.timfelgentreff.jsinterpreter.halt;
            users.timfelgentreff.jsinterpreter.halt = halt || Functions.True;
            try {
                func();
            } finally {
                users.timfelgentreff.jsinterpreter.halt = oldHalt;
            }
        }
    });

    users.timfelgentreff.jsinterpreter.Visitor.subclass('users.timfelgentreff.jsinterpreter.ContainsDebuggerVisitor',
        'visiting', {
            visitSequence: function(node) {
                for (var i = 0; i < node.children.length; i++) {
                    if (this.visit(node.children[i])) {
                        return true;
                    }
                }
                return false;
            },
            visitNumber: function(node) {
                return false;
            },
            visitString: function(node) {
                return false;
            },
            visitCond: function(node) {
                return this.visit(node.condExpr) || this.visit(node.trueExpr) || this.visit(node.falseExpr);
            },
            visitIf: function(node) {
                return this.visitCond(node);
            },
            visitWhile: function(node) {
                return this.visit(node.condExpr) || this.visit(node.body);
            },
            visitDoWhile: function(node) {
                return this.visit(node.body) || this.visit(node.condExpr);
            },
            visitFor: function(node) {
                return this.visit(node.init) || this.visit(node.condExpr) || this.visit(node.body) || this.visit(node.upd);
            },
            visitForIn: function(node) {
                return this.visit(node.obj) || this.visit(node.body);
            },
            visitSet: function(node) {
                return this.visit(node.left) || this.visit(node.right);
            },
            visitModifyingSet: function(node) {
                return this.visit(node.left) || this.visit(node.right);
            },
            visitBinaryOp: function(node) {
                return this.visit(node.left) || this.visit(node.right);
            },
            visitUnaryOp: function(node) {
                return this.visit(node.expr);
            },
            visitPreOp: function(node) {
                return this.visit(node.expr);
            },
            visitPostOp: function(node) {
                return this.visit(node.expr);
            },
            visitThis: function(node) {
                return false;
            },
            visitVariable: function(node) {
                return false;
            },
            visitGetSlot: function(node) {
                return false;
            },
            visitBreak: function(node) {
                return false;
            },
            visitDebugger: function(node) {
                return true;
            },
            visitContinue: function(node) {
                return false;
            },
            visitArrayLiteral: function(node) {
                for (var i = 0; i < node.elements.length; i++) {
                    if (this.visit(node.elements[i])) {
                        return true;
                    }
                }
                return false;
            },
            visitReturn: function(node) {
                return this.visit(node.expr);
            },
            visitWith: function(node) {
                throw new Error('with statement not yet supported');
            },
            visitSend: function(node) {
                if (this.visit(node.recv)) return true;
                for (var i = 0; i < node.args.length; i++) {
                    if (this.visit(node.args[i])) {
                        return true;
                    }
                }
                return false;
            },
            visitCall: function(node) {
                if (this.visit(node.fn)) return true;
                for (var i = 0; i < node.args.length; i++) {
                    if (this.visit(node.args[i])) {
                        return true;
                    }
                }
                return false;
            },
            visitNew: function(node) {
                return this.visit(node.clsExpr);
            },
            visitVarDeclaration: function(node) {
                return this.visit(node.val);
            },
            visitThrow: function(node) {
                return this.visit(node.expr);
            },
            visitTryCatchFinally: function(node) {
                return this.visit(node.trySeq) || this.visit(node.catchSeq) || this.visit(node.finallySeq);
            },
            visitFunction: function(node) {
                return this.visit(node.body);
            },
            visitObjectLiteral: function(node) {
                for (var i = 0; i < node.properties.length; i++) {
                    if (this.visit(node.properties[i].property)) {
                        return true;
                    }
                }
                return false;
            },
            visitObjProperty: function(node) {
                return false;
            },
            visitSwitch: function(node) {
                if (this.visit(node.expr)) {
                    return true;
                }
                for (var i = 0; i < node.cases.length; i++) {
                    if (this.visit(node.cases[i])) {
                        return true;
                    }
                }
                return false;
            },
            visitCase: function(node) {
                return this.visit(node.condExpr) || this.visit(node.thenExpr);
            },
            visitDefault: function(node) {
                return this.visit(node.defaultExpr);
            },
            visitRegex: function(node) {
                return false;
            }
        });

    Function.addMethods(
        'ast', {
            evaluatedSource: function() {
                return this.toSource();
            },
            ast: function() {
                if (this._cachedAst) return this._cachedAst;
                var parseResult = users.timfelgentreff.jsinterpreter.Parser.parse(this.toSource(), 'topLevel');
                if (!parseResult || Object.isString(parseResult)) return parseResult;
                parseResult = parseResult.children[0];
                if (parseResult.isVarDeclaration && parseResult.val.isFunction) {
                    return this._cachedAst = parseResult.val;
                }
                return this._cachedAst = parseResult;
            }
        },
        'debugging', {
            forInterpretation: function(optMapping) {
                var funcAst = this.ast();
                if (!funcAst.lexicalScope && this._cachedScope) {
                    funcAst.lexicalScope = users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromScope(this._cachedScope);
                }
                return funcAst.asFunction(this);
            },
            containsDebugger: function() {
                return new users.timfelgentreff.jsinterpreter.ContainsDebuggerVisitor().visit(this.ast());
            }
        });

}); // end of module














module('users.timfelgentreff.babelsberg.core_ext').requires().toRun(function() {

    Function.addMethods({
        varMap: function(obj) {
            this.varMapping = obj;
            return this;
        },
        recursionGuard: function(obj, key) {
            if (!obj[key]) {
                try {
                    obj[key] = true;
                    this();
                } finally {
                    obj[key] = false;
                }
            }
        }
    });

    Object.subclass('Guard', {
        initialize: function() {
            this.counter = 0;
            this.lastCall = {};
            this.cachedResult;
            return this;
        },
        call: function(id, func) {
            if (this.counter !== this.lastCall[id]) {
                this.cachedResult = func();
                this.lastCall[id] = this.counter;
            }
            return this.cachedResult;
        },
        tick: function(arg) {
            if (arg) {
                this.counter = arg;
            } else {
                this.counter++;
            }
        }
    });

    Object.extend(Strings, {
        safeToString: function(obj) {
            var toS = Object.prototype.toString,
                str;
            try {
                if (obj.toString) str = obj.toString();
            } catch (e) {
                str = toS.apply(obj);
            }
            return str;
        }
    });

}); // end of module













module('users.timfelgentreff.babelsberg.constraintinterpreter').requires(
    'users.timfelgentreff.jsinterpreter.Interpreter',
    'cop.Layers',
    'users.timfelgentreff.babelsberg.cassowary_ext',
    'users.timfelgentreff.babelsberg.deltablue_ext',
    'users.timfelgentreff.babelsberg.csp_ext',
    'users.timfelgentreff.babelsberg.core_ext',
    'users.timfelgentreff.babelsberg.src_transform',
    'users.timfelgentreff.babelsberg.babelsberg-lively',
    'users.timfelgentreff.sutherland.relax_bbb').
toRun(function() {

    /**
     * The interface to create, maintain and remove constraints.
     * @class Babelsberg
     */
    Object.subclass('Babelsberg', {

        initialize: function() {
            this.defaultSolvers = [];
            this.callbacks = [];
        },

        isConstraintObject: true,

        /**
         * Removes the listener on the given property of the given object.
         * @function Babelsberg#unconstrain
         * @public
         * @param {Object} obj The object whose property should be unconstrained.
         * @param {string} accessor The name of the property to be unconstrained.
         */
        unconstrain: function(obj, accessor) {
            if (!obj) return;
            var cvar = ConstrainedVariable.findConstraintVariableFor(obj, accessor);
            if (!cvar) return;
            var cGetter = obj.__lookupGetter__(accessor),
                cSetter = obj.__lookupSetter__(accessor);
            if (!cGetter && !cSetter) {
                return;
            }
            if (!cGetter.isConstraintAccessor || !cSetter.isConstraintAccessor) {
                throw 'too many accessors - ' +
                'unconstrain only works for the very simple case now';
            }
            ConstrainedVariable.deleteConstraintVariableFor(obj, accessor);
            var newName = cvar.newIvarname;
            var existingSetter = obj.__lookupSetter__(newName),
                existingGetter = obj.__lookupGetter__(newName);
            if (existingGetter) {
                obj.__defineGetter__(accessor, existingGetter);
            }
            if (existingSetter) {
                obj.__defineSetter__(accessor, existingSetter);
            }
            if (!existingSetter || !existingGetter) {
                delete obj[accessor];
            }
            obj[accessor] = obj[newName];
            delete obj[newName];

            // recursive unconstrain
            var child = obj[accessor];
            bbb.unconstrainAll(child);
        },

        /**
         * Removes all listener on the given object.
         * @function Babelsberg#unconstrainAll
         * @public
         * @param {Object} obj The object whose property should be unconstrained.
         */
        unconstrainAll: function(obj) {
            if (obj && obj instanceof Object) {
                Object.keys(obj).each(function(property, index) {
                    var cvar = ConstrainedVariable.findConstraintVariableFor(
                        obj,
                        property
                    );
                    if (!cvar) return;
                    var cGetter = obj.__lookupGetter__(property),
                        cSetter = obj.__lookupSetter__(property);
                    if (!cGetter && !cSetter) return;
                    if (!cGetter.isConstraintAccessor || !cSetter.isConstraintAccessor) {
                        return;
                    }

                    bbb.unconstrain(obj, property);
                });
            }

        },

        /**
         * Some solvers, like Cassowary and DeltaBlue, handle assignments
         * by using temporary constraint that reflects the
         * assignments. The creation and deletion of these constraints can
         * be costly if assignments are done frequently. The edit function
         * is one way to deal with this issue. Use it on attributes that
         * are frequently modified for better performance.
         * @function Babelsberg#edit
         * @public
         * @param {Object} obj An object that is modified quite often.
         * @param {string[]} accessors The property names of the properties that are modified.
         * @return {function} {
     *    A callback that can be used to assign new values to the given properties.
     * }
         * @example Example usage of bbb.edit
         * var s = new DBPlanner(),
         *     obj = {int: 42, str: "42"};
         *
         * // Keep the attributes 'str' and 'int' in sync.
         * bbb.always({
     *     solver: deltablue,
     *     ctx: {
     *         obj: obj
     *     }, methods: function() {
     *         obj.int.formula([obj.str], function (str) { return parseInt(str); });
     *         obj.str.formula([obj.int], function (int) { return int + ""; })
     *     }
     * }, function () {
     *     return obj.int + "" === obj.str;
     * });
         *
         * // Create an edit constraint for frequent assignments on obj.int.
         * var callback = bbb.edit(obj, ["int"]);
         * // Assign 17 as the new value of obj.int. Constraints are solved automatically.
         * callback([17]);
         */
        edit: function(obj, accessors) {
            var extVars = {},
                cVars = {},
                extConstraints = [],
                solvers = [],
                callback = function(newObj) {
                    if (!newObj) { // end-of-edit
                        for (var prop in extVars) {
                            extVars[prop].each(function(evar) {
                                evar.finishEdit();
                            });
                        }
                        solvers.invoke('endEdit');
                    } else {
                        var newEditConstants = newObj;
                        if (!Object.isArray(newObj)) {
                            newEditConstants = accessors.map(function(accessor) {
                                return newObj[accessor];
                            });
                        }
                        solvers.invoke('resolveArray', newEditConstants);
                        accessors.each(function(a) {
                            cVars[a].suggestValue(cVars[a].externalValue);
                            // extVars[a] = extVars[a]; // set the value,
                            // propagates change to other property
                            // accessors calls the setters does not
                            // recurse into solvers, because they have
                            // already adopted the correct value
                        });
                    }
                };

            accessors.each(function(accessor) {
                var cvar = ConstrainedVariable.findConstraintVariableFor(obj, accessor);
                if (!cvar) {
                    throw 'Cannot edit ' + obj + '["' + accessor +
                    '"], because it isn\'t constrained';
                }
                var evars = Properties.values(cvar._externalVariables);
                if (evars.compact().length < evars.length) {
                    throw 'Cannot edit ' + obj + '["' + accessor +
                    '"], because it is in a recalculate relation';
                }
                var hasEditSolver = cvar.solvers.any(function(s) {
                    return !Object.isFunction(s.beginEdit);
                });
                if (hasEditSolver) {
                    throw 'Cannot edit ' + obj + '["' + accessor +
                    '"], because it is in a no-edit solver';
                }
                cVars[accessor] = cvar;
                extVars[accessor] = evars;
                solvers = solvers.concat(cvar.solvers).uniq();
                evars.each(function(evar) {
                    evar.prepareEdit();
                });
            });

            solvers.invoke('beginEdit');
            return callback;
        },

        /**
         * Marks the given object as readonly. This functionality is only
         * supported for some solvers.
         * @function Babelsberg#readonly
         * @public
         * @param {Object} obj The object that should not be modified.
         * @example Example usage of bbb.readonly
         * var s = new ClSimplexSolver(),
         *     pt = {x: 1, y: 2, z: 3};
         *
         * // The x and y coordinate of the point should sum up to its z coordinate.
         * // Cassowary is not allowed to change the value of pt.y in order to
         * // fulfill this constraint.
         * always: { solver: s
     *     pt.x + bbb.readonly(pt.y) == pt.z
     * }
         *
         * // This assignment cannot modify pt.y, but rather changes pt.z.
         * pt.x = 4;
         */
        readonly: function(obj) {
            if (obj.isConstraintObject) {
                obj.setReadonly(true);
            } else {
                if (Constraint.current && Constraint.current.solver) {
                    Properties.own(obj).each(function(ea) {
                        var cvar = ConstrainedVariable.newConstraintVariableFor(obj, ea);
                        cvar.addToConstraint(Constraint.current);
                        cvar.ensureExternalVariableFor(Constraint.current.solver);
                        if (cvar.isSolveable()) {
                            bbb.readonly(cvar.externalVariables(Constraint.current.solver));
                        }
                    });
                }
            }
            return obj;
        },

        /**
         * Creates a constraint equivalent to the given function.
         * @function Babelsberg#always
         * @public
         * @param {Object} opts An options object to configure the constraint construction.
         * @param {Object} opts.ctx The local scope in which the given function is executed.
         * @param {Object} [opts.solver] The solver to maintain the constraint.
         * @param {boolean} [opts.allowTests=false]
         *     If true, allows to specify assertions rather than solvable constraints.
         * @param {boolean} [opts.allowUnsolvableOperations=false]
         *     If true, allows the use of operations that are not supported by the solver.
         * @param {boolean} [opts.debugging=false]
         *     If true, calls debugger at certain points during constraint construction.
         * @param {function} func The constraint to be fulfilled.
         */
        always: function(opts, func) {
            var constraint = null,
                solvers = this.chooseSolvers(opts.solver),
                errors = [];

            func.allowTests = (opts.allowTests === true);
            func.allowUnsolvableOperations = (opts.allowUnsolvableOperations === true);
            func.debugging = opts.debugging;
            func.onError = opts.onError;

            solvers.some(function(solver) {
                try {
                    constraint = solver.always(opts, func);
                } catch (e) {
                    errors.push(e);
                    return false;
                }
                try {
                    if (!opts.postponeEnabling) constraint.enable();
                } catch (e) {
                    errors.push(e);
                    constraint.disable();
                    constraint = null;
                    return false;
                }
                return true;
            });

            if (!constraint) {
                if (typeof opts.onError === 'function') {
                    bbb.addCallback(opts.onError, opts.onError.constraint, errors);
                } else {
                    bbb.addCallback(function(e) {
                        e = e || new Error('No solver available!');
                        e.errors = Array.from(arguments);
                        throw e;
                    }, null, errors);
                }
            }
            bbb.processCallbacks();
            return constraint;
        },

        /**
         * Creates a constraint equivalent to the given function through
         * Babelsberg#always, and then disables it immediately
         * @function Babelsberg#once
         * @public
         */
        once: function(opts, func) {
            var constraint = this.always(opts, func);
            constraint.disable();
            return constraint;
        },

        chooseSolvers: function(optSolver) {
            if (optSolver) {
                return [optSolver];
            } else if (this.defaultSolver) {
                return [this.defaultSolver];
            } else if (this.defaultSolvers.length > 0) {
                return this.defaultSolvers;
            } else {
                return [];
                // throw new Error('Must pass a solver, or set defaultSolver.');
            }
        },

        addCallback: function(func, context, args) {
            this.callbacks.push({
                func: func,
                context: context,
                args: args || []
            });
        },

        processCallbacks: function() {
            (function() {
                while (bbb.callbacks.length > 0) {
                    var cb = bbb.callbacks.shift();
                    cb.func.apply(cb.context, cb.args);
                }
            }).recursionGuard(bbb, 'isProcessingCallbacks');
        }
    });

    Object.extend(Global, {
        /**
         * A globally accessible instance of {@link Babelsberg}
         * @global
         */
        bbb: new Babelsberg()
    });

    users.timfelgentreff.jsinterpreter.Send.addMethods({
        get args() {
            return this._$args || [];
        },

        set args(value) {
            this._$args = value;
        }
    });

    cop.create('ConstraintConstructionLayer').
    refineObject(users.timfelgentreff.jsinterpreter, {
        get InterpreterVisitor() {
            return ConstraintInterpreterVisitor;
        }
    }).refineClass(users.timfelgentreff.jsinterpreter.Send, {
        asFunction: function(optFunc) {
            var initializer = optFunc.prototype.initialize.ast().asFunction();
            initializer.original = optFunc;
            return initializer;
        }
    }).refineClass(users.timfelgentreff.jsinterpreter.GetSlot, {
        set: function(value, frame, interpreter) {
            var obj = interpreter.visit(this.obj),
                name = interpreter.visit(this.slotName);
            if (obj === Global || (obj instanceof lively.Module)) {
                return obj[name] = value;
            }
            if (obj && obj.isConstraintObject) {
                obj = this.getConstraintObjectValue(obj);
            }

            obj[name] = value;
            cvar = ConstrainedVariable.newConstraintVariableFor(obj, name);
            if (Constraint.current) {
                cvar.ensureExternalVariableFor(Constraint.current.solver);
                cvar.addToConstraint(Constraint.current);
                if (cvar.isSolveable()) {
                    Constraint.current.addPrimitiveConstraint(
                        cvar.externalVariable.cnEquals(value)
                    );
                }
            }
        }
    });

    /**
     * Represents an invariant.
     * @class Constraint
     */
    Object.subclass('Constraint', {
        initialize: function(predicate, solver) {
            var constraintObject;
            this._enabled = false;
            this._predicate = predicate;
            if (typeof predicate.onError === 'function') {
                this.onError = predicate.onError;
                this.onError.constraint = this;
            }
            this.constraintobjects = [];
            this.constraintvariables = [];
            this.solver = solver;

            // FIXME: this global state is ugly
            try {
                Constraint.current = this;
                constraintObject = cop.withLayers([ConstraintConstructionLayer], function() {
                    return predicate.forInterpretation().apply(undefined, []);
                });
            } finally {
                Constraint.current = null;
            }
            this.addPrimitiveConstraint(constraintObject);
        },
        addPrimitiveConstraint: function(obj) {
            if (typeof(obj) != 'undefined' && !this.constraintobjects.include(obj)) {
                if (!obj.enable) this.haltIfDebugging();
                this.constraintobjects.push(obj);
            }
        },
        addConstraintVariable: function(v) {
            if (v && !this.constraintvariables.include(v)) {
                this.constraintvariables.push(v);
            }
        },
        get predicate() {
            return this._predicate;
        },
        get allowUnsolvableOperations() {
            this.haltIfDebugging();
            return !!this.predicate.allowUnsolvableOperations;
        },
        haltIfDebugging: function() {
            if (this.predicate.debugging) debugger;
        },
        get allowTests() {
            this.haltIfDebugging();
            return !!this.predicate.allowTests;
        },

        get priority() {
            return this._priority;
        },

        set priority(value) {
            var enabled = this._enabled;
            if (enabled) {
                this.disable();
            }
            this._priority = value;
            if (enabled) {
                this.enable();
            }
        },

        get value() {
            return this.constraintobjects.last();
        },

        /**
         * Enables this constraint. This is done automatically after
         * constraint construction by most solvers.
         * @function Constraint#enable
         * @public
         */
        enable: function() {
            if (!this._enabled) {
                Constraint.enabledConstraintsGuard.tick();
                this.constraintobjects.each(function(ea) {
                    this.enableConstraintObject(ea);
                }.bind(this));
                if (this.constraintobjects.length === 0) {
                    throw new Error('BUG: No constraintobjects were created.');
                }
                this._enabled = true;
                this.solver.solve();

                this.constraintvariables.each(function(ea) {
                    var value = ea.getValue();
                    if (value != this.storedValue) {
                        // solveForConnectedVariables might eventually
                        // call updateDownstreamExternalVariables, too.
                        // We need this first, however, for the case when
                        // this newly enabled constraint is the new
                        // highest-weight solver
                        ea.updateDownstreamExternalVariables(value);
                        ea.solveForConnectedVariables(value);
                    }
                });
            }
        },

        enableConstraintObject: function(obj, optPriority) {
            if (obj === true) {
                if (this.allowTests) {
                    this.isTest = true;
                    alertOK(
                        'Warning: Constraint expression returned true. ' +
                        'Re-running whenever the value changes'
                    );
                } else {
                    throw new Error(
                        'Constraint expression returned true, but was not marked as test. ' +
                        'If you expected this to be solveable, check that there are ' +
                        'no operations in this that cannot be solved by the selected ' +
                        "solver (e.g. Cassowary does not support `<', only `<='). " +
                        'Otherwise, if you think this is ok, you must pass ' +
                        "`allowTests: true' as option to the constraint."
                    );
                }
            } else if (obj === false) {
                if (!this.allowFailing) {
                    throw new Error(
                        'Constraint expression returned false, no solver available to fix it'
                    );
                }
            } else if (!obj.enable) {
                var e = new Error(
                    'Constraint expression returned an ' +
                    'object that does not respond to #enable'
                );
                e.obj = obj;
                e.constraint = this;
                throw e;
            } else {
                obj.solver = this.solver; // XXX: Bit of a hack, should really write it so
                                          // this gets passed through from the variables
                obj.enable(optPriority || this._priority);
            }
        },

        /**
         * Disables this constraint. It is not further maintained until
         * its {@link Constraint#enable|re-enabling}.
         * @function Constraint#disable
         * @public
         */
        disable: function() {
            if (this._enabled) {
                Constraint.enabledConstraintsGuard.tick();
                this.constraintobjects.each(function(ea) {
                    try {ea.disable()} catch (e) {}
                });
                this._enabled = false;
            }
        },

        recalculate: function() {
            if (!this._enabled) return;
            // TODO: Fix this so it uses the split-stay result, i.e. just
            // increase the stay for the newly assigned value
            if (this.isTest && !this.solver) {
                debugger;
                // TODO: If this is a test and there is no solver,
                // we can safely just run this as an assert
            }

            var enabled = this._enabled,
                cvars = this.constraintvariables,
                self = this,
                assignments;
            if (enabled) {
                this.disable();
            }
            this.initialize(this.predicate, this.solver);

            cvars.select(function(ea) {
                // all the cvars that are not in this constraint anymore
                return !this.constraintvariables.include(ea) && ea.isSolveable();
            }.bind(this)).each(function(ea) {
                return ea.externalVariable.removeStay();
            });

            if (enabled) {
                assignments = this.constraintvariables.select(function(ea) {
                    // all the cvars that are new after this recalculation
                    return !cvars.include(ea) && ea.isSolveable();
                }).collect(function(ea) {
                    // add a required constraint for the new variable
                    // to keep its new value, to have the same semantics
                    // as for direct assignment
                    return ea.externalVariable.cnIdentical(ea.getValue());
                });

                assignments.each(function(ea) {
                    try {
                        self.enableConstraintObject(ea);
                    } catch (_) {
                        // if the assignment cannot be completely satisfied, make it strong
                        self.enableConstraintObject(ea, self.solver.strength.strong);
                    }
                });

                try {
                    // try to enable this constraints with (some) required assignments
                    this.enable();
                } catch (_) {
                    // if it fails, disable, make all the assignments only strong, re-enable
                    this._enabled = true; // force disable to run
                    this.disable();
                    assignments.invoke('disable');
                    assignments.invoke(
                        'enable',
                        this.solver.strength && this.solver.strength.strong
                    );
                    this.enable();
                } finally {
                    assignments.invoke('disable');
                }
            }
        }
    });
    Object.extend(Constraint, {
        set current(p) {
            if (!this._previous) {
                this._previous = [];
            }
            if (p === null) {
                if (this._previous.length > 0) {
                    this._current = this._previous.pop();
                } else {
                    this._current = null;
                }
                return;
            }
            if (this._current) {
                this._previous.push(this._current);
            }
            this._current = p;
        },

        get current() {
            return this._current;
        },

        enabledConstraintsGuard: new Guard()
    });

    Object.subclass('ConstrainedVariable', {
        initialize: function(obj, ivarname, optParentCVar) {
            this.__uuid__ = Strings.newUUID();
            this.obj = obj;
            this.ivarname = ivarname;
            this.newIvarname = '$1$1' + ivarname;
            this.parentConstrainedVariable = optParentCVar;
            this._constraints = [];
            this._externalVariables = {};
            this._isSolveable = false;
            this._definingSolver = null;
            var value = obj[ivarname],
                solver = this.currentSolver;

            dbgOn(!solver);
            this.ensureExternalVariableFor(solver);

            this.wrapProperties(obj, solver);
        },
        wrapProperties: function(obj, solver) {
            var existingSetter = obj.__lookupSetter__(this.ivarname),
                existingGetter = obj.__lookupGetter__(this.ivarname);

            if (existingGetter && !existingGetter.isConstraintAccessor) {
                obj.__defineGetter__(this.newIvarname, existingGetter);
            }
            if (existingSetter && !existingSetter.isConstraintAccessor) {
                obj.__defineSetter__(this.newIvarname, existingSetter);
            }
            // assign old value to new slot
            if (!existingGetter &&
                !existingSetter &&
                this.obj.hasOwnProperty(this.ivarname)) {
                this.setValue(obj[this.ivarname]);
            }

            try {
                obj.__defineGetter__(this.ivarname, function() {
                    return this.getValue();
                }.bind(this));
            } catch (e) { /* Firefox raises for Array.length */ }
            var newGetter = obj.__lookupGetter__(this.ivarname);
            if (!newGetter) {
                // Chrome silently ignores __defineGetter__ for Array.length
                this.externalVariables(solver, null);
                return;
            }

            obj.__defineSetter__(this.ivarname, function(newValue) {
                return this.suggestValue(newValue, 'source');
            }.bind(this));
            var newSetter = obj.__lookupSetter__(this.ivarname);

            if (newSetter) newSetter.isConstraintAccessor = true;
            if (newGetter) newGetter.isConstraintAccessor = true;
        },
        ensureExternalVariableFor: function(solver) {
            var eVar = this.externalVariables(solver),
                value = this.obj[this.ivarname];

            if (!eVar && eVar !== null) { // don't try to create an external variable twice
                this.externalVariables(
                    solver,
                    solver.constraintVariableFor(value, this.ivarname, this)
                );
            }
        },



        get currentSolver() {
            if (Constraint.current) {
                return Constraint.current.solver;
            } else {
                return null;
            }
        },

        suggestValue: function(value, source, force) {
            if (ConstrainedVariable.$$callingSetters) {
                return value;
            } else if (force || value !== this.storedValue) {
                var callSetters = !ConstrainedVariable.$$optionalSetters,
                    oldValue = this.storedValue,
                    solver = this.definingSolver;

                ConstrainedVariable.$$optionalSetters =
                    ConstrainedVariable.$$optionalSetters || [];

                try {
                    this.solveForPrimarySolver(value, oldValue, solver, source, force);
                    this.solveForConnectedVariables(value, oldValue, solver, source, force);
                    this.findAndOptionallyCallSetters(callSetters);
                } catch (e) {
                    if (this.getValue() !== oldValue) {
                        throw 'solving failed, but variable changed to ' +
                        this.getValue() + ' from ' + oldValue;
                    }
                    this.addErrorCallback(e);
                } finally {
                    this.ensureClearSetters(callSetters);
                    if (solver && source) {
                        this.bumpSolverWeight(solver, 'down');
                    }
                }
                bbb.processCallbacks();
            }
            return value;
        },

        solveForPrimarySolver: function(value, priorValue, solver, source) {
            if (this.isSolveable()) {
                (function() {
                    var wasReadonly = false,
                        // recursionGuard per externalVariable?
                        eVar = this.definingExternalVariable;
                    try {
                        if (solver && source) {
                            this.bumpSolverWeight(solver, 'up');
                        }
                        wasReadonly = eVar.isReadonly();
                        eVar.setReadonly(false);
                        eVar.suggestValue(value);
                    } finally {
                        eVar.setReadonly(wasReadonly);
                    }
                }).bind(this).recursionGuard(
                    ConstrainedVariable.isSuggestingValue,
                    this.__uuid__
                );
            }
        },

        bumpSolverWeight: function(solver, direction) {
            if (direction == 'up') {
                solver.weight += 987654321; // XXX Magic Number
            } else {
                solver.weight -= 987654321;
            }
            this.findTransitiveConnectedVariables().each(function(cvar) {
                cvar.setDownstreamReadonly(direction == 'up');
            });
        },

        solveForConnectedVariables: function(value, priorValue, solver, source, force) {
            if (force || value !== this.storedValue) {
                (function() {
                    try {
                        // this.setValue(value);
                        this.updateDownstreamVariables(value, solver);
                        this.updateConnectedVariables(value, solver);
                    } catch (e) {
                        if (source) {
                            // is freeing the recursionGuard here necessary?
                            this.$$isStoring = false;
                            this.suggestValue(priorValue, source, 'force');
                        }
                        throw e; // XXX: Lively checks type, so wrap for top-level
                    }
                }).bind(this).recursionGuard(this, '$$isStoring');
            }
        },

        findAndOptionallyCallSetters: function(callSetters) {
            if (this.isSolveable()) {
                var getterSetterPair = this.findOptionalSetter();
                if (getterSetterPair) {
                    ConstrainedVariable.$$optionalSetters.push(
                        getterSetterPair
                    );
                }
            }
            if (callSetters) {
                this.callSetters.recursionGuard(ConstrainedVariable, '$$callingSetters');
            }
        },

        addErrorCallback: function(e) {
            var catchingConstraint = this._constraints.find(function(constraint) {
                return typeof constraint.onError === 'function';
            });
            if (catchingConstraint) {
                bbb.addCallback(catchingConstraint.onError, catchingConstraint, [e]);
            } else {
                throw e;
            }
        },

        callSetters: function() {
            var recvs = [],
                setters = [];
            ConstrainedVariable.$$optionalSetters.each(function(ea) {
                var recvIdx = recvs.indexOf(ea.recv);
                if (recvIdx === -1) {
                    recvIdx = recvs.length;
                    recvs.push(ea.recv);
                }
                setters[recvIdx] = setters[recvIdx] || [];
                // If we have already called this setter for this recv, skip
                if (setters[recvIdx].indexOf(ea.setter) !== -1) return;
                setters[recvIdx].push(ea.setter);
                try {
                    ea.recv[ea.setter](ea.recv[ea.getter]());
                } catch (e) {
                    alert(e);
                }
            });
        },

        findOptionalSetter: function() {
            if (this.setterObj) return this.setterObj;

            if (this.setter) {
                this.setterObj = {recv: this.recv, getter: this.getter, setter: this.setter};
            } else if (this.parentConstrainedVariable) {
                this.setterObj = this.parentConstrainedVariable.findOptionalSetter();
            }
            return this.setterObj;
        },

        ensureClearSetters: function(callSetters) {
            if (callSetters) {
                ConstrainedVariable.$$optionalSetters = null;
            }
        },

        get getter() {
            return this.$getter;
        },
        get recv() {
            return this.$recv;
        },
        set getter(value) {
            this.$getter = value;
            if (this.recv) {
                var setter = value.replace('get', 'set');
                if (Object.isFunction(this.recv[setter])) {
                    this.setter = setter;
                }
            }
        },
        set recv(value) {
            this.$recv = value;
            if (this.getter) {
                var setter = this.getter.replace('get', 'set');
                if (Object.isFunction(value[setter])) {
                    this.setter = setter;
                }
            }
        },
        setDownstreamReadonly: function(bool) {
            if (bool && !this.$$downstreamReadonlyVars) {
                // flushCaches
                var defVar = this.definingExternalVariable;
                this.$$downstreamReadonlyVars = [];
                this.eachExternalVariableDo(function(eVar) {
                    if (eVar !== defVar) {
                        if (!eVar.isReadonly()) {
                            eVar.setReadonly(true);
                            this.$$downstreamReadonlyVars.push(eVar);
                        }
                    }
                }.bind(this));
            } else if (!bool && this.$$downstreamReadonlyVars) {
                this.$$downstreamReadonlyVars.each(function(eVar) {
                    eVar.setReadonly(false);
                }.bind(this));
                this.$$downstreamReadonlyVars = null;
            }
        },
        findTransitiveConnectedVariables: function(ary) {
            return Constraint.enabledConstraintsGuard.call(this.__uuid__, function() {
                return this._findTransitiveConnectedVariables(ary || []);
            }.bind(this));
        },
        _findTransitiveConnectedVariables: function(ary) {
            // XXX soooo slowwww
            var self = this;
            if (ary.indexOf(this) !== -1) return;

            ary.push(this);
            this._constraints.each(function(c) {
                return c.constraintvariables.each(function(cvar) {
                    cvar.findTransitiveConnectedVariables(ary);
                });
            });
            return ary;
        },
        updateConnectedVariables: function() {
            // so slow :(
            var self = this;
            this._constraints.collect(function(c) {
                return c.constraintvariables;
            }).flatten().uniq().each(function(cvar) {
                cvar.suggestValue(cvar.getValue()); // will store and recurse only if needed
            });
        },

        updateDownstreamVariables: function(value) {
            this.updateDownstreamExternalVariables(value);
            this.updateDownstreamUnsolvableVariables(value);
        },

        updateDownstreamExternalVariables: function(value) {
            var defVar = this.definingExternalVariable;
            this.eachExternalVariableDo(function(ea) {
                if (ea !== defVar) {
                    var wasReadonly = ea.isReadonly();
                    ea.setReadonly(false);
                    ea.suggestValue(value);
                    ea.setReadonly(wasReadonly);
                }
            });
        },

        updateDownstreamUnsolvableVariables: function(value) {
            if (!this.isValueClass()) {
                this.recalculateDownstreamConstraints(value);
            } else {
                this.updateValueClassParts(value);
            }
        },

        recalculateDownstreamConstraints: function(value) {
            this.setValue(value);
            this._constraints.each(function(c) {
                var eVar = this.externalVariables(c.solver);
                if (!eVar) {
                    c.recalculate();
                }
            }.bind(this));
        },

        updateValueClassParts: function(value) {
            (function() {
                for (key in this.storedValue[ConstrainedVariable.AttrName]) {
                    var cvar = this.storedValue[ConstrainedVariable.AttrName][key];
                    cvar.suggestValue(value[key]);
                }
            }).bind(this).recursionGuard(this, '$$valueClassUpdate');
        },

        addToConstraint: function(constraint) {
            if (!this._constraints.include(constraint)) {
                this._constraints.push(constraint);
            }
            constraint.addConstraintVariable(this);
        },
        get definingSolver() {
            if (Constraint.current || this._hasMultipleSolvers) {
                // no fast path for variables with multiple solvers for now
                this._definingSolver = null;
                return this._searchDefiningSolver();
            } else if (!this._definingSolver) {
                return this._definingSolver = this._searchDefiningSolver();
            } else {
                return this._definingSolver;
            }
        },
        _searchDefiningSolver: function() {
            var solver = {weight: -1000, fake: true};
            this.eachExternalVariableDo(function(eVar) {
                if (eVar) {
                    if (!solver.fake) {
                        this._hasMultipleSolvers = true;
                    }
                    var s = eVar.__solver__;
                    if (s.weight > solver.weight) {
                        solver = s;
                    }
                }
            }.bind(this));
            return solver;
        },

        get solvers() {
            var solvers = [];
            this.eachExternalVariableDo(function(eVar) {
                if (eVar) {
                    var s = eVar.__solver__;
                    solvers.push(s);
                }
            });
            return solvers.uniq();
        },
        get definingExternalVariable() {
            return this.externalVariables(this.definingSolver);
        },

        isSolveable: function() {
            return Constraint.current ? !!this.externalVariable : this._isSolveable;
        },

        _resetIsSolveable: function() {
            this._isSolveable = !!this.definingExternalVariable;
        },

        isValueClass: function() {
            // TODO: add more value classes
            return !this.isSolveable() &&
                this.storedValue instanceof lively.Point;
            // return false && this.storedValue instanceof lively.Point;
        },

        get storedValue() {
            return this.obj[this.newIvarname];
        },

        get externalValue() {
            var value;
            return this.pvtGetExternalValue(this.externalVariable);
        },

        pvtGetExternalValue: function(evar) {
            if (typeof(evar.value) == 'function') {
                return evar.value();
            } else {
                return evar.value;
            }
        },

        setValue: function(value) {
            this.obj[this.newIvarname] = value;
        },
        eachExternalVariableDo: function(func) {
            func.bind(this);
            for (var key in this._externalVariables) {
                var eVar = this._externalVariables[key];
                if (eVar) { func(eVar); }
            }
        },

        getValue: function() {
            if (this.isSolveable()) {
                return this.externalValue;
            } else {
                return this.storedValue;
            }
        },


        get externalVariable() {
            if (this.currentSolver) {
                return this.externalVariables(this.currentSolver);
            } else {
                return this.definingExternalVariable;
            }
        },
        externalVariables: function(solver, value) {
            if (!solver.__uuid__) {
                solver.__uuid__ = Strings.newUUID();
            }
            if (arguments.length === 1) {
                return this._externalVariables[solver.__uuid__];
            } else {
                if (value) {
                    value.__solver__ = value.__solver__ || solver;
                    if (value.__cvar__ && !(value.__cvar__ === this)) {
                        throw 'Inconsistent external variable. This should not happen!';
                    }
                    value.__cvar__ = this;
                }
                this._externalVariables[solver.__uuid__] = value || null;
                this._resetIsSolveable();
            }
        }
    });

    users.timfelgentreff.jsinterpreter.InterpreterVisitor.
    subclass('ConstraintInterpreterVisitor', {

        binaryExpressionMap: {
            // operation: [method, reverseMethod (or undefined)]
            '+': ['plus', 'plus'],
            '-': ['minus'],
            '*': ['times', 'times'],
            '/': ['divide'],
            '%': ['modulo'],
            '==': ['cnEquals', 'cnEquals'],
            '===': ['cnIdentical', 'cnIdentical'],
            '<=': ['cnLeq', 'cnGeq'],
            '>=': ['cnGeq', 'cnLeq'],
            '<': ['cnLess', 'cnGreater'],
            '>': ['cnGreater', 'cnLess'],
            '||': ['cnOr', 'cnOr'],
            '!=': ['cnNeq', 'cnNeq'],
            '!==': ['cnNotIdentical', 'cnNotIdentical']
        },

        alternativeExpressionsMapTo: {
            '+': '-',
            '<=': '<',
            '>=': '>',
            '==': '==='
        },

        get alternativeExpressionsMap() {
            var map = {};
            Properties.own(this.alternativeExpressionsMapTo).each(function(ea) {
                map[this.alternativeExpressionsMapTo[ea]] = ea;
                map[ea] = this.alternativeExpressionsMapTo[ea];
            }.bind(this));
            return map;
        },



        getConstraintObjectValue: function(o) {
            if (o === undefined || !o.isConstraintObject) return o;
            var value = o.value;
            if (typeof(value) == 'function') {
                return value.apply(o);
            } else {
                return value;
            }
        },
        errorIfUnsolvable: function(op, l, r, res) {
            if (typeof(res) == 'undefined') {
                res = r;
                r = undefined;
            }

            if (!(l.isConstraintObject || (r && r.isConstraintObject)) ||
                Constraint.current.allowUnsolvableOperations) {
                return ((typeof(res) == 'function') ? res() : res);
            } else {
                var msg = '`' + op + "'" + ' not allowed on ' + l,
                    alternative;
                if (r !== undefined) {
                    msg = 'Binary op ' + msg + ' and ' + r;

                    var altOp = this.alternativeExpressionsMap[op];
                    if (altOp) {
                        if (l[this.binaryExpressionMap[altOp][0]] ||
                            r[this.binaryExpressionMap[altOp][1]]) {
                            alternative = altOp;
                        }
                    }
                }
                if (!alternative && Constraint.current.solver.alternativeOperationFor) {
                    alternative = Constraint.current.solver.alternativeOperationFor(op);
                }

                msg += ". If you want to allow this, pass `allowUnsolvableOperations'" +
                    'to the constraint.';
                if (alternative) {
                    msg += ' You can also rewrite the code to use ' +
                        alternative + ' instead.';
                }
                throw new Error(msg);
            }
        },

        visitVariable: function($super, node) {
            return $super(node);
        },

        visitCond: function($super, node) {
            var frame = this.currentFrame,
                condVal = this.visit(node.condExpr);
            if (condVal && condVal.isConstraintObject) {
                debugger;
                var self = this;
                condVal = this.getConstraintObjectValue(condVal);
                if (!condVal) {
                    condVal = cop.withoutLayers([ConstraintConstructionLayer], function() {
                        // XXX: this will cause GetSlot to call $super, so
                        // we don't get constrainded vars
                        return self.visit(node.condExpr);
                    });
                    debugger;
                }
            }
            return condVal ? this.visit(node.trueExpr) : this.visit(node.falseExpr);
        },

        visitUnaryOp: function($super, node) {
            var frame = this.currentFrame,
                val = this.visit(node.expr),
                rVal = this.getConstraintObjectValue(val),
                msg = 'Unary op `' + node.name + "'";

            switch (node.name) {
                case '-':
                    if (val && val.isConstraintObject && val.times) {
                        return val.times(-1);
                    } else {
                        return this.errorIfUnsolvable(msg, val, -rVal);
                    }
                case '!':
                    if (val && val.isConstraintObject && val.not) {
                        return val.not();
                    } else {
                        return !val;
                        // return this.errorIfUnsolvable(msg, val, !val);
                    }
                case '~':
                    return this.errorIfUnsolvable(msg, val, ~rVal);
                case 'typeof':
                    return this.errorIfUnsolvable(msg, val, typeof(rVal));
                default:
                    throw new Error('No semantics for unary op ' + node.name);
            }
        },

        invoke: function($super, node, recv, func, argValues) {
            if (!func && (!recv || !recv.isConstraintObject)) {
                var error = 'No such method: ' + recv + '.' +
                    (node.property && node.property.value);
                alert(error);
                throw new Error(error);
            }
            if (recv && recv.isConstraintObject) {
                if (func) {
                    var forInterpretation = func.forInterpretation;
                    func.forInterpretation = undefined;
                    var prevNode = bbb.currentNode,
                        prevInterp = bbb.currentInterpreter;
                    bbb.currentInterpreter = this;
                    bbb.currentNode = node;
                    try {
                        return cop.withoutLayers([ConstraintConstructionLayer], function() {
                            return $super(node, recv, func, argValues);
                        });
                    } catch (e) {
                        // TIM: send doesNotUnderstand to solver variable?
                        return this.errorIfUnsolvable(
                            (node.property && node.property.value),
                            recv,
                            (function() {
                                var value = this.getConstraintObjectValue(recv);
                                var prop = this.visit(node.property);
                                return this.invoke(node, value, value[prop], argValues);
                            }).bind(this)
                        );
                    } finally {
                        func.forInterpretation = forInterpretation;
                        bbb.currentInterpreter = prevInterp;
                        bbb.currentNode = prevNode;
                    }
                } else {
                    return this.errorIfUnsolvable(
                        (node.property && node.property.value),
                        recv,
                        (function() {
                            var value = this.getConstraintObjectValue(recv);
                            var prop = this.visit(node.property);
                            return this.invoke(node, value, value[prop], argValues);
                        }).bind(this)
                    );
                }
            } else if (func === Date) {
                return new func();
            } else if (recv === Math) {
                if (func === Math.sqrt && argValues[0].pow || argValues[0].sqrt) {
                    if (argValues[0].pow) {
                        return this.invoke(node, argValues[0], argValues[0].pow, [0.5]);
                    } else {
                        return this.invoke(node, argValues[0], argValues[0].sqrt, []);
                    }
                } else if (func === Math.pow && argValues[0].pow) {
                    return this.invoke(node, argValues[0], argValues[0].pow, [argValues[1]]);
                } else if (func === Math.sin && argValues[0].sin) {
                    return this.invoke(node, argValues[0], argValues[0].sin, []);
                } else if (func === Math.cos && argValues[0].cos) {
                    return this.invoke(node, argValues[0], argValues[0].cos, []);
                } else {
                    return $super(node, recv, func,
                        argValues.map(this.getConstraintObjectValue));
                }
            } else {
                return cop.withLayers([ConstraintConstructionLayer], function() {
                    return $super(node, recv, func, argValues);
                });
            }
        },
        visitBinaryOp: function($super, node) {
            var prevNode = bbb.currentNode,
                prevInterp = bbb.currentInterpreter;
            bbb.currentInterpreter = this;
            bbb.currentNode = node;
            try {
                return this.pvtVisitBinaryOp($super, node);
            } finally {
                bbb.currentInterpreter = prevInterp;
                bbb.currentNode = prevNode;
            }
        },

        pvtVisitBinaryOp: function(mySuper, node) {
            var op = node.name;

            // /* Only supported */ if (node.name.match(/[\*\+\/\-]|==|<=|>=|===|<|>|\|\|/)) {
            var leftVal = this.visit(node.left),
                rightVal = this.visit(node.right);

            if (leftVal === undefined) leftVal = 0;
            if (rightVal === undefined) rightVal = 0;

            var rLeftVal = (leftVal && leftVal.isConstraintObject) ?
                    this.getConstraintObjectValue(leftVal) :
                    leftVal,
                rRightVal = (rightVal && rightVal.isConstraintObject) ?
                    this.getConstraintObjectValue(rightVal) :
                    rightVal;
            switch (node.name) {
                case '&&':
                    if (!leftVal) return leftVal;
                    if (leftVal === true || leftVal.isConstraintObject) {
                        if (typeof(leftVal.cnAnd) == 'function') {
                            return leftVal.cnAnd(rightVal);
                        } else {
                            Constraint.current.addPrimitiveConstraint(leftVal);
                        }
                    } else {
                        Constraint.current.haltIfDebugging(); // XXX: Sure?
                    }
                    return rightVal;
                case '-':
                    if (rightVal.isConstraintObject &&
                        rightVal.plus &&
                        Object.isNumber(leftVal)) {
                        return rightVal.plus(-leftVal);
                    } // special case for reversing minus - allowed to fall through to default
                case 'in':
                    if (node.name != '-') {
                        if (leftVal.isConstraintObject && leftVal.cnIn) {
                            return leftVal.cnIn(rightVal);
                        } else if (this.$finiteDomainProperty) {
                            var lV = this.$finiteDomainProperty;
                            delete this.$finiteDomainProperty;
                            if (lV.cnIn) {
                                return lV.cnIn(rightVal);
                            }
                        } // TODO: rightVal->contains if !leftVal.isConstraintObject
                        // special case for reversing minus - allowed to
                        // fall through to default
                    }
                default:
                    var method = this.binaryExpressionMap[node.name];
                    if (method) {
                        if (leftVal && leftVal.isConstraintObject &&
                            typeof(leftVal[method[0]]) == 'function') {
                            return leftVal[method[0]](rightVal);
                        } else if (rightVal && rightVal.isConstraintObject &&
                            typeof(rightVal[method[1]]) == 'function') {
                            return rightVal[method[1]](leftVal);
                        } else {
                            return this.errorIfUnsolvable(
                                op,
                                leftVal,
                                rightVal,
                                eval('rLeftVal ' + node.name + ' rRightVal')
                            );
                        }
                    } else {
                        return this.errorIfUnsolvable(op, leftVal, rightVal, mySuper(node));
                    }
            }
        },


        visitGetSlot: function($super, node) {
            if (cop.currentLayers().indexOf(ConstraintConstructionLayer) === -1) {
                // XXX: See visitCond
                return $super(node);
            }
            var obj = this.visit(node.obj),
                name = this.visit(node.slotName),
                cobj = (obj ? obj[ConstrainedVariable.ThisAttrName] : undefined),
                cvar;
            if (obj === Global ||
                (obj instanceof lively.Module) /*|| (typeof(obj) == "string")*/) {
                return obj[name];
            }
            if (name && name.isConstraintObject) {
                name = this.getConstraintObjectValue(name);
            }
            if (obj && obj.isConstraintObject) {
                if (obj['cn' + name]) {
                    return obj['cn' + name]; // XXX: TODO: Document this
                } else if (name === 'is') {
                    // possibly a finite domain definition
                    this.$finiteDomainProperty = obj;
                } else {
                    cobj = obj.__cvar__;
                    obj = this.getConstraintObjectValue(obj);
                }
            }

            cvar = ConstrainedVariable.newConstraintVariableFor(obj, name, cobj);
            if (Constraint.current) {
                cvar.ensureExternalVariableFor(Constraint.current.solver);
                cvar.addToConstraint(Constraint.current);
            }
            if (cvar && cvar.isSolveable()) {
                return cvar.externalVariable;
            } else {
                var retval = obj[name];
                if (!retval || !retval.isConstraintObject) {
                    var objStr = Strings.safeToString(obj),
                        retStr = Strings.safeToString(retval);
                    console.log(
                        Constraint.current.solver.constructor.name +
                        ' cannot reason about the variable ' + objStr + '[' +
                        name + '], a ' + retStr + ' of type ' +
                        (typeof(retval) == 'object' ?
                            retval.constructor.name :
                            typeof(retval))
                    );
                    Constraint.current.haltIfDebugging();
                }
                if (retval) {
                    switch (typeof(retval)) {
                        case 'object':
                            retval[ConstrainedVariable.ThisAttrName] = cvar;
                            break;
                        case 'number':
                            new Number(retval)[ConstrainedVariable.ThisAttrName] = cvar;
                            break;
                        case 'string':
                            new String(retval)[ConstrainedVariable.ThisAttrName] = cvar;
                            break;
                        case 'boolean': break;
                        default: throw 'Error - ' +
                        'we cannot store the constrained var attribute on ' +
                        retval + ' of type ' + typeof(retval);
                    }
                }
                return retval;
            }
        },
        visitReturn: function($super, node) {
            var retVal = $super(node);
            if (retVal) {
                var cvar = retVal[ConstrainedVariable.ThisAttrName];
                if (retVal.isConstraintObject) {
                    cvar = retVal.__cvar__;
                }
                if (cvar) {
                    var parentFunc = node.parentFunction();
                    if (parentFunc) {
                        cvar.getter = parentFunc.name();
                        cvar.recv = this.currentFrame.mapping['this'];
                    }
                }
            }
            return retVal;
        },



        shouldInterpret: function(frame, func) {
            if (func.sourceModule ===
                Global.users.timfelgentreff.babelsberg.constraintinterpreter) {
                return false;
            }
            if (func.declaredClass === 'Babelsberg') {
                return false;
            }
            var nativeClass = lively.Class.isClass(func) && func.superclass === undefined;
            return (!(this.isNative(func) || nativeClass)) &&
                typeof(func.forInterpretation) == 'function';
        },
        getCurrentScope: function() {
            var scope = {};
            var frame = this.currentFrame;
            while (frame) {
                if (frame.mapping === Global) { // reached global scope
                    return scope;
                }
                for (var key in frame.mapping) {
                    scope[key] = frame.mapping[key];
                }
                var mapping = frame.func.getVarMapping();
                if (mapping) {
                    for (var key in mapping) {
                        scope[key] = mapping[key];
                    }
                }
                frame = frame.getContainingScope();
            }
            return scope;
        },
        newObject: function($super, func) {
            if (func.original) {
                return $super(func.original);
            } else {
                return $super(func);
            }
        }

    });

    ConstrainedVariable.AttrName = '__constrainedVariables__';
    ConstrainedVariable.ThisAttrName = '__lastConstrainedVariableForThis__';
    Object.extend(ConstrainedVariable, {
        findConstraintVariableFor: function(obj, ivarname) {
            var l = obj[ConstrainedVariable.AttrName];
            if (l && l[ivarname]) {
                return l[ivarname];
            } else {
                return null;
            }
        },

        newConstraintVariableFor: function(obj, ivarname, cobj) {
            var cvar = this.findConstraintVariableFor(obj, ivarname);
            if (!cvar) {
                cvar = new ConstrainedVariable(obj, ivarname, cobj);
                obj[ConstrainedVariable.AttrName] = obj[ConstrainedVariable.AttrName] || {};
                obj[ConstrainedVariable.AttrName][ivarname] = cvar;
            }
            return cvar;
        },

        deleteConstraintVariableFor: function(obj, ivarname) {
            var l = obj[ConstrainedVariable.AttrName];
            if (l && l[ivarname]) {
                delete l[ivarname];
            }
        },

        isSuggestingValue: {}
    });

    Object.subclass('PrimitiveCObjectRegistry', {});
    Object.extend(PrimitiveCObjectRegistry, {
        registry: {},

        // stores last seen cvars for objects weakly
        set: function(obj, cobj) {
            PrimitiveCObjectRegistry.registry[obj] = cobj;
        },
        get: function(obj) {
            return PrimitiveCObjectRegistry.registry[obj];
        }
    });

    Number.prototype.__defineGetter__(ConstrainedVariable.ThisAttrName, function() {
        return PrimitiveCObjectRegistry.get(this + 0 /* coerce back into prim */);
    });
    Number.prototype.__defineGetter__(ConstrainedVariable.AttrName, function() {
        return {};
    });
    Number.prototype.__defineSetter__(ConstrainedVariable.ThisAttrName, function(v) {
        PrimitiveCObjectRegistry.set(this + 0 /* coerce back into prim */, v);
    });
    String.prototype.__defineGetter__(ConstrainedVariable.ThisAttrName, function() {
        return PrimitiveCObjectRegistry.get(this + '' /* coerce back into prim */);
    });
    String.prototype.__defineGetter__(ConstrainedVariable.AttrName, function() {
        return {};
    });
    String.prototype.__defineSetter__(ConstrainedVariable.ThisAttrName, function(v) {
        PrimitiveCObjectRegistry.set(this + '' /* coerce back into prim */, v);
    });


});















window.GlobalErrors = [];
window.runcount = 0;

Array.prototype.equals = (function (otherArray) {
    var array = this;
    // Returns true iff each element in `array` is equal (`==`) to its
    // corresponding element in `otherArray`
    var len = array.length;
    if (!otherArray || len !== otherArray.length) return false;
    for (var i = 0; i < len; i++) {
        if (array[i] && otherArray[i] && array[i].equals && otherArray[i].equals) {
            if (!array[i].equals(otherArray[i])) {
                return false;
            } else {
                continue;
            }
        }
        if (array[i] != otherArray[i]) return false;
    }
    return true;
});

Object.subclass("TestCase", {
    assert: function (bool, msg) {
        if (!bool) {
            throw new Error("Assertion failed " + msg);
        }
    },
    assertEquals: function (left, right, msg) {
        if (!left == right) {
            throw new Error("Expected " + left + " and " + right + " to be equal. " + msg);
        }
    },
    assertEqualsEpsilon: function(a, b, msg) {
        var eps = 0.01;
        if (Math.abs(a-b) <= eps) return;
        if (a == b) return;
        this.assert(false, (msg ? msg : '') + ' (' + a +' != ' + b +')');
    },
    runAll: function () {
        for (var l in this) {
            if (l.match(/^test/)) {
                var p = this[l];
                if (typeof(p) == "function") {
                    try {
                        console.log(l);
                        window.runcount += 1;
                        this.setUp && this.setUp();
                        p.apply(this);
                        this.tearDown && this.tearDown();
                    } catch (e) {
                        window.GlobalErrors.push(e.stack);
                        console.error(e);
                    }
                }
            }
        }
    }
});

lively.Point = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
    return this;
};
lively.Point.prototype = {
    addPt: function(p) {
        return new lively.Point(this.x + p.x, this.y + p.y);
    },
    subPt: function(p) {
        return new lively.Point(this.x - p.x, this.y - p.y);
    },
    equals: function(p) {
        return this.eqPt(p);
    },
    eqPt: function(p) {
        return this.x == p.x && this.y == p.y;
    },
    leqPt: function(p) {
        return this.x <= p.x && this.y <= p.y;
    },
    scaleBy: function(scaleX, scaleYOrUndefined) {
        return new lively.Point(this.x * scaleX, this.y * (scaleYOrUndefined||scaleX));
    },
    toString: function() {
        return "Point<" + this.x + ", " + this.y + ">";
    },
    copy: function() {
        return new lively.Point(this.x, this.y);
    }
};

Object.subclass("lively.morphic.Slider", {
    initialize: function(/* ignored */) {
        this.val = 0;
    },
    getValue: function() {
        return this.val;
    },
    setValue: function(val) {
        return this.val = val;
    }
});

Object.subclass("lively.morphic.Text", {
    initialize: function(ignored, string) {
        this.textString = string || "";
    },
    getTextString: function() {
        return this.textString;
    },
    setTextString: function(string) {
        return this.textString = string;
    }
});

lively.pt = window.pt = (function (x, y) {
    return new lively.Point(x,y);
});

window.rect = (function() {});

Object.subclass("Color", {
    initialize: function(r, g, b, a) {
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
        this.a = a || (a === 0 ? 0 : 1);
    },
    equals: function(other) {
        if (!other) return false;
        return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    }
});

Object.extend(Color, {
    rgb: function(r, g, b) {
        return new Color(r/255, g/255, b/255);
    }
});

Object.subclass("lively.morphic.Morph", {
    initialize: function(x, y /* ... ignored */) {
        this.position = pt(x, y);
    },
    setPosition: function(pos) {
        return this.position = pos;
    },
    getPosition: function() {
        return this.position;
    }
});
Object.extend(lively.morphic.Morph, {
    makeRectangle: function(x, y /* ... ignored */) {
        return new lively.morphic.Morph(x, y);
    },
    makeCircle: function(point /* ... ignored */) {
        return new lively.morphic.Morph(point.x, point.y);
    }
});

(function() {
    var temp = window.alert;
    window.alert = function() {
        console.log.apply(console, arguments);
    };
    window.alert.original = temp;
})();

(function(global) {
    global.assert = global.assert || function assert(bool) {
            if(!bool) {
                throw "assertion failed";
            }
        };
})(this);

Object.subclass('lively.ide.BrowserPanel', {
    addMorph: function() {}
});

Object.subclass('lively.morphic.CodeEditor', {
    initialize: function(unused, src) {
        this.textString = src;
        this.owner = new lively.ide.BrowserPanel();
    },
    doSave: function() {
    }
});















(function(exports, global) {
    global["UglifyJS"] = exports;
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    function array_to_hash(a) {
        var ret = Object.create(null);
        for (var i = 0; i < a.length; ++i) ret[a[i]] = true;
        return ret;
    }
    function slice(a, start) {
        return Array.prototype.slice.call(a, start || 0);
    }
    function characters(str) {
        return str.split("");
    }
    function member(name, array) {
        for (var i = array.length; --i >= 0; ) if (array[i] == name) return true;
        return false;
    }
    function find_if(func, array) {
        for (var i = 0, n = array.length; i < n; ++i) {
            if (func(array[i])) return array[i];
        }
    }
    function repeat_string(str, i) {
        if (i <= 0) return "";
        if (i == 1) return str;
        var d = repeat_string(str, i >> 1);
        d += d;
        if (i & 1) d += str;
        return d;
    }
    function DefaultsError(msg, defs) {
        this.msg = msg;
        this.defs = defs;
    }
    function defaults(args, defs, croak) {
        if (args === true) args = {};
        var ret = args || {};
        if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i)) throw new DefaultsError("`" + i + "` is not a supported option", defs);
        for (var i in defs) if (defs.hasOwnProperty(i)) {
            ret[i] = args && args.hasOwnProperty(i) ? args[i] : defs[i];
        }
        return ret;
    }
    function merge(obj, ext) {
        for (var i in ext) if (ext.hasOwnProperty(i)) {
            obj[i] = ext[i];
        }
        return obj;
    }
    function noop() {}
    var MAP = function() {
        function MAP(a, f, backwards) {
            var ret = [], top = [], i;
            function doit() {
                var val = f(a[i], i);
                var is_last = val instanceof Last;
                if (is_last) val = val.v;
                if (val instanceof AtTop) {
                    val = val.v;
                    if (val instanceof Splice) {
                        top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                    } else {
                        top.push(val);
                    }
                } else if (val !== skip) {
                    if (val instanceof Splice) {
                        ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                    } else {
                        ret.push(val);
                    }
                }
                return is_last;
            }
            if (a instanceof Array) {
                if (backwards) {
                    for (i = a.length; --i >= 0; ) if (doit()) break;
                    ret.reverse();
                    top.reverse();
                } else {
                    for (i = 0; i < a.length; ++i) if (doit()) break;
                }
            } else {
                for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
            }
            return top.concat(ret);
        }
        MAP.at_top = function(val) {
            return new AtTop(val);
        };
        MAP.splice = function(val) {
            return new Splice(val);
        };
        MAP.last = function(val) {
            return new Last(val);
        };
        var skip = MAP.skip = {};
        function AtTop(val) {
            this.v = val;
        }
        function Splice(val) {
            this.v = val;
        }
        function Last(val) {
            this.v = val;
        }
        return MAP;
    }();
    function push_uniq(array, el) {
        if (array.indexOf(el) < 0) array.push(el);
    }
    function string_template(text, props) {
        return text.replace(/\{(.+?)\}/g, function(str, p) {
            return props[p];
        });
    }
    function remove(array, el) {
        for (var i = array.length; --i >= 0; ) {
            if (array[i] === el) array.splice(i, 1);
        }
    }
    function mergeSort(array, cmp) {
        if (array.length < 2) return array.slice();
        function merge(a, b) {
            var r = [], ai = 0, bi = 0, i = 0;
            while (ai < a.length && bi < b.length) {
                cmp(a[ai], b[bi]) <= 0 ? r[i++] = a[ai++] : r[i++] = b[bi++];
            }
            if (ai < a.length) r.push.apply(r, a.slice(ai));
            if (bi < b.length) r.push.apply(r, b.slice(bi));
            return r;
        }
        function _ms(a) {
            if (a.length <= 1) return a;
            var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
            left = _ms(left);
            right = _ms(right);
            return merge(left, right);
        }
        return _ms(array);
    }
    function set_difference(a, b) {
        return a.filter(function(el) {
            return b.indexOf(el) < 0;
        });
    }
    function set_intersection(a, b) {
        return a.filter(function(el) {
            return b.indexOf(el) >= 0;
        });
    }
    // this function is taken from Acorn [1], written by Marijn Haverbeke
    // [1] https://github.com/marijnh/acorn
    function makePredicate(words) {
        if (!(words instanceof Array)) words = words.split(" ");
        var f = "", cats = [];
        out: for (var i = 0; i < words.length; ++i) {
            for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
                cats[j].push(words[i]);
                continue out;
            }
            cats.push([ words[i] ]);
        }
        function compareTo(arr) {
            if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
            f += "switch(str){";
            for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
            f += "return true}return false;";
        }
        // When there are more than three length categories, an outer
        // switch first dispatches on the lengths, to save on comparisons.
        if (cats.length > 3) {
            cats.sort(function(a, b) {
                return b.length - a.length;
            });
            f += "switch(str.length){";
            for (var i = 0; i < cats.length; ++i) {
                var cat = cats[i];
                f += "case " + cat[0].length + ":";
                compareTo(cat);
            }
            f += "}";
        } else {
            compareTo(words);
        }
        return new Function("str", f);
    }
    function all(array, predicate) {
        for (var i = array.length; --i >= 0; ) if (!predicate(array[i])) return false;
        return true;
    }
    function Dictionary() {
        this._values = Object.create(null);
        this._size = 0;
    }
    Dictionary.prototype = {
        set: function(key, val) {
            if (!this.has(key)) ++this._size;
            this._values["$" + key] = val;
            return this;
        },
        add: function(key, val) {
            if (this.has(key)) {
                this.get(key).push(val);
            } else {
                this.set(key, [ val ]);
            }
            return this;
        },
        get: function(key) {
            return this._values["$" + key];
        },
        del: function(key) {
            if (this.has(key)) {
                --this._size;
                delete this._values["$" + key];
            }
            return this;
        },
        has: function(key) {
            return "$" + key in this._values;
        },
        each: function(f) {
            for (var i in this._values) f(this._values[i], i.substr(1));
        },
        size: function() {
            return this._size;
        },
        map: function(f) {
            var ret = [];
            for (var i in this._values) ret.push(f(this._values[i], i.substr(1)));
            return ret;
        }
    };
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    function DEFNODE(type, props, methods, base) {
        if (arguments.length < 4) base = AST_Node;
        if (!props) props = []; else props = props.split(/\s+/);
        var self_props = props;
        if (base && base.PROPS) props = props.concat(base.PROPS);
        var code = "return function AST_" + type + "(props){ if (props) { ";
        for (var i = props.length; --i >= 0; ) {
            code += "this." + props[i] + " = props." + props[i] + ";";
        }
        var proto = base && new base();
        if (proto && proto.initialize || methods && methods.initialize) code += "this.initialize();";
        code += "}}";
        var ctor = new Function(code)();
        if (proto) {
            ctor.prototype = proto;
            ctor.BASE = base;
        }
        if (base) base.SUBCLASSES.push(ctor);
        ctor.prototype.CTOR = ctor;
        ctor.PROPS = props || null;
        ctor.SELF_PROPS = self_props;
        ctor.SUBCLASSES = [];
        if (type) {
            ctor.prototype.TYPE = ctor.TYPE = type;
        }
        if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
            if (/^\$/.test(i)) {
                ctor[i.substr(1)] = methods[i];
            } else {
                ctor.prototype[i] = methods[i];
            }
        }
        ctor.DEFMETHOD = function(name, method) {
            this.prototype[name] = method;
        };
        return ctor;
    }
    var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {}, null);
    var AST_Node = DEFNODE("Node", "start end", {
        clone: function() {
            return new this.CTOR(this);
        },
        $documentation: "Base class of all AST nodes",
        $propdoc: {
            start: "[AST_Token] The first token of this node",
            end: "[AST_Token] The last token of this node"
        },
        _walk: function(visitor) {
            return visitor._visit(this);
        },
        walk: function(visitor) {
            return this._walk(visitor);
        }
    }, null);
    AST_Node.warn_function = null;
    AST_Node.warn = function(txt, props) {
        if (AST_Node.warn_function) AST_Node.warn_function(string_template(txt, props));
    };
    /* -----[ statements ]----- */
    var AST_Statement = DEFNODE("Statement", null, {
        $documentation: "Base class of all statements"
    });
    var AST_Debugger = DEFNODE("Debugger", null, {
        $documentation: "Represents a debugger statement"
    }, AST_Statement);
    var AST_Directive = DEFNODE("Directive", "value scope", {
        $documentation: 'Represents a directive, like "use strict";',
        $propdoc: {
            value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
            scope: "[AST_Scope/S] The scope that this directive affects"
        }
    }, AST_Statement);
    var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
        $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
        $propdoc: {
            body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.body._walk(visitor);
            });
        }
    }, AST_Statement);
    function walk_body(node, visitor) {
        if (node.body instanceof AST_Statement) {
            node.body._walk(visitor);
        } else node.body.forEach(function(stat) {
            stat._walk(visitor);
        });
    }
    var AST_Block = DEFNODE("Block", "body", {
        $documentation: "A body of statements (usually bracketed)",
        $propdoc: {
            body: "[AST_Statement*] an array of statements"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                walk_body(this, visitor);
            });
        }
    }, AST_Statement);
    var AST_BlockStatement = DEFNODE("BlockStatement", null, {
        $documentation: "A block statement"
    }, AST_Block);
    var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
        $documentation: "The empty statement (empty block or simply a semicolon)",
        _walk: function(visitor) {
            return visitor._visit(this);
        }
    }, AST_Statement);
    var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
        $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
        $propdoc: {
            body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.body._walk(visitor);
            });
        }
    }, AST_Statement);
    var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
        $documentation: "Statement with a label",
        $propdoc: {
            label: "[AST_Label] a label definition"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.label._walk(visitor);
                this.body._walk(visitor);
            });
        }
    }, AST_StatementWithBody);
    var AST_IterationStatement = DEFNODE("IterationStatement", null, {
        $documentation: "Internal class.  All loops inherit from it."
    }, AST_StatementWithBody);
    var AST_DWLoop = DEFNODE("DWLoop", "condition", {
        $documentation: "Base class for do/while statements",
        $propdoc: {
            condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.condition._walk(visitor);
                this.body._walk(visitor);
            });
        }
    }, AST_IterationStatement);
    var AST_Do = DEFNODE("Do", null, {
        $documentation: "A `do` statement"
    }, AST_DWLoop);
    var AST_While = DEFNODE("While", null, {
        $documentation: "A `while` statement"
    }, AST_DWLoop);
    var AST_For = DEFNODE("For", "init condition step", {
        $documentation: "A `for` statement",
        $propdoc: {
            init: "[AST_Node?] the `for` initialization code, or null if empty",
            condition: "[AST_Node?] the `for` termination clause, or null if empty",
            step: "[AST_Node?] the `for` update clause, or null if empty"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                if (this.init) this.init._walk(visitor);
                if (this.condition) this.condition._walk(visitor);
                if (this.step) this.step._walk(visitor);
                this.body._walk(visitor);
            });
        }
    }, AST_IterationStatement);
    var AST_ForIn = DEFNODE("ForIn", "init name object", {
        $documentation: "A `for ... in` statement",
        $propdoc: {
            init: "[AST_Node] the `for/in` initialization code",
            name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
            object: "[AST_Node] the object that we're looping through"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.init._walk(visitor);
                this.object._walk(visitor);
                this.body._walk(visitor);
            });
        }
    }, AST_IterationStatement);
    var AST_With = DEFNODE("With", "expression", {
        $documentation: "A `with` statement",
        $propdoc: {
            expression: "[AST_Node] the `with` expression"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
                this.body._walk(visitor);
            });
        }
    }, AST_StatementWithBody);
    /* -----[ scope and functions ]----- */
    var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
        $documentation: "Base class for all statements introducing a lexical scope",
        $propdoc: {
            directives: "[string*/S] an array of directives declared in this scope",
            variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
            functions: "[Object/S] like `variables`, but only lists function declarations",
            uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
            uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
            parent_scope: "[AST_Scope?/S] link to the parent scope",
            enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
            cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
        }
    }, AST_Block);
    var AST_Toplevel = DEFNODE("Toplevel", "globals", {
        $documentation: "The toplevel scope",
        $propdoc: {
            globals: "[Object/S] a map of name -> SymbolDef for all undeclared names"
        },
        wrap_enclose: function(arg_parameter_pairs) {
            var self = this;
            var args = [];
            var parameters = [];
            arg_parameter_pairs.forEach(function(pair) {
                var split = pair.split(":");
                args.push(split[0]);
                parameters.push(split[1]);
            });
            var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
            wrapped_tl = parse(wrapped_tl);
            wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                if (node instanceof AST_Directive && node.value == "$ORIG") {
                    return MAP.splice(self.body);
                }
            }));
            return wrapped_tl;
        },
        wrap_commonjs: function(name, export_all) {
            var self = this;
            var to_export = [];
            if (export_all) {
                self.figure_out_scope();
                self.walk(new TreeWalker(function(node) {
                    if (node instanceof AST_SymbolDeclaration && node.definition().global) {
                        if (!find_if(function(n) {
                                return n.name == node.name;
                            }, to_export)) to_export.push(node);
                    }
                }));
            }
            var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
            wrapped_tl = parse(wrapped_tl);
            wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                if (node instanceof AST_SimpleStatement) {
                    node = node.body;
                    if (node instanceof AST_String) switch (node.getValue()) {
                        case "$ORIG":
                            return MAP.splice(self.body);

                        case "$EXPORTS":
                            var body = [];
                            to_export.forEach(function(sym) {
                                body.push(new AST_SimpleStatement({
                                    body: new AST_Assign({
                                        left: new AST_Sub({
                                            expression: new AST_SymbolRef({
                                                name: "exports"
                                            }),
                                            property: new AST_String({
                                                value: sym.name
                                            })
                                        }),
                                        operator: "=",
                                        right: new AST_SymbolRef(sym)
                                    })
                                }));
                            });
                            return MAP.splice(body);
                    }
                }
            }));
            return wrapped_tl;
        }
    }, AST_Scope);
    var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
        $documentation: "Base class for functions",
        $propdoc: {
            name: "[AST_SymbolDeclaration?] the name of this function",
            argnames: "[AST_SymbolFunarg*] array of function arguments",
            uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                if (this.name) this.name._walk(visitor);
                this.argnames.forEach(function(arg) {
                    arg._walk(visitor);
                });
                walk_body(this, visitor);
            });
        }
    }, AST_Scope);
    var AST_Accessor = DEFNODE("Accessor", null, {
        $documentation: "A setter/getter function"
    }, AST_Lambda);
    var AST_Function = DEFNODE("Function", null, {
        $documentation: "A function expression"
    }, AST_Lambda);
    var AST_Defun = DEFNODE("Defun", null, {
        $documentation: "A function definition"
    }, AST_Lambda);
    /* -----[ JUMPS ]----- */
    var AST_Jump = DEFNODE("Jump", null, {
        $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
    }, AST_Statement);
    var AST_Exit = DEFNODE("Exit", "value", {
        $documentation: "Base class for “exits” (`return` and `throw`)",
        $propdoc: {
            value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
        },
        _walk: function(visitor) {
            return visitor._visit(this, this.value && function() {
                    this.value._walk(visitor);
                });
        }
    }, AST_Jump);
    var AST_Return = DEFNODE("Return", null, {
        $documentation: "A `return` statement"
    }, AST_Exit);
    var AST_Throw = DEFNODE("Throw", null, {
        $documentation: "A `throw` statement"
    }, AST_Exit);
    var AST_LoopControl = DEFNODE("LoopControl", "label", {
        $documentation: "Base class for loop control statements (`break` and `continue`)",
        $propdoc: {
            label: "[AST_LabelRef?] the label, or null if none"
        },
        _walk: function(visitor) {
            return visitor._visit(this, this.label && function() {
                    this.label._walk(visitor);
                });
        }
    }, AST_Jump);
    var AST_Break = DEFNODE("Break", null, {
        $documentation: "A `break` statement"
    }, AST_LoopControl);
    var AST_Continue = DEFNODE("Continue", null, {
        $documentation: "A `continue` statement"
    }, AST_LoopControl);
    /* -----[ IF ]----- */
    var AST_If = DEFNODE("If", "condition alternative", {
        $documentation: "A `if` statement",
        $propdoc: {
            condition: "[AST_Node] the `if` condition",
            alternative: "[AST_Statement?] the `else` part, or null if not present"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.condition._walk(visitor);
                this.body._walk(visitor);
                if (this.alternative) this.alternative._walk(visitor);
            });
        }
    }, AST_StatementWithBody);
    /* -----[ SWITCH ]----- */
    var AST_Switch = DEFNODE("Switch", "expression", {
        $documentation: "A `switch` statement",
        $propdoc: {
            expression: "[AST_Node] the `switch` “discriminant”"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
                walk_body(this, visitor);
            });
        }
    }, AST_Block);
    var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
        $documentation: "Base class for `switch` branches"
    }, AST_Block);
    var AST_Default = DEFNODE("Default", null, {
        $documentation: "A `default` switch branch"
    }, AST_SwitchBranch);
    var AST_Case = DEFNODE("Case", "expression", {
        $documentation: "A `case` switch branch",
        $propdoc: {
            expression: "[AST_Node] the `case` expression"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
                walk_body(this, visitor);
            });
        }
    }, AST_SwitchBranch);
    /* -----[ EXCEPTIONS ]----- */
    var AST_Try = DEFNODE("Try", "bcatch bfinally", {
        $documentation: "A `try` statement",
        $propdoc: {
            bcatch: "[AST_Catch?] the catch block, or null if not present",
            bfinally: "[AST_Finally?] the finally block, or null if not present"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                walk_body(this, visitor);
                if (this.bcatch) this.bcatch._walk(visitor);
                if (this.bfinally) this.bfinally._walk(visitor);
            });
        }
    }, AST_Block);
    // XXX: this is wrong according to ECMA-262 (12.4).  the catch block
    // should introduce another scope, as the argname should be visible
    // only inside the catch block.  However, doing it this way because of
    // IE which simply introduces the name in the surrounding scope.  If
    // we ever want to fix this then AST_Catch should inherit from
    // AST_Scope.
    var AST_Catch = DEFNODE("Catch", "argname", {
        $documentation: "A `catch` node; only makes sense as part of a `try` statement",
        $propdoc: {
            argname: "[AST_SymbolCatch] symbol for the exception"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.argname._walk(visitor);
                walk_body(this, visitor);
            });
        }
    }, AST_Block);
    var AST_Finally = DEFNODE("Finally", null, {
        $documentation: "A `finally` node; only makes sense as part of a `try` statement"
    }, AST_Block);
    /* -----[ VAR/CONST ]----- */
    var AST_Definitions = DEFNODE("Definitions", "definitions", {
        $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
        $propdoc: {
            definitions: "[AST_VarDef*] array of variable definitions"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.definitions.forEach(function(def) {
                    def._walk(visitor);
                });
            });
        }
    }, AST_Statement);
    var AST_Var = DEFNODE("Var", null, {
        $documentation: "A `var` statement"
    }, AST_Definitions);
    var AST_Const = DEFNODE("Const", null, {
        $documentation: "A `const` statement"
    }, AST_Definitions);
    var AST_VarDef = DEFNODE("VarDef", "name value", {
        $documentation: "A variable declaration; only appears in a AST_Definitions node",
        $propdoc: {
            name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
            value: "[AST_Node?] initializer, or null of there's no initializer"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.name._walk(visitor);
                if (this.value) this.value._walk(visitor);
            });
        }
    });
    /* -----[ OTHER ]----- */
    var AST_Call = DEFNODE("Call", "expression args", {
        $documentation: "A function call expression",
        $propdoc: {
            expression: "[AST_Node] expression to invoke as function",
            args: "[AST_Node*] array of arguments"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
                this.args.forEach(function(arg) {
                    arg._walk(visitor);
                });
            });
        }
    });
    var AST_New = DEFNODE("New", null, {
        $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
    }, AST_Call);
    var AST_Seq = DEFNODE("Seq", "car cdr", {
        $documentation: "A sequence expression (two comma-separated expressions)",
        $propdoc: {
            car: "[AST_Node] first element in sequence",
            cdr: "[AST_Node] second element in sequence"
        },
        $cons: function(x, y) {
            var seq = new AST_Seq(x);
            seq.car = x;
            seq.cdr = y;
            return seq;
        },
        $from_array: function(array) {
            if (array.length == 0) return null;
            if (array.length == 1) return array[0].clone();
            var list = null;
            for (var i = array.length; --i >= 0; ) {
                list = AST_Seq.cons(array[i], list);
            }
            var p = list;
            while (p) {
                if (p.cdr && !p.cdr.cdr) {
                    p.cdr = p.cdr.car;
                    break;
                }
                p = p.cdr;
            }
            return list;
        },
        to_array: function() {
            var p = this, a = [];
            while (p) {
                a.push(p.car);
                if (p.cdr && !(p.cdr instanceof AST_Seq)) {
                    a.push(p.cdr);
                    break;
                }
                p = p.cdr;
            }
            return a;
        },
        add: function(node) {
            var p = this;
            while (p) {
                if (!(p.cdr instanceof AST_Seq)) {
                    var cell = AST_Seq.cons(p.cdr, node);
                    return p.cdr = cell;
                }
                p = p.cdr;
            }
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.car._walk(visitor);
                if (this.cdr) this.cdr._walk(visitor);
            });
        }
    });
    var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
        $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
        $propdoc: {
            expression: "[AST_Node] the “container” expression",
            property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
        }
    });
    var AST_Dot = DEFNODE("Dot", null, {
        $documentation: "A dotted property access expression",
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
            });
        }
    }, AST_PropAccess);
    var AST_Sub = DEFNODE("Sub", null, {
        $documentation: 'Index-style property access, i.e. `a["foo"]`',
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
                this.property._walk(visitor);
            });
        }
    }, AST_PropAccess);
    var AST_Unary = DEFNODE("Unary", "operator expression", {
        $documentation: "Base class for unary expressions",
        $propdoc: {
            operator: "[string] the operator",
            expression: "[AST_Node] expression that this unary operator applies to"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.expression._walk(visitor);
            });
        }
    });
    var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
        $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
    }, AST_Unary);
    var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
        $documentation: "Unary postfix expression, i.e. `i++`"
    }, AST_Unary);
    var AST_Binary = DEFNODE("Binary", "left operator right", {
        $documentation: "Binary expression, i.e. `a + b`",
        $propdoc: {
            left: "[AST_Node] left-hand side expression",
            operator: "[string] the operator",
            right: "[AST_Node] right-hand side expression"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.left._walk(visitor);
                this.right._walk(visitor);
            });
        }
    });
    var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
        $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
        $propdoc: {
            condition: "[AST_Node]",
            consequent: "[AST_Node]",
            alternative: "[AST_Node]"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.condition._walk(visitor);
                this.consequent._walk(visitor);
                this.alternative._walk(visitor);
            });
        }
    });
    var AST_Assign = DEFNODE("Assign", null, {
        $documentation: "An assignment expression — `a = b + 5`"
    }, AST_Binary);
    /* -----[ LITERALS ]----- */
    var AST_Array = DEFNODE("Array", "elements", {
        $documentation: "An array literal",
        $propdoc: {
            elements: "[AST_Node*] array of elements"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.elements.forEach(function(el) {
                    el._walk(visitor);
                });
            });
        }
    });
    var AST_Object = DEFNODE("Object", "properties", {
        $documentation: "An object literal",
        $propdoc: {
            properties: "[AST_ObjectProperty*] array of properties"
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.properties.forEach(function(prop) {
                    prop._walk(visitor);
                });
            });
        }
    });
    var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
        $documentation: "Base class for literal object properties",
        $propdoc: {
            key: "[string] the property name; it's always a plain string in our AST, no matter if it was a string, number or identifier in original code",
            value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
        },
        _walk: function(visitor) {
            return visitor._visit(this, function() {
                this.value._walk(visitor);
            });
        }
    });
    var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
        $documentation: "A key: value object property"
    }, AST_ObjectProperty);
    var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
        $documentation: "An object setter property"
    }, AST_ObjectProperty);
    var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
        $documentation: "An object getter property"
    }, AST_ObjectProperty);
    var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
        $propdoc: {
            name: "[string] name of this symbol",
            scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
            thedef: "[SymbolDef/S] the definition of this symbol"
        },
        $documentation: "Base class for all symbols"
    });
    var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
        $documentation: "The name of a property accessor (setter/getter function)"
    }, AST_Symbol);
    var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
        $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
        $propdoc: {
            init: "[AST_Node*/S] array of initializers for this declaration."
        }
    }, AST_Symbol);
    var AST_SymbolVar = DEFNODE("SymbolVar", null, {
        $documentation: "Symbol defining a variable"
    }, AST_SymbolDeclaration);
    var AST_SymbolConst = DEFNODE("SymbolConst", null, {
        $documentation: "A constant declaration"
    }, AST_SymbolDeclaration);
    var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
        $documentation: "Symbol naming a function argument"
    }, AST_SymbolVar);
    var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
        $documentation: "Symbol defining a function"
    }, AST_SymbolDeclaration);
    var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
        $documentation: "Symbol naming a function expression"
    }, AST_SymbolDeclaration);
    var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
        $documentation: "Symbol naming the exception in catch"
    }, AST_SymbolDeclaration);
    var AST_Label = DEFNODE("Label", "references", {
        $documentation: "Symbol naming a label (declaration)",
        $propdoc: {
            references: "[AST_LoopControl*] a list of nodes referring to this label"
        },
        initialize: function() {
            this.references = [];
            this.thedef = this;
        }
    }, AST_Symbol);
    var AST_SymbolRef = DEFNODE("SymbolRef", null, {
        $documentation: "Reference to some symbol (not definition/declaration)"
    }, AST_Symbol);
    var AST_LabelRef = DEFNODE("LabelRef", null, {
        $documentation: "Reference to a label symbol"
    }, AST_Symbol);
    var AST_This = DEFNODE("This", null, {
        $documentation: "The `this` symbol"
    }, AST_Symbol);
    var AST_Constant = DEFNODE("Constant", null, {
        $documentation: "Base class for all constants",
        getValue: function() {
            return this.value;
        }
    });
    var AST_String = DEFNODE("String", "value", {
        $documentation: "A string literal",
        $propdoc: {
            value: "[string] the contents of this string"
        }
    }, AST_Constant);
    var AST_Number = DEFNODE("Number", "value", {
        $documentation: "A number literal",
        $propdoc: {
            value: "[number] the numeric value"
        }
    }, AST_Constant);
    var AST_RegExp = DEFNODE("RegExp", "value", {
        $documentation: "A regexp literal",
        $propdoc: {
            value: "[RegExp] the actual regexp"
        }
    }, AST_Constant);
    var AST_Atom = DEFNODE("Atom", null, {
        $documentation: "Base class for atoms"
    }, AST_Constant);
    var AST_Null = DEFNODE("Null", null, {
        $documentation: "The `null` atom",
        value: null
    }, AST_Atom);
    var AST_NaN = DEFNODE("NaN", null, {
        $documentation: "The impossible value",
        value: 0 / 0
    }, AST_Atom);
    var AST_Undefined = DEFNODE("Undefined", null, {
        $documentation: "The `undefined` value",
        value: function() {}()
    }, AST_Atom);
    var AST_Hole = DEFNODE("Hole", null, {
        $documentation: "A hole in an array",
        value: function() {}()
    }, AST_Atom);
    var AST_Infinity = DEFNODE("Infinity", null, {
        $documentation: "The `Infinity` value",
        value: 1 / 0
    }, AST_Atom);
    var AST_Boolean = DEFNODE("Boolean", null, {
        $documentation: "Base class for booleans"
    }, AST_Atom);
    var AST_False = DEFNODE("False", null, {
        $documentation: "The `false` atom",
        value: false
    }, AST_Boolean);
    var AST_True = DEFNODE("True", null, {
        $documentation: "The `true` atom",
        value: true
    }, AST_Boolean);
    /* -----[ TreeWalker ]----- */
    function TreeWalker(callback) {
        this.visit = callback;
        this.stack = [];
    }
    TreeWalker.prototype = {
        _visit: function(node, descend) {
            this.stack.push(node);
            var ret = this.visit(node, descend ? function() {
                descend.call(node);
            } : noop);
            if (!ret && descend) {
                descend.call(node);
            }
            this.stack.pop();
            return ret;
        },
        parent: function(n) {
            return this.stack[this.stack.length - 2 - (n || 0)];
        },
        push: function(node) {
            this.stack.push(node);
        },
        pop: function() {
            return this.stack.pop();
        },
        self: function() {
            return this.stack[this.stack.length - 1];
        },
        find_parent: function(type) {
            var stack = this.stack;
            for (var i = stack.length; --i >= 0; ) {
                var x = stack[i];
                if (x instanceof type) return x;
            }
        },
        has_directive: function(type) {
            return this.find_parent(AST_Scope).has_directive(type);
        },
        in_boolean_context: function() {
            var stack = this.stack;
            var i = stack.length, self = stack[--i];
            while (i > 0) {
                var p = stack[--i];
                if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_For && p.condition === self || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self) {
                    return true;
                }
                if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||"))) return false;
                self = p;
            }
        },
        loopcontrol_target: function(label) {
            var stack = this.stack;
            if (label) for (var i = stack.length; --i >= 0; ) {
                var x = stack[i];
                if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
                    return x.body;
                }
            } else for (var i = stack.length; --i >= 0; ) {
                var x = stack[i];
                if (x instanceof AST_Switch || x instanceof AST_IterationStatement) return x;
            }
        }
    };
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
     Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    var KEYWORDS = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with";
    var KEYWORDS_ATOM = "false null true";
    var RESERVED_WORDS = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile" + " " + KEYWORDS_ATOM + " " + KEYWORDS;
    var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
    KEYWORDS = makePredicate(KEYWORDS);
    RESERVED_WORDS = makePredicate(RESERVED_WORDS);
    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
    var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
    var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
    var RE_OCT_NUMBER = /^0[0-7]+$/;
    var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
    var OPERATORS = makePredicate([ "in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||" ]);
    var WHITESPACE_CHARS = makePredicate(characters("  \n\r	\f​᠎             　"));
    var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));
    var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
    var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));
    /* -----[ Tokenizer ]----- */
    // regexps adapted from http://xregexp.com/plugins/#unicode
    var UNICODE = {
        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
        non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
        space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
    };
    function is_letter(code) {
        return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));
    }
    function is_digit(code) {
        return code >= 48 && code <= 57;
    }
    function is_alphanumeric_char(code) {
        return is_digit(code) || is_letter(code);
    }
    function is_unicode_combining_mark(ch) {
        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
    }
    function is_unicode_connector_punctuation(ch) {
        return UNICODE.connector_punctuation.test(ch);
    }
    function is_identifier(name) {
        return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
    }
    function is_identifier_start(code) {
        return code == 36 || code == 95 || is_letter(code);
    }
    function is_identifier_char(ch) {
        var code = ch.charCodeAt(0);
        return is_identifier_start(code) || is_digit(code) || code == 8204 || code == 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);
    }
    function is_identifier_string(str) {
        var i = str.length;
        if (i == 0) return false;
        if (!is_identifier_start(str.charCodeAt(0))) return false;
        while (--i >= 0) {
            if (!is_identifier_char(str.charAt(i))) return false;
        }
        return true;
    }
    function parse_js_number(num) {
        if (RE_HEX_NUMBER.test(num)) {
            return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
            return parseInt(num.substr(1), 8);
        } else if (RE_DEC_NUMBER.test(num)) {
            return parseFloat(num);
        }
    }
    function JS_Parse_Error(message, line, col, pos) {
        this.message = message;
        this.line = line;
        this.col = col;
        this.pos = pos;
        this.stack = new Error().stack;
    }
    JS_Parse_Error.prototype.toString = function() {
        return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
    };
    function js_error(message, filename, line, col, pos) {
        throw new JS_Parse_Error(message, line, col, pos);
    }
    function is_token(token, type, val) {
        return token.type == type && (val == null || token.value == val);
    }
    var EX_EOF = {};
    function tokenizer($TEXT, filename, html5_comments) {
        var S = {
            text: $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
            filename: filename,
            pos: 0,
            tokpos: 0,
            line: 1,
            tokline: 0,
            col: 0,
            tokcol: 0,
            newline_before: false,
            regex_allowed: false,
            comments_before: []
        };
        function peek() {
            return S.text.charAt(S.pos);
        }
        function next(signal_eof, in_string) {
            var ch = S.text.charAt(S.pos++);
            if (signal_eof && !ch) throw EX_EOF;
            if (ch == "\n") {
                S.newline_before = S.newline_before || !in_string;
                ++S.line;
                S.col = 0;
            } else {
                ++S.col;
            }
            return ch;
        }
        function forward(i) {
            while (i-- > 0) next();
        }
        function looking_at(str) {
            return S.text.substr(S.pos, str.length) == str;
        }
        function find(what, signal_eof) {
            var pos = S.text.indexOf(what, S.pos);
            if (signal_eof && pos == -1) throw EX_EOF;
            return pos;
        }
        function start_token() {
            S.tokline = S.line;
            S.tokcol = S.col;
            S.tokpos = S.pos;
        }
        var prev_was_dot = false;
        function token(type, value, is_comment) {
            S.regex_allowed = type == "operator" && !UNARY_POSTFIX(value) || type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value) || type == "punc" && PUNC_BEFORE_EXPRESSION(value);
            prev_was_dot = type == "punc" && value == ".";
            var ret = {
                type: type,
                value: value,
                line: S.tokline,
                col: S.tokcol,
                pos: S.tokpos,
                endpos: S.pos,
                nlb: S.newline_before,
                file: filename
            };
            if (!is_comment) {
                ret.comments_before = S.comments_before;
                S.comments_before = [];
                // make note of any newlines in the comments that came before
                for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                    ret.nlb = ret.nlb || ret.comments_before[i].nlb;
                }
            }
            S.newline_before = false;
            return new AST_Token(ret);
        }
        function skip_whitespace() {
            while (WHITESPACE_CHARS(peek())) next();
        }
        function read_while(pred) {
            var ret = "", ch, i = 0;
            while ((ch = peek()) && pred(ch, i++)) ret += next();
            return ret;
        }
        function parse_error(err) {
            js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
        }
        function read_num(prefix) {
            var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
            var num = read_while(function(ch, i) {
                var code = ch.charCodeAt(0);
                switch (code) {
                    case 120:
                    case 88:
                        // xX
                        return has_x ? false : has_x = true;

                    case 101:
                    case 69:
                        // eE
                        return has_x ? true : has_e ? false : has_e = after_e = true;

                    case 45:
                        // -
                        return after_e || i == 0 && !prefix;

                    case 43:
                        // +
                        return after_e;

                    case after_e = false, 46:
                        // .
                        return !has_dot && !has_x && !has_e ? has_dot = true : false;
                }
                return is_alphanumeric_char(code);
            });
            if (prefix) num = prefix + num;
            var valid = parse_js_number(num);
            if (!isNaN(valid)) {
                return token("num", valid);
            } else {
                parse_error("Invalid syntax: " + num);
            }
        }
        function read_escaped_char(in_string) {
            var ch = next(true, in_string);
            switch (ch.charCodeAt(0)) {
                case 110:
                    return "\n";

                case 114:
                    return "\r";

                case 116:
                    return "	";

                case 98:
                    return "\b";

                case 118:
                    return "";

                // \v
                case 102:
                    return "\f";

                case 48:
                    return "\x00";

                case 120:
                    return String.fromCharCode(hex_bytes(2));

                // \x
                case 117:
                    return String.fromCharCode(hex_bytes(4));

                // \u
                case 10:
                    return "";

                // newline
                default:
                    return ch;
            }
        }
        function hex_bytes(n) {
            var num = 0;
            for (;n > 0; --n) {
                var digit = parseInt(next(true), 16);
                if (isNaN(digit)) parse_error("Invalid hex-character pattern in string");
                num = num << 4 | digit;
            }
            return num;
        }
        var read_string = with_eof_error("Unterminated string constant", function() {
            var quote = next(), ret = "";
            for (;;) {
                var ch = next(true);
                if (ch == "\\") {
                    // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                    // https://github.com/mishoo/UglifyJS/issues/178
                    var octal_len = 0, first = null;
                    ch = read_while(function(ch) {
                        if (ch >= "0" && ch <= "7") {
                            if (!first) {
                                first = ch;
                                return ++octal_len;
                            } else if (first <= "3" && octal_len <= 2) return ++octal_len; else if (first >= "4" && octal_len <= 1) return ++octal_len;
                        }
                        return false;
                    });
                    if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8)); else ch = read_escaped_char(true);
                } else if (ch == quote) break;
                ret += ch;
            }
            return token("string", ret);
        });
        function skip_line_comment(type) {
            var regex_allowed = S.regex_allowed;
            var i = find("\n"), ret;
            if (i == -1) {
                ret = S.text.substr(S.pos);
                S.pos = S.text.length;
            } else {
                ret = S.text.substring(S.pos, i);
                S.pos = i;
            }
            S.comments_before.push(token(type, ret, true));
            S.regex_allowed = regex_allowed;
            return next_token();
        }
        var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
            var regex_allowed = S.regex_allowed;
            var i = find("*/", true);
            var text = S.text.substring(S.pos, i);
            var a = text.split("\n"), n = a.length;
            // update stream position
            S.pos = i + 2;
            S.line += n - 1;
            if (n > 1) S.col = a[n - 1].length; else S.col += a[n - 1].length;
            S.col += 2;
            var nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
            S.comments_before.push(token("comment2", text, true));
            S.regex_allowed = regex_allowed;
            S.newline_before = nlb;
            return next_token();
        });
        function read_name() {
            var backslash = false, name = "", ch, escaped = false, hex;
            while ((ch = peek()) != null) {
                if (!backslash) {
                    if (ch == "\\") escaped = backslash = true, next(); else if (is_identifier_char(ch)) name += next(); else break;
                } else {
                    if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                    ch = read_escaped_char();
                    if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                    name += ch;
                    backslash = false;
                }
            }
            if (KEYWORDS(name) && escaped) {
                hex = name.charCodeAt(0).toString(16).toUpperCase();
                name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
            }
            return name;
        }
        var read_regexp = with_eof_error("Unterminated regular expression", function(regexp) {
            var prev_backslash = false, ch, in_class = false;
            while (ch = next(true)) if (prev_backslash) {
                regexp += "\\" + ch;
                prev_backslash = false;
            } else if (ch == "[") {
                in_class = true;
                regexp += ch;
            } else if (ch == "]" && in_class) {
                in_class = false;
                regexp += ch;
            } else if (ch == "/" && !in_class) {
                break;
            } else if (ch == "\\") {
                prev_backslash = true;
            } else {
                regexp += ch;
            }
            var mods = read_name();
            return token("regexp", new RegExp(regexp, mods));
        });
        function read_operator(prefix) {
            function grow(op) {
                if (!peek()) return op;
                var bigger = op + peek();
                if (OPERATORS(bigger)) {
                    next();
                    return grow(bigger);
                } else {
                    return op;
                }
            }
            return token("operator", grow(prefix || next()));
        }
        function handle_slash() {
            next();
            switch (peek()) {
                case "/":
                    next();
                    return skip_line_comment("comment1");

                case "*":
                    next();
                    return skip_multiline_comment();
            }
            return S.regex_allowed ? read_regexp("") : read_operator("/");
        }
        function handle_dot() {
            next();
            return is_digit(peek().charCodeAt(0)) ? read_num(".") : token("punc", ".");
        }
        function read_word() {
            var word = read_name();
            if (prev_was_dot) return token("name", word);
            return KEYWORDS_ATOM(word) ? token("atom", word) : !KEYWORDS(word) ? token("name", word) : OPERATORS(word) ? token("operator", word) : token("keyword", word);
        }
        function with_eof_error(eof_error, cont) {
            return function(x) {
                try {
                    return cont(x);
                } catch (ex) {
                    if (ex === EX_EOF) parse_error(eof_error); else throw ex;
                }
            };
        }
        function next_token(force_regexp) {
            if (force_regexp != null) return read_regexp(force_regexp);
            skip_whitespace();
            start_token();
            if (html5_comments) {
                if (looking_at("<!--")) {
                    forward(4);
                    return skip_line_comment("comment3");
                }
                if (looking_at("-->") && S.newline_before) {
                    forward(3);
                    return skip_line_comment("comment4");
                }
            }
            var ch = peek();
            if (!ch) return token("eof");
            var code = ch.charCodeAt(0);
            switch (code) {
                case 34:
                case 39:
                    return read_string();

                case 46:
                    return handle_dot();

                case 47:
                    return handle_slash();
            }
            if (is_digit(code)) return read_num();
            if (PUNC_CHARS(ch)) return token("punc", next());
            if (OPERATOR_CHARS(ch)) return read_operator();
            if (code == 92 || is_identifier_start(code)) return read_word();
            parse_error("Unexpected character '" + ch + "'");
        }
        next_token.context = function(nc) {
            if (nc) S = nc;
            return S;
        };
        return next_token;
    }
    /* -----[ Parser (constants) ]----- */
    var UNARY_PREFIX = makePredicate([ "typeof", "void", "delete", "--", "++", "!", "~", "-", "+" ]);
    var UNARY_POSTFIX = makePredicate([ "--", "++" ]);
    var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);
    var PRECEDENCE = function(a, ret) {
        for (var i = 0, n = 1; i < a.length; ++i, ++n) {
            var b = a[i];
            for (var j = 0; j < b.length; ++j) {
                ret[b[j]] = n;
            }
        }
        return ret;
    }([ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "%" ] ], {});
    var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
    var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);
    /* -----[ Parser ]----- */
    function parse($TEXT, options) {
        options = defaults(options, {
            strict: false,
            filename: null,
            toplevel: null,
            expression: false,
            html5_comments: true
        });
        var S = {
            input: typeof $TEXT == "string" ? tokenizer($TEXT, options.filename, options.html5_comments) : $TEXT,
            token: null,
            prev: null,
            peeked: null,
            in_function: 0,
            in_directives: true,
            in_loop: 0,
            labels: []
        };
        S.token = next();
        function is(type, value) {
            return is_token(S.token, type, value);
        }
        function peek() {
            return S.peeked || (S.peeked = S.input());
        }
        function next() {
            S.prev = S.token;
            if (S.peeked) {
                S.token = S.peeked;
                S.peeked = null;
            } else {
                S.token = S.input();
            }
            S.in_directives = S.in_directives && (S.token.type == "string" || is("punc", ";"));
            return S.token;
        }
        function prev() {
            return S.prev;
        }
        function croak(msg, line, col, pos) {
            var ctx = S.input.context();
            js_error(msg, ctx.filename, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos != null ? pos : ctx.tokpos);
        }
        function token_error(token, msg) {
            croak(msg, token.line, token.col);
        }
        function unexpected(token) {
            if (token == null) token = S.token;
            token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
        }
        function expect_token(type, val) {
            if (is(type, val)) {
                return next();
            }
            token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
        }
        function expect(punc) {
            return expect_token("punc", punc);
        }
        function can_insert_semicolon() {
            return !options.strict && (S.token.nlb || is("eof") || is("punc", "}"));
        }
        function semicolon() {
            if (is("punc", ";")) next(); else if (!can_insert_semicolon()) unexpected();
        }
        function parenthesised() {
            expect("(");
            var exp = expression(true);
            expect(")");
            return exp;
        }
        function embed_tokens(parser) {
            return function() {
                var start = S.token;
                var expr = parser();
                var end = prev();
                expr.start = start;
                expr.end = end;
                return expr;
            };
        }
        function handle_regexp() {
            if (is("operator", "/") || is("operator", "/=")) {
                S.peeked = null;
                S.token = S.input(S.token.value.substr(1));
            }
        }
        var statement = embed_tokens(function() {
            var tmp;
            handle_regexp();
            switch (S.token.type) {
                case "string":
                    var dir = S.in_directives, stat = simple_statement();
                    // XXXv2: decide how to fix directives
                    if (dir && stat.body instanceof AST_String && !is("punc", ",")) return new AST_Directive({
                        value: stat.body.value
                    });
                    return stat;

                case "num":
                case "regexp":
                case "operator":
                case "atom":
                    return simple_statement();

                case "name":
                    return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();

                case "punc":
                    switch (S.token.value) {
                        case "{":
                            return new AST_BlockStatement({
                                start: S.token,
                                body: block_(),
                                end: prev()
                            });

                        case "[":
                        case "(":
                            return simple_statement();

                        case ";":
                            next();
                            return new AST_EmptyStatement();

                        default:
                            unexpected();
                    }

                case "keyword":
                    switch (tmp = S.token.value, next(), tmp) {
                        case "break":
                            return break_cont(AST_Break);

                        case "continue":
                            return break_cont(AST_Continue);

                        case "debugger":
                            semicolon();
                            return new AST_Debugger();

                        case "do":
                            return new AST_Do({
                                body: in_loop(statement),
                                condition: (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(),
                                    tmp)
                            });

                        case "while":
                            return new AST_While({
                                condition: parenthesised(),
                                body: in_loop(statement)
                            });

                        case "for":
                            return for_();

                        case "function":
                            return function_(true);

                        case "if":
                            return if_();

                        case "return":
                            if (S.in_function == 0) croak("'return' outside of function");
                            return new AST_Return({
                                value: is("punc", ";") ? (next(), null) : can_insert_semicolon() ? null : (tmp = expression(true),
                                    semicolon(), tmp)
                            });

                        case "switch":
                            return new AST_Switch({
                                expression: parenthesised(),
                                body: in_loop(switch_body_)
                            });

                        case "throw":
                            if (S.token.nlb) croak("Illegal newline after 'throw'");
                            return new AST_Throw({
                                value: (tmp = expression(true), semicolon(), tmp)
                            });

                        case "try":
                            return try_();

                        case "var":
                            return tmp = var_(), semicolon(), tmp;

                        case "const":
                            return tmp = const_(), semicolon(), tmp;

                        case "with":
                            return new AST_With({
                                expression: parenthesised(),
                                body: statement()
                            });

                        default:
                            unexpected();
                    }
            }
        });
        function labeled_statement() {
            var label = as_symbol(AST_Label);
            if (find_if(function(l) {
                    return l.name == label.name;
                }, S.labels)) {
                // ECMA-262, 12.12: An ECMAScript program is considered
                // syntactically incorrect if it contains a
                // LabelledStatement that is enclosed by a
                // LabelledStatement with the same Identifier as label.
                croak("Label " + label.name + " defined twice");
            }
            expect(":");
            S.labels.push(label);
            var stat = statement();
            S.labels.pop();
            if (!(stat instanceof AST_IterationStatement)) {
                // check for `continue` that refers to this label.
                // those should be reported as syntax errors.
                // https://github.com/mishoo/UglifyJS2/issues/287
                label.references.forEach(function(ref) {
                    if (ref instanceof AST_Continue) {
                        ref = ref.label.start;
                        croak("Continue label `" + label.name + "` refers to non-IterationStatement.", ref.line, ref.col, ref.pos);
                    }
                });
            }
            return new AST_LabeledStatement({
                body: stat,
                label: label
            });
        }
        function simple_statement(tmp) {
            return new AST_SimpleStatement({
                body: (tmp = expression(true), semicolon(), tmp)
            });
        }
        function break_cont(type) {
            var label = null, ldef;
            if (!can_insert_semicolon()) {
                label = as_symbol(AST_LabelRef, true);
            }
            if (label != null) {
                ldef = find_if(function(l) {
                    return l.name == label.name;
                }, S.labels);
                if (!ldef) croak("Undefined label " + label.name);
                label.thedef = ldef;
            } else if (S.in_loop == 0) croak(type.TYPE + " not inside a loop or switch");
            semicolon();
            var stat = new type({
                label: label
            });
            if (ldef) ldef.references.push(stat);
            return stat;
        }
        function for_() {
            expect("(");
            var init = null;
            if (!is("punc", ";")) {
                init = is("keyword", "var") ? (next(), var_(true)) : expression(true, true);
                if (is("operator", "in")) {
                    if (init instanceof AST_Var && init.definitions.length > 1) croak("Only one variable declaration allowed in for..in loop");
                    next();
                    return for_in(init);
                }
            }
            return regular_for(init);
        }
        function regular_for(init) {
            expect(";");
            var test = is("punc", ";") ? null : expression(true);
            expect(";");
            var step = is("punc", ")") ? null : expression(true);
            expect(")");
            return new AST_For({
                init: init,
                condition: test,
                step: step,
                body: in_loop(statement)
            });
        }
        function for_in(init) {
            var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
            var obj = expression(true);
            expect(")");
            return new AST_ForIn({
                init: init,
                name: lhs,
                object: obj,
                body: in_loop(statement)
            });
        }
        var function_ = function(in_statement, ctor) {
            var is_accessor = ctor === AST_Accessor;
            var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : is_accessor ? AST_SymbolAccessor : AST_SymbolLambda) : is_accessor && (is("string") || is("num")) ? as_atom_node() : null;
            if (in_statement && !name) unexpected();
            expect("(");
            if (!ctor) ctor = in_statement ? AST_Defun : AST_Function;
            return new ctor({
                name: name,
                argnames: function(first, a) {
                    while (!is("punc", ")")) {
                        if (first) first = false; else expect(",");
                        a.push(as_symbol(AST_SymbolFunarg));
                    }
                    next();
                    return a;
                }(true, []),
                body: function(loop, labels) {
                    ++S.in_function;
                    S.in_directives = true;
                    S.in_loop = 0;
                    S.labels = [];
                    var a = block_();
                    --S.in_function;
                    S.in_loop = loop;
                    S.labels = labels;
                    return a;
                }(S.in_loop, S.labels)
            });
        };
        function if_() {
            var cond = parenthesised(), body = statement(), belse = null;
            if (is("keyword", "else")) {
                next();
                belse = statement();
            }
            return new AST_If({
                condition: cond,
                body: body,
                alternative: belse
            });
        }
        function block_() {
            expect("{");
            var a = [];
            while (!is("punc", "}")) {
                if (is("eof")) unexpected();
                a.push(statement());
            }
            next();
            return a;
        }
        function switch_body_() {
            expect("{");
            var a = [], cur = null, branch = null, tmp;
            while (!is("punc", "}")) {
                if (is("eof")) unexpected();
                if (is("keyword", "case")) {
                    if (branch) branch.end = prev();
                    cur = [];
                    branch = new AST_Case({
                        start: (tmp = S.token, next(), tmp),
                        expression: expression(true),
                        body: cur
                    });
                    a.push(branch);
                    expect(":");
                } else if (is("keyword", "default")) {
                    if (branch) branch.end = prev();
                    cur = [];
                    branch = new AST_Default({
                        start: (tmp = S.token, next(), expect(":"), tmp),
                        body: cur
                    });
                    a.push(branch);
                } else {
                    if (!cur) unexpected();
                    cur.push(statement());
                }
            }
            if (branch) branch.end = prev();
            next();
            return a;
        }
        function try_() {
            var body = block_(), bcatch = null, bfinally = null;
            if (is("keyword", "catch")) {
                var start = S.token;
                next();
                expect("(");
                var name = as_symbol(AST_SymbolCatch);
                expect(")");
                bcatch = new AST_Catch({
                    start: start,
                    argname: name,
                    body: block_(),
                    end: prev()
                });
            }
            if (is("keyword", "finally")) {
                var start = S.token;
                next();
                bfinally = new AST_Finally({
                    start: start,
                    body: block_(),
                    end: prev()
                });
            }
            if (!bcatch && !bfinally) croak("Missing catch/finally blocks");
            return new AST_Try({
                body: body,
                bcatch: bcatch,
                bfinally: bfinally
            });
        }
        function vardefs(no_in, in_const) {
            var a = [];
            for (;;) {
                a.push(new AST_VarDef({
                    start: S.token,
                    name: as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                    value: is("operator", "=") ? (next(), expression(false, no_in)) : null,
                    end: prev()
                }));
                if (!is("punc", ",")) break;
                next();
            }
            return a;
        }
        var var_ = function(no_in) {
            return new AST_Var({
                start: prev(),
                definitions: vardefs(no_in, false),
                end: prev()
            });
        };
        var const_ = function() {
            return new AST_Const({
                start: prev(),
                definitions: vardefs(false, true),
                end: prev()
            });
        };
        var new_ = function() {
            var start = S.token;
            expect_token("operator", "new");
            var newexp = expr_atom(false), args;
            if (is("punc", "(")) {
                next();
                args = expr_list(")");
            } else {
                args = [];
            }
            return subscripts(new AST_New({
                start: start,
                expression: newexp,
                args: args,
                end: prev()
            }), true);
        };
        function as_atom_node() {
            var tok = S.token, ret;
            switch (tok.type) {
                case "name":
                    return as_symbol(AST_SymbolRef);

                case "num":
                    ret = new AST_Number({
                        start: tok,
                        end: tok,
                        value: tok.value
                    });
                    break;

                case "string":
                    ret = new AST_String({
                        start: tok,
                        end: tok,
                        value: tok.value
                    });
                    break;

                case "regexp":
                    ret = new AST_RegExp({
                        start: tok,
                        end: tok,
                        value: tok.value
                    });
                    break;

                case "atom":
                    switch (tok.value) {
                        case "false":
                            ret = new AST_False({
                                start: tok,
                                end: tok
                            });
                            break;

                        case "true":
                            ret = new AST_True({
                                start: tok,
                                end: tok
                            });
                            break;

                        case "null":
                            ret = new AST_Null({
                                start: tok,
                                end: tok
                            });
                            break;
                    }
                    break;
            }
            next();
            return ret;
        }
        var expr_atom = function(allow_calls) {
            if (is("operator", "new")) {
                return new_();
            }
            var start = S.token;
            if (is("punc")) {
                switch (start.value) {
                    case "(":
                        next();
                        var ex = expression(true);
                        ex.start = start;
                        ex.end = S.token;
                        expect(")");
                        return subscripts(ex, allow_calls);

                    case "[":
                        return subscripts(array_(), allow_calls);

                    case "{":
                        return subscripts(object_(), allow_calls);
                }
                unexpected();
            }
            if (is("keyword", "function")) {
                next();
                var func = function_(false);
                func.start = start;
                func.end = prev();
                return subscripts(func, allow_calls);
            }
            if (ATOMIC_START_TOKEN[S.token.type]) {
                return subscripts(as_atom_node(), allow_calls);
            }
            unexpected();
        };
        function expr_list(closing, allow_trailing_comma, allow_empty) {
            var first = true, a = [];
            while (!is("punc", closing)) {
                if (first) first = false; else expect(",");
                if (allow_trailing_comma && is("punc", closing)) break;
                if (is("punc", ",") && allow_empty) {
                    a.push(new AST_Hole({
                        start: S.token,
                        end: S.token
                    }));
                } else {
                    a.push(expression(false));
                }
            }
            next();
            return a;
        }
        var array_ = embed_tokens(function() {
            expect("[");
            return new AST_Array({
                elements: expr_list("]", !options.strict, true)
            });
        });
        var object_ = embed_tokens(function() {
            expect("{");
            var first = true, a = [];
            while (!is("punc", "}")) {
                if (first) first = false; else expect(",");
                if (!options.strict && is("punc", "}")) // allow trailing comma
                    break;
                var start = S.token;
                var type = start.type;
                var name = as_property_name();
                if (type == "name" && !is("punc", ":")) {
                    if (name == "get") {
                        a.push(new AST_ObjectGetter({
                            start: start,
                            key: name,
                            value: function_(false, AST_Accessor),
                            end: prev()
                        }));
                        continue;
                    }
                    if (name == "set") {
                        a.push(new AST_ObjectSetter({
                            start: start,
                            key: name,
                            value: function_(false, AST_Accessor),
                            end: prev()
                        }));
                        continue;
                    }
                }
                expect(":");
                a.push(new AST_ObjectKeyVal({
                    start: start,
                    key: name,
                    value: expression(false),
                    end: prev()
                }));
            }
            next();
            return new AST_Object({
                properties: a
            });
        });
        function as_property_name() {
            var tmp = S.token;
            next();
            switch (tmp.type) {
                case "num":
                case "string":
                case "name":
                case "operator":
                case "keyword":
                case "atom":
                    return tmp.value;

                default:
                    unexpected();
            }
        }
        function as_name() {
            var tmp = S.token;
            next();
            switch (tmp.type) {
                case "name":
                case "operator":
                case "keyword":
                case "atom":
                    return tmp.value;

                default:
                    unexpected();
            }
        }
        function as_symbol(type, noerror) {
            if (!is("name")) {
                if (!noerror) croak("Name expected");
                return null;
            }
            var name = S.token.value;
            var sym = new (name == "this" ? AST_This : type)({
                name: String(S.token.value),
                start: S.token,
                end: S.token
            });
            next();
            return sym;
        }
        var subscripts = function(expr, allow_calls) {
            var start = expr.start;
            if (is("punc", ".")) {
                next();
                return subscripts(new AST_Dot({
                    start: start,
                    expression: expr,
                    property: as_name(),
                    end: prev()
                }), allow_calls);
            }
            if (is("punc", "[")) {
                next();
                var prop = expression(true);
                expect("]");
                return subscripts(new AST_Sub({
                    start: start,
                    expression: expr,
                    property: prop,
                    end: prev()
                }), allow_calls);
            }
            if (allow_calls && is("punc", "(")) {
                next();
                return subscripts(new AST_Call({
                    start: start,
                    expression: expr,
                    args: expr_list(")"),
                    end: prev()
                }), true);
            }
            return expr;
        };
        var maybe_unary = function(allow_calls) {
            var start = S.token;
            if (is("operator") && UNARY_PREFIX(start.value)) {
                next();
                handle_regexp();
                var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
                ex.start = start;
                ex.end = prev();
                return ex;
            }
            var val = expr_atom(allow_calls);
            while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
                val = make_unary(AST_UnaryPostfix, S.token.value, val);
                val.start = start;
                val.end = S.token;
                next();
            }
            return val;
        };
        function make_unary(ctor, op, expr) {
            if ((op == "++" || op == "--") && !is_assignable(expr)) croak("Invalid use of " + op + " operator");
            return new ctor({
                operator: op,
                expression: expr
            });
        }
        var expr_op = function(left, min_prec, no_in) {
            var op = is("operator") ? S.token.value : null;
            if (op == "in" && no_in) op = null;
            var prec = op != null ? PRECEDENCE[op] : null;
            if (prec != null && prec > min_prec) {
                next();
                var right = expr_op(maybe_unary(true), prec, no_in);
                return expr_op(new AST_Binary({
                    start: left.start,
                    left: left,
                    operator: op,
                    right: right,
                    end: right.end
                }), min_prec, no_in);
            }
            return left;
        };
        function expr_ops(no_in) {
            return expr_op(maybe_unary(true), 0, no_in);
        }
        var maybe_conditional = function(no_in) {
            var start = S.token;
            var expr = expr_ops(no_in);
            if (is("operator", "?")) {
                next();
                var yes = expression(false);
                expect(":");
                return new AST_Conditional({
                    start: start,
                    condition: expr,
                    consequent: yes,
                    alternative: expression(false, no_in),
                    end: peek()
                });
            }
            return expr;
        };
        function is_assignable(expr) {
            if (!options.strict) return true;
            if (expr instanceof AST_This) return false;
            return expr instanceof AST_PropAccess || expr instanceof AST_Symbol;
        }
        var maybe_assign = function(no_in) {
            var start = S.token;
            var left = maybe_conditional(no_in), val = S.token.value;
            if (is("operator") && ASSIGNMENT(val)) {
                if (is_assignable(left)) {
                    next();
                    return new AST_Assign({
                        start: start,
                        left: left,
                        operator: val,
                        right: maybe_assign(no_in),
                        end: prev()
                    });
                }
                croak("Invalid assignment");
            }
            return left;
        };
        var expression = function(commas, no_in) {
            var start = S.token;
            var expr = maybe_assign(no_in);
            if (commas && is("punc", ",")) {
                next();
                return new AST_Seq({
                    start: start,
                    car: expr,
                    cdr: expression(true, no_in),
                    end: peek()
                });
            }
            return expr;
        };
        function in_loop(cont) {
            ++S.in_loop;
            var ret = cont();
            --S.in_loop;
            return ret;
        }
        if (options.expression) {
            return expression(true);
        }
        return function() {
            var start = S.token;
            var body = [];
            while (!is("eof")) body.push(statement());
            var end = prev();
            var toplevel = options.toplevel;
            if (toplevel) {
                toplevel.body = toplevel.body.concat(body);
                toplevel.end = end;
            } else {
                toplevel = new AST_Toplevel({
                    start: start,
                    body: body,
                    end: end
                });
            }
            return toplevel;
        }();
    }
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    // Tree transformer helpers.
    function TreeTransformer(before, after) {
        TreeWalker.call(this);
        this.before = before;
        this.after = after;
    }
    TreeTransformer.prototype = new TreeWalker();
    (function(undefined) {
        function _(node, descend) {
            node.DEFMETHOD("transform", function(tw, in_list) {
                var x, y;
                tw.push(this);
                if (tw.before) x = tw.before(this, descend, in_list);
                if (x === undefined) {
                    if (!tw.after) {
                        x = this;
                        descend(x, tw);
                    } else {
                        tw.stack[tw.stack.length - 1] = x = this.clone();
                        descend(x, tw);
                        y = tw.after(x, in_list);
                        if (y !== undefined) x = y;
                    }
                }
                tw.pop();
                return x;
            });
        }
        function do_list(list, tw) {
            return MAP(list, function(node) {
                return node.transform(tw, true);
            });
        }
        _(AST_Node, noop);
        _(AST_LabeledStatement, function(self, tw) {
            self.label = self.label.transform(tw);
            self.body = self.body.transform(tw);
        });
        _(AST_SimpleStatement, function(self, tw) {
            self.body = self.body.transform(tw);
        });
        _(AST_Block, function(self, tw) {
            self.body = do_list(self.body, tw);
        });
        _(AST_DWLoop, function(self, tw) {
            self.condition = self.condition.transform(tw);
            self.body = self.body.transform(tw);
        });
        _(AST_For, function(self, tw) {
            if (self.init) self.init = self.init.transform(tw);
            if (self.condition) self.condition = self.condition.transform(tw);
            if (self.step) self.step = self.step.transform(tw);
            self.body = self.body.transform(tw);
        });
        _(AST_ForIn, function(self, tw) {
            self.init = self.init.transform(tw);
            self.object = self.object.transform(tw);
            self.body = self.body.transform(tw);
        });
        _(AST_With, function(self, tw) {
            self.expression = self.expression.transform(tw);
            self.body = self.body.transform(tw);
        });
        _(AST_Exit, function(self, tw) {
            if (self.value) self.value = self.value.transform(tw);
        });
        _(AST_LoopControl, function(self, tw) {
            if (self.label) self.label = self.label.transform(tw);
        });
        _(AST_If, function(self, tw) {
            self.condition = self.condition.transform(tw);
            self.body = self.body.transform(tw);
            if (self.alternative) self.alternative = self.alternative.transform(tw);
        });
        _(AST_Switch, function(self, tw) {
            self.expression = self.expression.transform(tw);
            self.body = do_list(self.body, tw);
        });
        _(AST_Case, function(self, tw) {
            self.expression = self.expression.transform(tw);
            self.body = do_list(self.body, tw);
        });
        _(AST_Try, function(self, tw) {
            self.body = do_list(self.body, tw);
            if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
            if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
        });
        _(AST_Catch, function(self, tw) {
            self.argname = self.argname.transform(tw);
            self.body = do_list(self.body, tw);
        });
        _(AST_Definitions, function(self, tw) {
            self.definitions = do_list(self.definitions, tw);
        });
        _(AST_VarDef, function(self, tw) {
            self.name = self.name.transform(tw);
            if (self.value) self.value = self.value.transform(tw);
        });
        _(AST_Lambda, function(self, tw) {
            if (self.name) self.name = self.name.transform(tw);
            self.argnames = do_list(self.argnames, tw);
            self.body = do_list(self.body, tw);
        });
        _(AST_Call, function(self, tw) {
            self.expression = self.expression.transform(tw);
            self.args = do_list(self.args, tw);
        });
        _(AST_Seq, function(self, tw) {
            self.car = self.car.transform(tw);
            self.cdr = self.cdr.transform(tw);
        });
        _(AST_Dot, function(self, tw) {
            self.expression = self.expression.transform(tw);
        });
        _(AST_Sub, function(self, tw) {
            self.expression = self.expression.transform(tw);
            self.property = self.property.transform(tw);
        });
        _(AST_Unary, function(self, tw) {
            self.expression = self.expression.transform(tw);
        });
        _(AST_Binary, function(self, tw) {
            self.left = self.left.transform(tw);
            self.right = self.right.transform(tw);
        });
        _(AST_Conditional, function(self, tw) {
            self.condition = self.condition.transform(tw);
            self.consequent = self.consequent.transform(tw);
            self.alternative = self.alternative.transform(tw);
        });
        _(AST_Array, function(self, tw) {
            self.elements = do_list(self.elements, tw);
        });
        _(AST_Object, function(self, tw) {
            self.properties = do_list(self.properties, tw);
        });
        _(AST_ObjectProperty, function(self, tw) {
            self.value = self.value.transform(tw);
        });
    })();
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    function SymbolDef(scope, index, orig) {
        this.name = orig.name;
        this.orig = [ orig ];
        this.scope = scope;
        this.references = [];
        this.global = false;
        this.mangled_name = null;
        this.undeclared = false;
        this.constant = false;
        this.index = index;
    }
    SymbolDef.prototype = {
        unmangleable: function(options) {
            return this.global && !(options && options.toplevel) || this.undeclared || !(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with);
        },
        mangle: function(options) {
            if (!this.mangled_name && !this.unmangleable(options)) {
                var s = this.scope;
                if (this.orig[0] instanceof AST_SymbolLambda && !options.screw_ie8) s = s.parent_scope;
                this.mangled_name = s.next_mangled(options);
            }
        }
    };
    AST_Toplevel.DEFMETHOD("figure_out_scope", function() {
        // This does what ast_add_scope did in UglifyJS v1.
        //
        // Part of it could be done at parse time, but it would complicate
        // the parser (and it's already kinda complex).  It's also worth
        // having it separated because we might need to call it multiple
        // times on the same tree.
        // pass 1: setup scope chaining and handle definitions
        var self = this;
        var scope = self.parent_scope = null;
        var nesting = 0;
        var tw = new TreeWalker(function(node, descend) {
            if (node instanceof AST_Scope) {
                node.init_scope_vars(nesting);
                var save_scope = node.parent_scope = scope;
                ++nesting;
                scope = node;
                descend();
                scope = save_scope;
                --nesting;
                return true;
            }
            if (node instanceof AST_Directive) {
                node.scope = scope;
                push_uniq(scope.directives, node.value);
                return true;
            }
            if (node instanceof AST_With) {
                for (var s = scope; s; s = s.parent_scope) s.uses_with = true;
                return;
            }
            if (node instanceof AST_Symbol) {
                node.scope = scope;
            }
            if (node instanceof AST_SymbolLambda) {
                scope.def_function(node);
            } else if (node instanceof AST_SymbolDefun) {
                // Careful here, the scope where this should be defined is
                // the parent scope.  The reason is that we enter a new
                // scope when we encounter the AST_Defun node (which is
                // instanceof AST_Scope) but we get to the symbol a bit
                // later.
                (node.scope = scope.parent_scope).def_function(node);
            } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolConst) {
                var def = scope.def_variable(node);
                def.constant = node instanceof AST_SymbolConst;
                def.init = tw.parent().value;
            } else if (node instanceof AST_SymbolCatch) {
                // XXX: this is wrong according to ECMA-262 (12.4).  the
                // `catch` argument name should be visible only inside the
                // catch block.  For a quick fix AST_Catch should inherit
                // from AST_Scope.  Keeping it this way because of IE,
                // which doesn't obey the standard. (it introduces the
                // identifier in the enclosing scope)
                scope.def_variable(node);
            }
        });
        self.walk(tw);
        // pass 2: find back references and eval
        var func = null;
        var globals = self.globals = new Dictionary();
        var tw = new TreeWalker(function(node, descend) {
            if (node instanceof AST_Lambda) {
                var prev_func = func;
                func = node;
                descend();
                func = prev_func;
                return true;
            }
            if (node instanceof AST_SymbolRef) {
                var name = node.name;
                var sym = node.scope.find_variable(name);
                if (!sym) {
                    var g;
                    if (globals.has(name)) {
                        g = globals.get(name);
                    } else {
                        g = new SymbolDef(self, globals.size(), node);
                        g.undeclared = true;
                        g.global = true;
                        globals.set(name, g);
                    }
                    node.thedef = g;
                    if (name == "eval" && tw.parent() instanceof AST_Call) {
                        for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) s.uses_eval = true;
                    }
                    if (func && name == "arguments") {
                        func.uses_arguments = true;
                    }
                } else {
                    node.thedef = sym;
                }
                node.reference();
                return true;
            }
        });
        self.walk(tw);
    });
    AST_Scope.DEFMETHOD("init_scope_vars", function(nesting) {
        this.directives = [];
        // contains the directives defined in this scope, i.e. "use strict"
        this.variables = new Dictionary();
        // map name to AST_SymbolVar (variables defined in this scope; includes functions)
        this.functions = new Dictionary();
        // map name to AST_SymbolDefun (functions defined in this scope)
        this.uses_with = false;
        // will be set to true if this or some nested scope uses the `with` statement
        this.uses_eval = false;
        // will be set to true if this or nested scope uses the global `eval`
        this.parent_scope = null;
        // the parent scope
        this.enclosed = [];
        // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
        this.cname = -1;
        // the current index for mangling functions/variables
        this.nesting = nesting;
    });
    AST_Scope.DEFMETHOD("strict", function() {
        return this.has_directive("use strict");
    });
    AST_Lambda.DEFMETHOD("init_scope_vars", function() {
        AST_Scope.prototype.init_scope_vars.apply(this, arguments);
        this.uses_arguments = false;
    });
    AST_SymbolRef.DEFMETHOD("reference", function() {
        var def = this.definition();
        def.references.push(this);
        var s = this.scope;
        while (s) {
            push_uniq(s.enclosed, def);
            if (s === def.scope) break;
            s = s.parent_scope;
        }
        this.frame = this.scope.nesting - def.scope.nesting;
    });
    AST_Scope.DEFMETHOD("find_variable", function(name) {
        if (name instanceof AST_Symbol) name = name.name;
        return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
    });
    AST_Scope.DEFMETHOD("has_directive", function(value) {
        return this.parent_scope && this.parent_scope.has_directive(value) || (this.directives.indexOf(value) >= 0 ? this : null);
    });
    AST_Scope.DEFMETHOD("def_function", function(symbol) {
        this.functions.set(symbol.name, this.def_variable(symbol));
    });
    AST_Scope.DEFMETHOD("def_variable", function(symbol) {
        var def;
        if (!this.variables.has(symbol.name)) {
            def = new SymbolDef(this, this.variables.size(), symbol);
            this.variables.set(symbol.name, def);
            def.global = !this.parent_scope;
        } else {
            def = this.variables.get(symbol.name);
            def.orig.push(symbol);
        }
        return symbol.thedef = def;
    });
    AST_Scope.DEFMETHOD("next_mangled", function(options) {
        var ext = this.enclosed;
        out: while (true) {
            var m = base54(++this.cname);
            if (!is_identifier(m)) continue;
            // skip over "do"
            // we must ensure that the mangled name does not shadow a name
            // from some parent scope that is referenced in this or in
            // inner scopes.
            for (var i = ext.length; --i >= 0; ) {
                var sym = ext[i];
                var name = sym.mangled_name || sym.unmangleable(options) && sym.name;
                if (m == name) continue out;
            }
            return m;
        }
    });
    AST_Scope.DEFMETHOD("references", function(sym) {
        if (sym instanceof AST_Symbol) sym = sym.definition();
        return this.enclosed.indexOf(sym) < 0 ? null : sym;
    });
    AST_Symbol.DEFMETHOD("unmangleable", function(options) {
        return this.definition().unmangleable(options);
    });
    // property accessors are not mangleable
    AST_SymbolAccessor.DEFMETHOD("unmangleable", function() {
        return true;
    });
    // labels are always mangleable
    AST_Label.DEFMETHOD("unmangleable", function() {
        return false;
    });
    AST_Symbol.DEFMETHOD("unreferenced", function() {
        return this.definition().references.length == 0 && !(this.scope.uses_eval || this.scope.uses_with);
    });
    AST_Symbol.DEFMETHOD("undeclared", function() {
        return this.definition().undeclared;
    });
    AST_LabelRef.DEFMETHOD("undeclared", function() {
        return false;
    });
    AST_Label.DEFMETHOD("undeclared", function() {
        return false;
    });
    AST_Symbol.DEFMETHOD("definition", function() {
        return this.thedef;
    });
    AST_Symbol.DEFMETHOD("global", function() {
        return this.definition().global;
    });
    AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options) {
        return defaults(options, {
            except: [],
            eval: false,
            sort: false,
            toplevel: false,
            screw_ie8: false
        });
    });
    AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
        options = this._default_mangler_options(options);
        // We only need to mangle declaration nodes.  Special logic wired
        // into the code generator will display the mangled name if it's
        // present (and for AST_SymbolRef-s it'll use the mangled name of
        // the AST_SymbolDeclaration that it points to).
        var lname = -1;
        var to_mangle = [];
        var tw = new TreeWalker(function(node, descend) {
            if (node instanceof AST_LabeledStatement) {
                // lname is incremented when we get to the AST_Label
                var save_nesting = lname;
                descend();
                lname = save_nesting;
                return true;
            }
            if (node instanceof AST_Scope) {
                var p = tw.parent(), a = [];
                node.variables.each(function(symbol) {
                    if (options.except.indexOf(symbol.name) < 0) {
                        a.push(symbol);
                    }
                });
                if (options.sort) a.sort(function(a, b) {
                    return b.references.length - a.references.length;
                });
                to_mangle.push.apply(to_mangle, a);
                return;
            }
            if (node instanceof AST_Label) {
                var name;
                do name = base54(++lname); while (!is_identifier(name));
                node.mangled_name = name;
                return true;
            }
        });
        this.walk(tw);
        to_mangle.forEach(function(def) {
            def.mangle(options);
        });
    });
    AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
        options = this._default_mangler_options(options);
        var tw = new TreeWalker(function(node) {
            if (node instanceof AST_Constant) base54.consider(node.print_to_string()); else if (node instanceof AST_Return) base54.consider("return"); else if (node instanceof AST_Throw) base54.consider("throw"); else if (node instanceof AST_Continue) base54.consider("continue"); else if (node instanceof AST_Break) base54.consider("break"); else if (node instanceof AST_Debugger) base54.consider("debugger"); else if (node instanceof AST_Directive) base54.consider(node.value); else if (node instanceof AST_While) base54.consider("while"); else if (node instanceof AST_Do) base54.consider("do while"); else if (node instanceof AST_If) {
                base54.consider("if");
                if (node.alternative) base54.consider("else");
            } else if (node instanceof AST_Var) base54.consider("var"); else if (node instanceof AST_Const) base54.consider("const"); else if (node instanceof AST_Lambda) base54.consider("function"); else if (node instanceof AST_For) base54.consider("for"); else if (node instanceof AST_ForIn) base54.consider("for in"); else if (node instanceof AST_Switch) base54.consider("switch"); else if (node instanceof AST_Case) base54.consider("case"); else if (node instanceof AST_Default) base54.consider("default"); else if (node instanceof AST_With) base54.consider("with"); else if (node instanceof AST_ObjectSetter) base54.consider("set" + node.key); else if (node instanceof AST_ObjectGetter) base54.consider("get" + node.key); else if (node instanceof AST_ObjectKeyVal) base54.consider(node.key); else if (node instanceof AST_New) base54.consider("new"); else if (node instanceof AST_This) base54.consider("this"); else if (node instanceof AST_Try) base54.consider("try"); else if (node instanceof AST_Catch) base54.consider("catch"); else if (node instanceof AST_Finally) base54.consider("finally"); else if (node instanceof AST_Symbol && node.unmangleable(options)) base54.consider(node.name); else if (node instanceof AST_Unary || node instanceof AST_Binary) base54.consider(node.operator); else if (node instanceof AST_Dot) base54.consider(node.property);
        });
        this.walk(tw);
        base54.sort();
    });
    var base54 = function() {
        var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
        var chars, frequency;
        function reset() {
            frequency = Object.create(null);
            chars = string.split("").map(function(ch) {
                return ch.charCodeAt(0);
            });
            chars.forEach(function(ch) {
                frequency[ch] = 0;
            });
        }
        base54.consider = function(str) {
            for (var i = str.length; --i >= 0; ) {
                var code = str.charCodeAt(i);
                if (code in frequency) ++frequency[code];
            }
        };
        base54.sort = function() {
            chars = mergeSort(chars, function(a, b) {
                if (is_digit(a) && !is_digit(b)) return 1;
                if (is_digit(b) && !is_digit(a)) return -1;
                return frequency[b] - frequency[a];
            });
        };
        base54.reset = reset;
        reset();
        base54.get = function() {
            return chars;
        };
        base54.freq = function() {
            return frequency;
        };
        function base54(num) {
            var ret = "", base = 54;
            do {
                ret += String.fromCharCode(chars[num % base]);
                num = Math.floor(num / base);
                base = 64;
            } while (num > 0);
            return ret;
        }
        return base54;
    }();
    AST_Toplevel.DEFMETHOD("scope_warnings", function(options) {
        options = defaults(options, {
            undeclared: false,
            // this makes a lot of noise
            unreferenced: true,
            assign_to_global: true,
            func_arguments: true,
            nested_defuns: true,
            eval: true
        });
        var tw = new TreeWalker(function(node) {
            if (options.undeclared && node instanceof AST_SymbolRef && node.undeclared()) {
                // XXX: this also warns about JS standard names,
                // i.e. Object, Array, parseInt etc.  Should add a list of
                // exceptions.
                AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                    name: node.name,
                    file: node.start.file,
                    line: node.start.line,
                    col: node.start.col
                });
            }
            if (options.assign_to_global) {
                var sym = null;
                if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) sym = node.left; else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef) sym = node.init;
                if (sym && (sym.undeclared() || sym.global() && sym.scope !== sym.definition().scope)) {
                    AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                        msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                        name: sym.name,
                        file: sym.start.file,
                        line: sym.start.line,
                        col: sym.start.col
                    });
                }
            }
            if (options.eval && node instanceof AST_SymbolRef && node.undeclared() && node.name == "eval") {
                AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
            }
            if (options.unreferenced && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label) && node.unreferenced()) {
                AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                    type: node instanceof AST_Label ? "Label" : "Symbol",
                    name: node.name,
                    file: node.start.file,
                    line: node.start.line,
                    col: node.start.col
                });
            }
            if (options.func_arguments && node instanceof AST_Lambda && node.uses_arguments) {
                AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                    name: node.name ? node.name.name : "anonymous",
                    file: node.start.file,
                    line: node.start.line,
                    col: node.start.col
                });
            }
            if (options.nested_defuns && node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
                AST_Node.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', {
                    name: node.name.name,
                    type: tw.parent().TYPE,
                    file: node.start.file,
                    line: node.start.line,
                    col: node.start.col
                });
            }
        });
        this.walk(tw);
    });
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    function OutputStream(options) {
        options = defaults(options, {
            indent_start: 0,
            indent_level: 4,
            quote_keys: false,
            space_colon: true,
            ascii_only: false,
            inline_script: false,
            width: 80,
            max_line_len: 32e3,
            beautify: false,
            source_map: null,
            bracketize: false,
            semicolons: true,
            comments: false,
            preserve_line: false,
            screw_ie8: false
        }, true);
        var indentation = 0;
        var current_col = 0;
        var current_line = 1;
        var current_pos = 0;
        var OUTPUT = "";
        function to_ascii(str, identifier) {
            return str.replace(/[\u0080-\uffff]/g, function(ch) {
                var code = ch.charCodeAt(0).toString(16);
                if (code.length <= 2 && !identifier) {
                    while (code.length < 2) code = "0" + code;
                    return "\\x" + code;
                } else {
                    while (code.length < 4) code = "0" + code;
                    return "\\u" + code;
                }
            });
        }
        function make_string(str) {
            var dq = 0, sq = 0;
            str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s) {
                switch (s) {
                    case "\\":
                        return "\\\\";

                    case "\b":
                        return "\\b";

                    case "\f":
                        return "\\f";

                    case "\n":
                        return "\\n";

                    case "\r":
                        return "\\r";

                    case "\u2028":
                        return "\\u2028";

                    case "\u2029":
                        return "\\u2029";

                    case '"':
                        ++dq;
                        return '"';

                    case "'":
                        ++sq;
                        return "'";

                    case "\x00":
                        return "\\x00";
                }
                return s;
            });
            if (options.ascii_only) str = to_ascii(str);
            if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'"; else return '"' + str.replace(/\x22/g, '\\"') + '"';
        }
        function encode_string(str) {
            var ret = make_string(str);
            if (options.inline_script) ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
            return ret;
        }
        function make_name(name) {
            name = name.toString();
            if (options.ascii_only) name = to_ascii(name, true);
            return name;
        }
        function make_indent(back) {
            return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
        }
        /* -----[ beautification/minification ]----- */
        var might_need_space = false;
        var might_need_semicolon = false;
        var last = null;
        function last_char() {
            return last.charAt(last.length - 1);
        }
        function maybe_newline() {
            if (options.max_line_len && current_col > options.max_line_len) print("\n");
        }
        var requireSemicolonChars = makePredicate("( [ + * / - , .");
        function print(str) {
            str = String(str);
            var ch = str.charAt(0);
            if (might_need_semicolon) {
                if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                    if (options.semicolons || requireSemicolonChars(ch)) {
                        OUTPUT += ";";
                        current_col++;
                        current_pos++;
                    } else {
                        OUTPUT += "\n";
                        current_pos++;
                        current_line++;
                        current_col = 0;
                    }
                    if (!options.beautify) might_need_space = false;
                }
                might_need_semicolon = false;
                maybe_newline();
            }
            if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
                var target_line = stack[stack.length - 1].start.line;
                while (current_line < target_line) {
                    OUTPUT += "\n";
                    current_pos++;
                    current_line++;
                    current_col = 0;
                    might_need_space = false;
                }
            }
            if (might_need_space) {
                var prev = last_char();
                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || /^[\+\-\/]$/.test(ch) && ch == prev) {
                    OUTPUT += " ";
                    current_col++;
                    current_pos++;
                }
                might_need_space = false;
            }
            var a = str.split(/\r?\n/), n = a.length - 1;
            current_line += n;
            if (n == 0) {
                current_col += a[n].length;
            } else {
                current_col = a[n].length;
            }
            current_pos += str.length;
            last = str;
            OUTPUT += str;
        }
        var space = options.beautify ? function() {
            print(" ");
        } : function() {
            might_need_space = true;
        };
        var indent = options.beautify ? function(half) {
            if (options.beautify) {
                print(make_indent(half ? .5 : 0));
            }
        } : noop;
        var with_indent = options.beautify ? function(col, cont) {
            if (col === true) col = next_indent();
            var save_indentation = indentation;
            indentation = col;
            var ret = cont();
            indentation = save_indentation;
            return ret;
        } : function(col, cont) {
            return cont();
        };
        var newline = options.beautify ? function() {
            print("\n");
        } : noop;
        var semicolon = options.beautify ? function() {
            print(";");
        } : function() {
            might_need_semicolon = true;
        };
        function force_semicolon() {
            might_need_semicolon = false;
            print(";");
        }
        function next_indent() {
            return indentation + options.indent_level;
        }
        function with_block(cont) {
            var ret;
            print("{");
            newline();
            with_indent(next_indent(), function() {
                ret = cont();
            });
            indent();
            print("}");
            return ret;
        }
        function with_parens(cont) {
            print("(");
            //XXX: still nice to have that for argument lists
            //var ret = with_indent(current_col, cont);
            var ret = cont();
            print(")");
            return ret;
        }
        function with_square(cont) {
            print("[");
            //var ret = with_indent(current_col, cont);
            var ret = cont();
            print("]");
            return ret;
        }
        function comma() {
            print(",");
            space();
        }
        function colon() {
            print(":");
            if (options.space_colon) space();
        }
        var add_mapping = options.source_map ? function(token, name) {
            try {
                if (token) options.source_map.add(token.file || "?", current_line, current_col, token.line, token.col, !name && token.type == "name" ? token.value : name);
            } catch (ex) {
                AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                    file: token.file,
                    line: token.line,
                    col: token.col,
                    cline: current_line,
                    ccol: current_col,
                    name: name || ""
                });
            }
        } : noop;
        function get() {
            return OUTPUT;
        }
        var stack = [];
        return {
            get: get,
            toString: get,
            indent: indent,
            indentation: function() {
                return indentation;
            },
            current_width: function() {
                return current_col - indentation;
            },
            should_break: function() {
                return options.width && this.current_width() >= options.width;
            },
            newline: newline,
            print: print,
            space: space,
            comma: comma,
            colon: colon,
            last: function() {
                return last;
            },
            semicolon: semicolon,
            force_semicolon: force_semicolon,
            to_ascii: to_ascii,
            print_name: function(name) {
                print(make_name(name));
            },
            print_string: function(str) {
                print(encode_string(str));
            },
            next_indent: next_indent,
            with_indent: with_indent,
            with_block: with_block,
            with_parens: with_parens,
            with_square: with_square,
            add_mapping: add_mapping,
            option: function(opt) {
                return options[opt];
            },
            line: function() {
                return current_line;
            },
            col: function() {
                return current_col;
            },
            pos: function() {
                return current_pos;
            },
            push_node: function(node) {
                stack.push(node);
            },
            pop_node: function() {
                return stack.pop();
            },
            stack: function() {
                return stack;
            },
            parent: function(n) {
                return stack[stack.length - 2 - (n || 0)];
            }
        };
    }
    /* -----[ code generators ]----- */
    (function() {
        /* -----[ utils ]----- */
        function DEFPRINT(nodetype, generator) {
            nodetype.DEFMETHOD("_codegen", generator);
        }
        AST_Node.DEFMETHOD("print", function(stream, force_parens) {
            var self = this, generator = self._codegen;
            function doit() {
                self.add_comments(stream);
                self.add_source_map(stream);
                generator(self, stream);
            }
            stream.push_node(self);
            if (force_parens || self.needs_parens(stream)) {
                stream.with_parens(doit);
            } else {
                doit();
            }
            stream.pop_node();
        });
        AST_Node.DEFMETHOD("print_to_string", function(options) {
            var s = OutputStream(options);
            this.print(s);
            return s.get();
        });
        /* -----[ comments ]----- */
        AST_Node.DEFMETHOD("add_comments", function(output) {
            var c = output.option("comments"), self = this;
            if (c) {
                var start = self.start;
                if (start && !start._comments_dumped) {
                    start._comments_dumped = true;
                    var comments = start.comments_before;
                    // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                    //      if this node is `return` or `throw`, we cannot allow comments before
                    //      the returned or thrown value.
                    if (self instanceof AST_Exit && self.value && self.value.start.comments_before.length > 0) {
                        comments = (comments || []).concat(self.value.start.comments_before);
                        self.value.start.comments_before = [];
                    }
                    if (c.test) {
                        comments = comments.filter(function(comment) {
                            return c.test(comment.value);
                        });
                    } else if (typeof c == "function") {
                        comments = comments.filter(function(comment) {
                            return c(self, comment);
                        });
                    }
                    comments.forEach(function(c) {
                        if (/comment[134]/.test(c.type)) {
                            output.print("//" + c.value + "\n");
                            output.indent();
                        } else if (c.type == "comment2") {
                            output.print("/*" + c.value + "*/");
                            if (start.nlb) {
                                output.print("\n");
                                output.indent();
                            } else {
                                output.space();
                            }
                        }
                    });
                }
            }
        });
        /* -----[ PARENTHESES ]----- */
        function PARENS(nodetype, func) {
            nodetype.DEFMETHOD("needs_parens", func);
        }
        PARENS(AST_Node, function() {
            return false;
        });
        // a function expression needs parens around it when it's provably
        // the first token to appear in a statement.
        PARENS(AST_Function, function(output) {
            return first_in_statement(output);
        });
        // same goes for an object literal, because otherwise it would be
        // interpreted as a block of code.
        PARENS(AST_Object, function(output) {
            return first_in_statement(output);
        });
        PARENS(AST_Unary, function(output) {
            var p = output.parent();
            return p instanceof AST_PropAccess && p.expression === this;
        });
        PARENS(AST_Seq, function(output) {
            var p = output.parent();
            return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_Dot || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional;
        });
        PARENS(AST_Binary, function(output) {
            var p = output.parent();
            // (foo && bar)()
            if (p instanceof AST_Call && p.expression === this) return true;
            // typeof (foo && bar)
            if (p instanceof AST_Unary) return true;
            // (foo && bar)["prop"], (foo && bar).prop
            if (p instanceof AST_PropAccess && p.expression === this) return true;
            // this deals with precedence: 3 * (2 + 1)
            if (p instanceof AST_Binary) {
                var po = p.operator, pp = PRECEDENCE[po];
                var so = this.operator, sp = PRECEDENCE[so];
                if (pp > sp || pp == sp && this === p.right && !(so == po && (so == "*" || so == "&&" || so == "||"))) {
                    return true;
                }
            }
        });
        PARENS(AST_PropAccess, function(output) {
            var p = output.parent();
            if (p instanceof AST_New && p.expression === this) {
                // i.e. new (foo.bar().baz)
                //
                // if there's one call into this subtree, then we need
                // parens around it too, otherwise the call will be
                // interpreted as passing the arguments to the upper New
                // expression.
                try {
                    this.walk(new TreeWalker(function(node) {
                        if (node instanceof AST_Call) throw p;
                    }));
                } catch (ex) {
                    if (ex !== p) throw ex;
                    return true;
                }
            }
        });
        PARENS(AST_Call, function(output) {
            var p = output.parent();
            return p instanceof AST_New && p.expression === this;
        });
        PARENS(AST_New, function(output) {
            var p = output.parent();
            if (no_constructor_parens(this, output) && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
                return true;
        });
        PARENS(AST_Number, function(output) {
            var p = output.parent();
            if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this) return true;
        });
        PARENS(AST_NaN, function(output) {
            var p = output.parent();
            if (p instanceof AST_PropAccess && p.expression === this) return true;
        });
        function assign_and_conditional_paren_rules(output) {
            var p = output.parent();
            // !(a = false) → true
            if (p instanceof AST_Unary) return true;
            // 1 + (a = 2) + 3 → 6, side effect setting a = 2
            if (p instanceof AST_Binary && !(p instanceof AST_Assign)) return true;
            // (a = func)() —or— new (a = Object)()
            if (p instanceof AST_Call && p.expression === this) return true;
            // (a = foo) ? bar : baz
            if (p instanceof AST_Conditional && p.condition === this) return true;
            // (a = foo)["prop"] —or— (a = foo).prop
            if (p instanceof AST_PropAccess && p.expression === this) return true;
        }
        PARENS(AST_Assign, assign_and_conditional_paren_rules);
        PARENS(AST_Conditional, assign_and_conditional_paren_rules);
        /* -----[ PRINTERS ]----- */
        DEFPRINT(AST_Directive, function(self, output) {
            output.print_string(self.value);
            output.semicolon();
        });
        DEFPRINT(AST_Debugger, function(self, output) {
            output.print("debugger");
            output.semicolon();
        });
        /* -----[ statements ]----- */
        function display_body(body, is_toplevel, output) {
            var last = body.length - 1;
            body.forEach(function(stmt, i) {
                if (!(stmt instanceof AST_EmptyStatement)) {
                    output.indent();
                    stmt.print(output);
                    if (!(i == last && is_toplevel)) {
                        output.newline();
                        if (is_toplevel) output.newline();
                    }
                }
            });
        }
        AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
            force_statement(this.body, output);
        });
        DEFPRINT(AST_Statement, function(self, output) {
            self.body.print(output);
            output.semicolon();
        });
        DEFPRINT(AST_Toplevel, function(self, output) {
            display_body(self.body, true, output);
            output.print("");
        });
        DEFPRINT(AST_LabeledStatement, function(self, output) {
            self.label.print(output);
            output.colon();
            self.body.print(output);
        });
        DEFPRINT(AST_SimpleStatement, function(self, output) {
            self.body.print(output);
            output.semicolon();
        });
        function print_bracketed(body, output) {
            if (body.length > 0) output.with_block(function() {
                display_body(body, false, output);
            }); else output.print("{}");
        }
        DEFPRINT(AST_BlockStatement, function(self, output) {
            print_bracketed(self.body, output);
        });
        DEFPRINT(AST_EmptyStatement, function(self, output) {
            output.semicolon();
        });
        DEFPRINT(AST_Do, function(self, output) {
            output.print("do");
            output.space();
            self._do_print_body(output);
            output.space();
            output.print("while");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.semicolon();
        });
        DEFPRINT(AST_While, function(self, output) {
            output.print("while");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.space();
            self._do_print_body(output);
        });
        DEFPRINT(AST_For, function(self, output) {
            output.print("for");
            output.space();
            output.with_parens(function() {
                if (self.init) {
                    if (self.init instanceof AST_Definitions) {
                        self.init.print(output);
                    } else {
                        parenthesize_for_noin(self.init, output, true);
                    }
                    output.print(";");
                    output.space();
                } else {
                    output.print(";");
                }
                if (self.condition) {
                    self.condition.print(output);
                    output.print(";");
                    output.space();
                } else {
                    output.print(";");
                }
                if (self.step) {
                    self.step.print(output);
                }
            });
            output.space();
            self._do_print_body(output);
        });
        DEFPRINT(AST_ForIn, function(self, output) {
            output.print("for");
            output.space();
            output.with_parens(function() {
                self.init.print(output);
                output.space();
                output.print("in");
                output.space();
                self.object.print(output);
            });
            output.space();
            self._do_print_body(output);
        });
        DEFPRINT(AST_With, function(self, output) {
            output.print("with");
            output.space();
            output.with_parens(function() {
                self.expression.print(output);
            });
            output.space();
            self._do_print_body(output);
        });
        /* -----[ functions ]----- */
        AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
            var self = this;
            if (!nokeyword) {
                output.print("function");
            }
            if (self.name) {
                output.space();
                self.name.print(output);
            }
            output.with_parens(function() {
                self.argnames.forEach(function(arg, i) {
                    if (i) output.comma();
                    arg.print(output);
                });
            });
            output.space();
            print_bracketed(self.body, output);
        });
        DEFPRINT(AST_Lambda, function(self, output) {
            self._do_print(output);
        });
        /* -----[ exits ]----- */
        AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
            output.print(kind);
            if (this.value) {
                output.space();
                this.value.print(output);
            }
            output.semicolon();
        });
        DEFPRINT(AST_Return, function(self, output) {
            self._do_print(output, "return");
        });
        DEFPRINT(AST_Throw, function(self, output) {
            self._do_print(output, "throw");
        });
        /* -----[ loop control ]----- */
        AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
            output.print(kind);
            if (this.label) {
                output.space();
                this.label.print(output);
            }
            output.semicolon();
        });
        DEFPRINT(AST_Break, function(self, output) {
            self._do_print(output, "break");
        });
        DEFPRINT(AST_Continue, function(self, output) {
            self._do_print(output, "continue");
        });
        /* -----[ if ]----- */
        function make_then(self, output) {
            if (output.option("bracketize")) {
                make_block(self.body, output);
                return;
            }
            // The squeezer replaces "block"-s that contain only a single
            // statement with the statement itself; technically, the AST
            // is correct, but this can create problems when we output an
            // IF having an ELSE clause where the THEN clause ends in an
            // IF *without* an ELSE block (then the outer ELSE would refer
            // to the inner IF).  This function checks for this case and
            // adds the block brackets if needed.
            if (!self.body) return output.force_semicolon();
            if (self.body instanceof AST_Do && !output.option("screw_ie8")) {
                // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
                // croaks with "syntax error" on code like this: if (foo)
                // do ... while(cond); else ...  we need block brackets
                // around do/while
                make_block(self.body, output);
                return;
            }
            var b = self.body;
            while (true) {
                if (b instanceof AST_If) {
                    if (!b.alternative) {
                        make_block(self.body, output);
                        return;
                    }
                    b = b.alternative;
                } else if (b instanceof AST_StatementWithBody) {
                    b = b.body;
                } else break;
            }
            force_statement(self.body, output);
        }
        DEFPRINT(AST_If, function(self, output) {
            output.print("if");
            output.space();
            output.with_parens(function() {
                self.condition.print(output);
            });
            output.space();
            if (self.alternative) {
                make_then(self, output);
                output.space();
                output.print("else");
                output.space();
                force_statement(self.alternative, output);
            } else {
                self._do_print_body(output);
            }
        });
        /* -----[ switch ]----- */
        DEFPRINT(AST_Switch, function(self, output) {
            output.print("switch");
            output.space();
            output.with_parens(function() {
                self.expression.print(output);
            });
            output.space();
            if (self.body.length > 0) output.with_block(function() {
                self.body.forEach(function(stmt, i) {
                    if (i) output.newline();
                    output.indent(true);
                    stmt.print(output);
                });
            }); else output.print("{}");
        });
        AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
            if (this.body.length > 0) {
                output.newline();
                this.body.forEach(function(stmt) {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            }
        });
        DEFPRINT(AST_Default, function(self, output) {
            output.print("default:");
            self._do_print_body(output);
        });
        DEFPRINT(AST_Case, function(self, output) {
            output.print("case");
            output.space();
            self.expression.print(output);
            output.print(":");
            self._do_print_body(output);
        });
        /* -----[ exceptions ]----- */
        DEFPRINT(AST_Try, function(self, output) {
            output.print("try");
            output.space();
            print_bracketed(self.body, output);
            if (self.bcatch) {
                output.space();
                self.bcatch.print(output);
            }
            if (self.bfinally) {
                output.space();
                self.bfinally.print(output);
            }
        });
        DEFPRINT(AST_Catch, function(self, output) {
            output.print("catch");
            output.space();
            output.with_parens(function() {
                self.argname.print(output);
            });
            output.space();
            print_bracketed(self.body, output);
        });
        DEFPRINT(AST_Finally, function(self, output) {
            output.print("finally");
            output.space();
            print_bracketed(self.body, output);
        });
        /* -----[ var/const ]----- */
        AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
            output.print(kind);
            output.space();
            this.definitions.forEach(function(def, i) {
                if (i) output.comma();
                def.print(output);
            });
            var p = output.parent();
            var in_for = p instanceof AST_For || p instanceof AST_ForIn;
            var avoid_semicolon = in_for && p.init === this;
            if (!avoid_semicolon) output.semicolon();
        });
        DEFPRINT(AST_Var, function(self, output) {
            self._do_print(output, "var");
        });
        DEFPRINT(AST_Const, function(self, output) {
            self._do_print(output, "const");
        });
        function parenthesize_for_noin(node, output, noin) {
            if (!noin) node.print(output); else try {
                // need to take some precautions here:
                //    https://github.com/mishoo/UglifyJS2/issues/60
                node.walk(new TreeWalker(function(node) {
                    if (node instanceof AST_Binary && node.operator == "in") throw output;
                }));
                node.print(output);
            } catch (ex) {
                if (ex !== output) throw ex;
                node.print(output, true);
            }
        }
        DEFPRINT(AST_VarDef, function(self, output) {
            self.name.print(output);
            if (self.value) {
                output.space();
                output.print("=");
                output.space();
                var p = output.parent(1);
                var noin = p instanceof AST_For || p instanceof AST_ForIn;
                parenthesize_for_noin(self.value, output, noin);
            }
        });
        /* -----[ other expressions ]----- */
        DEFPRINT(AST_Call, function(self, output) {
            self.expression.print(output);
            if (self instanceof AST_New && no_constructor_parens(self, output)) return;
            output.with_parens(function() {
                self.args.forEach(function(expr, i) {
                    if (i) output.comma();
                    expr.print(output);
                });
            });
        });
        DEFPRINT(AST_New, function(self, output) {
            output.print("new");
            output.space();
            AST_Call.prototype._codegen(self, output);
        });
        AST_Seq.DEFMETHOD("_do_print", function(output) {
            this.car.print(output);
            if (this.cdr) {
                output.comma();
                if (output.should_break()) {
                    output.newline();
                    output.indent();
                }
                this.cdr.print(output);
            }
        });
        DEFPRINT(AST_Seq, function(self, output) {
            self._do_print(output);
        });
        DEFPRINT(AST_Dot, function(self, output) {
            var expr = self.expression;
            expr.print(output);
            if (expr instanceof AST_Number && expr.getValue() >= 0) {
                if (!/[xa-f.]/i.test(output.last())) {
                    output.print(".");
                }
            }
            output.print(".");
            // the name after dot would be mapped about here.
            output.add_mapping(self.end);
            output.print_name(self.property);
        });
        DEFPRINT(AST_Sub, function(self, output) {
            self.expression.print(output);
            output.print("[");
            self.property.print(output);
            output.print("]");
        });
        DEFPRINT(AST_UnaryPrefix, function(self, output) {
            var op = self.operator;
            output.print(op);
            if (/^[a-z]/i.test(op)) output.space();
            self.expression.print(output);
        });
        DEFPRINT(AST_UnaryPostfix, function(self, output) {
            self.expression.print(output);
            output.print(self.operator);
        });
        DEFPRINT(AST_Binary, function(self, output) {
            self.left.print(output);
            output.space();
            output.print(self.operator);
            if (self.operator == "<" && self.right instanceof AST_UnaryPrefix && self.right.operator == "!" && self.right.expression instanceof AST_UnaryPrefix && self.right.expression.operator == "--") {
                // space is mandatory to avoid outputting <!--
                // http://javascript.spec.whatwg.org/#comment-syntax
                output.print(" ");
            } else {
                // the space is optional depending on "beautify"
                output.space();
            }
            self.right.print(output);
        });
        DEFPRINT(AST_Conditional, function(self, output) {
            self.condition.print(output);
            output.space();
            output.print("?");
            output.space();
            self.consequent.print(output);
            output.space();
            output.colon();
            self.alternative.print(output);
        });
        /* -----[ literals ]----- */
        DEFPRINT(AST_Array, function(self, output) {
            output.with_square(function() {
                var a = self.elements, len = a.length;
                if (len > 0) output.space();
                a.forEach(function(exp, i) {
                    if (i) output.comma();
                    exp.print(output);
                    // If the final element is a hole, we need to make sure it
                    // doesn't look like a trailing comma, by inserting an actual
                    // trailing comma.
                    if (i === len - 1 && exp instanceof AST_Hole) output.comma();
                });
                if (len > 0) output.space();
            });
        });
        DEFPRINT(AST_Object, function(self, output) {
            if (self.properties.length > 0) output.with_block(function() {
                self.properties.forEach(function(prop, i) {
                    if (i) {
                        output.print(",");
                        output.newline();
                    }
                    output.indent();
                    prop.print(output);
                });
                output.newline();
            }); else output.print("{}");
        });
        DEFPRINT(AST_ObjectKeyVal, function(self, output) {
            var key = self.key;
            if (output.option("quote_keys")) {
                output.print_string(key + "");
            } else if ((typeof key == "number" || !output.option("beautify") && +key + "" == key) && parseFloat(key) >= 0) {
                output.print(make_num(key));
            } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
                output.print_name(key);
            } else {
                output.print_string(key);
            }
            output.colon();
            self.value.print(output);
        });
        DEFPRINT(AST_ObjectSetter, function(self, output) {
            output.print("set");
            self.value._do_print(output, true);
        });
        DEFPRINT(AST_ObjectGetter, function(self, output) {
            output.print("get");
            self.value._do_print(output, true);
        });
        DEFPRINT(AST_Symbol, function(self, output) {
            var def = self.definition();
            output.print_name(def ? def.mangled_name || def.name : self.name);
        });
        DEFPRINT(AST_Undefined, function(self, output) {
            output.print("void 0");
        });
        DEFPRINT(AST_Hole, noop);
        DEFPRINT(AST_Infinity, function(self, output) {
            output.print("1/0");
        });
        DEFPRINT(AST_NaN, function(self, output) {
            output.print("0/0");
        });
        DEFPRINT(AST_This, function(self, output) {
            output.print("this");
        });
        DEFPRINT(AST_Constant, function(self, output) {
            output.print(self.getValue());
        });
        DEFPRINT(AST_String, function(self, output) {
            output.print_string(self.getValue());
        });
        DEFPRINT(AST_Number, function(self, output) {
            output.print(make_num(self.getValue()));
        });
        DEFPRINT(AST_RegExp, function(self, output) {
            var str = self.getValue().toString();
            if (output.option("ascii_only")) str = output.to_ascii(str);
            output.print(str);
            var p = output.parent();
            if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self) output.print(" ");
        });
        function force_statement(stat, output) {
            if (output.option("bracketize")) {
                if (!stat || stat instanceof AST_EmptyStatement) output.print("{}"); else if (stat instanceof AST_BlockStatement) stat.print(output); else output.with_block(function() {
                    output.indent();
                    stat.print(output);
                    output.newline();
                });
            } else {
                if (!stat || stat instanceof AST_EmptyStatement) output.force_semicolon(); else stat.print(output);
            }
        }
        // return true if the node at the top of the stack (that means the
        // innermost node in the current output) is lexically the first in
        // a statement.
        function first_in_statement(output) {
            var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
            while (i > 0) {
                if (p instanceof AST_Statement && p.body === node) return true;
                if (p instanceof AST_Seq && p.car === node || p instanceof AST_Call && p.expression === node && !(p instanceof AST_New) || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {
                    node = p;
                    p = a[--i];
                } else {
                    return false;
                }
            }
        }
        // self should be AST_New.  decide if we want to show parens or not.
        function no_constructor_parens(self, output) {
            return self.args.length == 0 && !output.option("beautify");
        }
        function best_of(a) {
            var best = a[0], len = best.length;
            for (var i = 1; i < a.length; ++i) {
                if (a[i].length < len) {
                    best = a[i];
                    len = best.length;
                }
            }
            return best;
        }
        function make_num(num) {
            var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace("e+", "e") ], m;
            if (Math.floor(num) === num) {
                if (num >= 0) {
                    a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                        "0" + num.toString(8));
                } else {
                    a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                        "-0" + (-num).toString(8));
                }
                if (m = /^(.*?)(0+)$/.exec(num)) {
                    a.push(m[1] + "e" + m[2].length);
                }
            } else if (m = /^0?\.(0+)(.*)$/.exec(num)) {
                a.push(m[2] + "e-" + (m[1].length + m[2].length), str.substr(str.indexOf(".")));
            }
            return best_of(a);
        }
        function make_block(stmt, output) {
            if (stmt instanceof AST_BlockStatement) {
                stmt.print(output);
                return;
            }
            output.with_block(function() {
                output.indent();
                stmt.print(output);
                output.newline();
            });
        }
        /* -----[ source map generators ]----- */
        function DEFMAP(nodetype, generator) {
            nodetype.DEFMETHOD("add_source_map", function(stream) {
                generator(this, stream);
            });
        }
        // We could easily add info for ALL nodes, but it seems to me that
        // would be quite wasteful, hence this noop in the base class.
        DEFMAP(AST_Node, noop);
        function basic_sourcemap_gen(self, output) {
            output.add_mapping(self.start);
        }
        // XXX: I'm not exactly sure if we need it for all of these nodes,
        // or if we should add even more.
        DEFMAP(AST_Directive, basic_sourcemap_gen);
        DEFMAP(AST_Debugger, basic_sourcemap_gen);
        DEFMAP(AST_Symbol, basic_sourcemap_gen);
        DEFMAP(AST_Jump, basic_sourcemap_gen);
        DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
        DEFMAP(AST_LabeledStatement, noop);
        // since the label symbol will mark it
        DEFMAP(AST_Lambda, basic_sourcemap_gen);
        DEFMAP(AST_Switch, basic_sourcemap_gen);
        DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
        DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
        DEFMAP(AST_Toplevel, noop);
        DEFMAP(AST_New, basic_sourcemap_gen);
        DEFMAP(AST_Try, basic_sourcemap_gen);
        DEFMAP(AST_Catch, basic_sourcemap_gen);
        DEFMAP(AST_Finally, basic_sourcemap_gen);
        DEFMAP(AST_Definitions, basic_sourcemap_gen);
        DEFMAP(AST_Constant, basic_sourcemap_gen);
        DEFMAP(AST_ObjectProperty, function(self, output) {
            output.add_mapping(self.start, self.key);
        });
    })();
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    function Compressor(options, false_by_default) {
        if (!(this instanceof Compressor)) return new Compressor(options, false_by_default);
        TreeTransformer.call(this, this.before, this.after);
        this.options = defaults(options, {
            sequences: !false_by_default,
            properties: !false_by_default,
            dead_code: !false_by_default,
            drop_debugger: !false_by_default,
            unsafe: false,
            unsafe_comps: false,
            conditionals: !false_by_default,
            comparisons: !false_by_default,
            evaluate: !false_by_default,
            booleans: !false_by_default,
            loops: !false_by_default,
            unused: !false_by_default,
            hoist_funs: !false_by_default,
            hoist_vars: false,
            if_return: !false_by_default,
            join_vars: !false_by_default,
            cascade: !false_by_default,
            side_effects: !false_by_default,
            pure_getters: false,
            pure_funcs: null,
            negate_iife: !false_by_default,
            screw_ie8: false,
            warnings: true,
            global_defs: {}
        }, true);
    }
    Compressor.prototype = new TreeTransformer();
    merge(Compressor.prototype, {
        option: function(key) {
            return this.options[key];
        },
        warn: function() {
            if (this.options.warnings) AST_Node.warn.apply(AST_Node, arguments);
        },
        before: function(node, descend, in_list) {
            if (node._squeezed) return node;
            if (node instanceof AST_Scope) {
                node.drop_unused(this);
                node = node.hoist_declarations(this);
            }
            descend(node, this);
            node = node.optimize(this);
            if (node instanceof AST_Scope) {
                node.drop_unused(this);
            }
            node._squeezed = true;
            return node;
        }
    });
    (function() {
        function OPT(node, optimizer) {
            node.DEFMETHOD("optimize", function(compressor) {
                var self = this;
                if (self._optimized) return self;
                var opt = optimizer(self, compressor);
                opt._optimized = true;
                if (opt === self) return opt;
                return opt.transform(compressor);
            });
        }
        OPT(AST_Node, function(self, compressor) {
            return self;
        });
        AST_Node.DEFMETHOD("equivalent_to", function(node) {
            // XXX: this is a rather expensive way to test two node's equivalence:
            return this.print_to_string() == node.print_to_string();
        });
        function make_node(ctor, orig, props) {
            if (!props) props = {};
            if (orig) {
                if (!props.start) props.start = orig.start;
                if (!props.end) props.end = orig.end;
            }
            return new ctor(props);
        }
        function make_node_from_constant(compressor, val, orig) {
            // XXX: WIP.
            // if (val instanceof AST_Node) return val.transform(new TreeTransformer(null, function(node){
            //     if (node instanceof AST_SymbolRef) {
            //         var scope = compressor.find_parent(AST_Scope);
            //         var def = scope.find_variable(node);
            //         node.thedef = def;
            //         return node;
            //     }
            // })).transform(compressor);
            if (val instanceof AST_Node) return val.transform(compressor);
            switch (typeof val) {
                case "string":
                    return make_node(AST_String, orig, {
                        value: val
                    }).optimize(compressor);

                case "number":
                    return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                        value: val
                    }).optimize(compressor);

                case "boolean":
                    return make_node(val ? AST_True : AST_False, orig).optimize(compressor);

                case "undefined":
                    return make_node(AST_Undefined, orig).optimize(compressor);

                default:
                    if (val === null) {
                        return make_node(AST_Null, orig).optimize(compressor);
                    }
                    if (val instanceof RegExp) {
                        return make_node(AST_RegExp, orig).optimize(compressor);
                    }
                    throw new Error(string_template("Can't handle constant of type: {type}", {
                        type: typeof val
                    }));
            }
        }
        function as_statement_array(thing) {
            if (thing === null) return [];
            if (thing instanceof AST_BlockStatement) return thing.body;
            if (thing instanceof AST_EmptyStatement) return [];
            if (thing instanceof AST_Statement) return [ thing ];
            throw new Error("Can't convert thing to statement array");
        }
        function is_empty(thing) {
            if (thing === null) return true;
            if (thing instanceof AST_EmptyStatement) return true;
            if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
            return false;
        }
        function loop_body(x) {
            if (x instanceof AST_Switch) return x;
            if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
                return x.body instanceof AST_BlockStatement ? x.body : x;
            }
            return x;
        }
        function tighten_body(statements, compressor) {
            var CHANGED;
            do {
                CHANGED = false;
                statements = eliminate_spurious_blocks(statements);
                if (compressor.option("dead_code")) {
                    statements = eliminate_dead_code(statements, compressor);
                }
                if (compressor.option("if_return")) {
                    statements = handle_if_return(statements, compressor);
                }
                if (compressor.option("sequences")) {
                    statements = sequencesize(statements, compressor);
                }
                if (compressor.option("join_vars")) {
                    statements = join_consecutive_vars(statements, compressor);
                }
            } while (CHANGED);
            if (compressor.option("negate_iife")) {
                negate_iifes(statements, compressor);
            }
            return statements;
            function eliminate_spurious_blocks(statements) {
                var seen_dirs = [];
                return statements.reduce(function(a, stat) {
                    if (stat instanceof AST_BlockStatement) {
                        CHANGED = true;
                        a.push.apply(a, eliminate_spurious_blocks(stat.body));
                    } else if (stat instanceof AST_EmptyStatement) {
                        CHANGED = true;
                    } else if (stat instanceof AST_Directive) {
                        if (seen_dirs.indexOf(stat.value) < 0) {
                            a.push(stat);
                            seen_dirs.push(stat.value);
                        } else {
                            CHANGED = true;
                        }
                    } else {
                        a.push(stat);
                    }
                    return a;
                }, []);
            }
            function handle_if_return(statements, compressor) {
                var self = compressor.self();
                var in_lambda = self instanceof AST_Lambda;
                var ret = [];
                loop: for (var i = statements.length; --i >= 0; ) {
                    var stat = statements[i];
                    switch (true) {
                        case in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0:
                            CHANGED = true;
                            // note, ret.length is probably always zero
                            // because we drop unreachable code before this
                            // step.  nevertheless, it's good to check.
                            continue loop;

                        case stat instanceof AST_If:
                            if (stat.body instanceof AST_Return) {
                                //---
                                // pretty silly case, but:
                                // if (foo()) return; return; ==> foo(); return;
                                if ((in_lambda && ret.length == 0 || ret[0] instanceof AST_Return && !ret[0].value) && !stat.body.value && !stat.alternative) {
                                    CHANGED = true;
                                    var cond = make_node(AST_SimpleStatement, stat.condition, {
                                        body: stat.condition
                                    });
                                    ret.unshift(cond);
                                    continue loop;
                                }
                                //---
                                // if (foo()) return x; return y; ==> return foo() ? x : y;
                                if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0];
                                    ret[0] = stat.transform(compressor);
                                    continue loop;
                                }
                                //---
                                // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
                                if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                            value: make_node(AST_Undefined, stat)
                                        });
                                    ret[0] = stat.transform(compressor);
                                    continue loop;
                                }
                                //---
                                // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
                                if (!stat.body.value && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.condition = stat.condition.negate(compressor);
                                    stat.body = make_node(AST_BlockStatement, stat, {
                                        body: as_statement_array(stat.alternative).concat(ret)
                                    });
                                    stat.alternative = null;
                                    ret = [ stat.transform(compressor) ];
                                    continue loop;
                                }
                                //---
                                if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                                    CHANGED = true;
                                    ret.push(make_node(AST_Return, ret[0], {
                                        value: make_node(AST_Undefined, ret[0])
                                    }).transform(compressor));
                                    ret = as_statement_array(stat.alternative).concat(ret);
                                    ret.unshift(stat);
                                    continue loop;
                                }
                            }
                            var ab = aborts(stat.body);
                            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                var body = as_statement_array(stat.body).slice(0, -1);
                                stat = stat.clone();
                                stat.condition = stat.condition.negate(compressor);
                                stat.body = make_node(AST_BlockStatement, stat, {
                                    body: ret
                                });
                                stat.alternative = make_node(AST_BlockStatement, stat, {
                                    body: body
                                });
                                ret = [ stat.transform(compressor) ];
                                continue loop;
                            }
                            var ab = aborts(stat.alternative);
                            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                stat = stat.clone();
                                stat.body = make_node(AST_BlockStatement, stat.body, {
                                    body: as_statement_array(stat.body).concat(ret)
                                });
                                stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                                    body: as_statement_array(stat.alternative).slice(0, -1)
                                });
                                ret = [ stat.transform(compressor) ];
                                continue loop;
                            }
                            ret.unshift(stat);
                            break;

                        default:
                            ret.unshift(stat);
                            break;
                    }
                }
                return ret;
            }
            function eliminate_dead_code(statements, compressor) {
                var has_quit = false;
                var orig = statements.length;
                var self = compressor.self();
                statements = statements.reduce(function(a, stat) {
                    if (has_quit) {
                        extract_declarations_from_unreachable_code(compressor, stat, a);
                    } else {
                        if (stat instanceof AST_LoopControl) {
                            var lct = compressor.loopcontrol_target(stat.label);
                            if (stat instanceof AST_Break && lct instanceof AST_BlockStatement && loop_body(lct) === self || stat instanceof AST_Continue && loop_body(lct) === self) {
                                if (stat.label) {
                                    remove(stat.label.thedef.references, stat);
                                }
                            } else {
                                a.push(stat);
                            }
                        } else {
                            a.push(stat);
                        }
                        if (aborts(stat)) has_quit = true;
                    }
                    return a;
                }, []);
                CHANGED = statements.length != orig;
                return statements;
            }
            function sequencesize(statements, compressor) {
                if (statements.length < 2) return statements;
                var seq = [], ret = [];
                function push_seq() {
                    seq = AST_Seq.from_array(seq);
                    if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
                        body: seq
                    }));
                    seq = [];
                }
                statements.forEach(function(stat) {
                    if (stat instanceof AST_SimpleStatement) seq.push(stat.body); else push_seq(), ret.push(stat);
                });
                push_seq();
                ret = sequencesize_2(ret, compressor);
                CHANGED = ret.length != statements.length;
                return ret;
            }
            function sequencesize_2(statements, compressor) {
                function cons_seq(right) {
                    ret.pop();
                    var left = prev.body;
                    if (left instanceof AST_Seq) {
                        left.add(right);
                    } else {
                        left = AST_Seq.cons(left, right);
                    }
                    return left.transform(compressor);
                }
                var ret = [], prev = null;
                statements.forEach(function(stat) {
                    if (prev) {
                        if (stat instanceof AST_For) {
                            var opera = {};
                            try {
                                prev.body.walk(new TreeWalker(function(node) {
                                    if (node instanceof AST_Binary && node.operator == "in") throw opera;
                                }));
                                if (stat.init && !(stat.init instanceof AST_Definitions)) {
                                    stat.init = cons_seq(stat.init);
                                } else if (!stat.init) {
                                    stat.init = prev.body;
                                    ret.pop();
                                }
                            } catch (ex) {
                                if (ex !== opera) throw ex;
                            }
                        } else if (stat instanceof AST_If) {
                            stat.condition = cons_seq(stat.condition);
                        } else if (stat instanceof AST_With) {
                            stat.expression = cons_seq(stat.expression);
                        } else if (stat instanceof AST_Exit && stat.value) {
                            stat.value = cons_seq(stat.value);
                        } else if (stat instanceof AST_Exit) {
                            stat.value = cons_seq(make_node(AST_Undefined, stat));
                        } else if (stat instanceof AST_Switch) {
                            stat.expression = cons_seq(stat.expression);
                        }
                    }
                    ret.push(stat);
                    prev = stat instanceof AST_SimpleStatement ? stat : null;
                });
                return ret;
            }
            function join_consecutive_vars(statements, compressor) {
                var prev = null;
                return statements.reduce(function(a, stat) {
                    if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
                        prev.definitions = prev.definitions.concat(stat.definitions);
                        CHANGED = true;
                    } else if (stat instanceof AST_For && prev instanceof AST_Definitions && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                        CHANGED = true;
                        a.pop();
                        if (stat.init) {
                            stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                        } else {
                            stat.init = prev;
                        }
                        a.push(stat);
                        prev = stat;
                    } else {
                        prev = stat;
                        a.push(stat);
                    }
                    return a;
                }, []);
            }
            function negate_iifes(statements, compressor) {
                statements.forEach(function(stat) {
                    if (stat instanceof AST_SimpleStatement) {
                        stat.body = function transform(thing) {
                            return thing.transform(new TreeTransformer(function(node) {
                                if (node instanceof AST_Call && node.expression instanceof AST_Function) {
                                    return make_node(AST_UnaryPrefix, node, {
                                        operator: "!",
                                        expression: node
                                    });
                                } else if (node instanceof AST_Call) {
                                    node.expression = transform(node.expression);
                                } else if (node instanceof AST_Seq) {
                                    node.car = transform(node.car);
                                } else if (node instanceof AST_Conditional) {
                                    var expr = transform(node.condition);
                                    if (expr !== node.condition) {
                                        // it has been negated, reverse
                                        node.condition = expr;
                                        var tmp = node.consequent;
                                        node.consequent = node.alternative;
                                        node.alternative = tmp;
                                    }
                                }
                                return node;
                            }));
                        }(stat.body);
                    }
                });
            }
        }
        function extract_declarations_from_unreachable_code(compressor, stat, target) {
            compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
            stat.walk(new TreeWalker(function(node) {
                if (node instanceof AST_Definitions) {
                    compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                    node.remove_initializers();
                    target.push(node);
                    return true;
                }
                if (node instanceof AST_Defun) {
                    target.push(node);
                    return true;
                }
                if (node instanceof AST_Scope) {
                    return true;
                }
            }));
        }
        /* -----[ boolean/negation helpers ]----- */
        // methods to determine whether an expression has a boolean result type
        (function(def) {
            var unary_bool = [ "!", "delete" ];
            var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
            def(AST_Node, function() {
                return false;
            });
            def(AST_UnaryPrefix, function() {
                return member(this.operator, unary_bool);
            });
            def(AST_Binary, function() {
                return member(this.operator, binary_bool) || (this.operator == "&&" || this.operator == "||") && this.left.is_boolean() && this.right.is_boolean();
            });
            def(AST_Conditional, function() {
                return this.consequent.is_boolean() && this.alternative.is_boolean();
            });
            def(AST_Assign, function() {
                return this.operator == "=" && this.right.is_boolean();
            });
            def(AST_Seq, function() {
                return this.cdr.is_boolean();
            });
            def(AST_True, function() {
                return true;
            });
            def(AST_False, function() {
                return true;
            });
        })(function(node, func) {
            node.DEFMETHOD("is_boolean", func);
        });
        // methods to determine if an expression has a string result type
        (function(def) {
            def(AST_Node, function() {
                return false;
            });
            def(AST_String, function() {
                return true;
            });
            def(AST_UnaryPrefix, function() {
                return this.operator == "typeof";
            });
            def(AST_Binary, function(compressor) {
                return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
            });
            def(AST_Assign, function(compressor) {
                return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
            });
            def(AST_Seq, function(compressor) {
                return this.cdr.is_string(compressor);
            });
            def(AST_Conditional, function(compressor) {
                return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
            });
            def(AST_Call, function(compressor) {
                return compressor.option("unsafe") && this.expression instanceof AST_SymbolRef && this.expression.name == "String" && this.expression.undeclared();
            });
        })(function(node, func) {
            node.DEFMETHOD("is_string", func);
        });
        function best_of(ast1, ast2) {
            return ast1.print_to_string().length > ast2.print_to_string().length ? ast2 : ast1;
        }
        // methods to evaluate a constant expression
        (function(def) {
            // The evaluate method returns an array with one or two
            // elements.  If the node has been successfully reduced to a
            // constant, then the second element tells us the value;
            // otherwise the second element is missing.  The first element
            // of the array is always an AST_Node descendant; if
            // evaluation was successful it's a node that represents the
            // constant; otherwise it's the original or a replacement node.
            AST_Node.DEFMETHOD("evaluate", function(compressor) {
                if (!compressor.option("evaluate")) return [ this ];
                try {
                    var val = this._eval(compressor);
                    return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
                } catch (ex) {
                    if (ex !== def) throw ex;
                    return [ this ];
                }
            });
            def(AST_Statement, function() {
                throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
            });
            def(AST_Function, function() {
                // XXX: AST_Function inherits from AST_Scope, which itself
                // inherits from AST_Statement; however, an AST_Function
                // isn't really a statement.  This could byte in other
                // places too. :-( Wish JS had multiple inheritance.
                throw def;
            });
            function ev(node, compressor) {
                if (!compressor) throw new Error("Compressor must be passed");
                return node._eval(compressor);
            }
            def(AST_Node, function() {
                throw def;
            });
            def(AST_Constant, function() {
                return this.getValue();
            });
            def(AST_UnaryPrefix, function(compressor) {
                var e = this.expression;
                switch (this.operator) {
                    case "!":
                        return !ev(e, compressor);

                    case "typeof":
                        // Function would be evaluated to an array and so typeof would
                        // incorrectly return 'object'. Hence making is a special case.
                        if (e instanceof AST_Function) return typeof function() {};
                        e = ev(e, compressor);
                        // typeof <RegExp> returns "object" or "function" on different platforms
                        // so cannot evaluate reliably
                        if (e instanceof RegExp) throw def;
                        return typeof e;

                    case "void":
                        return void ev(e, compressor);

                    case "~":
                        return ~ev(e, compressor);

                    case "-":
                        e = ev(e, compressor);
                        if (e === 0) throw def;
                        return -e;

                    case "+":
                        return +ev(e, compressor);
                }
                throw def;
            });
            def(AST_Binary, function(c) {
                var left = this.left, right = this.right;
                switch (this.operator) {
                    case "&&":
                        return ev(left, c) && ev(right, c);

                    case "||":
                        return ev(left, c) || ev(right, c);

                    case "|":
                        return ev(left, c) | ev(right, c);

                    case "&":
                        return ev(left, c) & ev(right, c);

                    case "^":
                        return ev(left, c) ^ ev(right, c);

                    case "+":
                        return ev(left, c) + ev(right, c);

                    case "*":
                        return ev(left, c) * ev(right, c);

                    case "/":
                        return ev(left, c) / ev(right, c);

                    case "%":
                        return ev(left, c) % ev(right, c);

                    case "-":
                        return ev(left, c) - ev(right, c);

                    case "<<":
                        return ev(left, c) << ev(right, c);

                    case ">>":
                        return ev(left, c) >> ev(right, c);

                    case ">>>":
                        return ev(left, c) >>> ev(right, c);

                    case "==":
                        return ev(left, c) == ev(right, c);

                    case "===":
                        return ev(left, c) === ev(right, c);

                    case "!=":
                        return ev(left, c) != ev(right, c);

                    case "!==":
                        return ev(left, c) !== ev(right, c);

                    case "<":
                        return ev(left, c) < ev(right, c);

                    case "<=":
                        return ev(left, c) <= ev(right, c);

                    case ">":
                        return ev(left, c) > ev(right, c);

                    case ">=":
                        return ev(left, c) >= ev(right, c);

                    case "in":
                        return ev(left, c) in ev(right, c);

                    case "instanceof":
                        return ev(left, c) instanceof ev(right, c);
                }
                throw def;
            });
            def(AST_Conditional, function(compressor) {
                return ev(this.condition, compressor) ? ev(this.consequent, compressor) : ev(this.alternative, compressor);
            });
            def(AST_SymbolRef, function(compressor) {
                var d = this.definition();
                if (d && d.constant && d.init) return ev(d.init, compressor);
                throw def;
            });
        })(function(node, func) {
            node.DEFMETHOD("_eval", func);
        });
        // method to negate an expression
        (function(def) {
            function basic_negation(exp) {
                return make_node(AST_UnaryPrefix, exp, {
                    operator: "!",
                    expression: exp
                });
            }
            def(AST_Node, function() {
                return basic_negation(this);
            });
            def(AST_Statement, function() {
                throw new Error("Cannot negate a statement");
            });
            def(AST_Function, function() {
                return basic_negation(this);
            });
            def(AST_UnaryPrefix, function() {
                if (this.operator == "!") return this.expression;
                return basic_negation(this);
            });
            def(AST_Seq, function(compressor) {
                var self = this.clone();
                self.cdr = self.cdr.negate(compressor);
                return self;
            });
            def(AST_Conditional, function(compressor) {
                var self = this.clone();
                self.consequent = self.consequent.negate(compressor);
                self.alternative = self.alternative.negate(compressor);
                return best_of(basic_negation(this), self);
            });
            def(AST_Binary, function(compressor) {
                var self = this.clone(), op = this.operator;
                if (compressor.option("unsafe_comps")) {
                    switch (op) {
                        case "<=":
                            self.operator = ">";
                            return self;

                        case "<":
                            self.operator = ">=";
                            return self;

                        case ">=":
                            self.operator = "<";
                            return self;

                        case ">":
                            self.operator = "<=";
                            return self;
                    }
                }
                switch (op) {
                    case "==":
                        self.operator = "!=";
                        return self;

                    case "!=":
                        self.operator = "==";
                        return self;

                    case "===":
                        self.operator = "!==";
                        return self;

                    case "!==":
                        self.operator = "===";
                        return self;

                    case "&&":
                        self.operator = "||";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);

                    case "||":
                        self.operator = "&&";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);
                }
                return basic_negation(this);
            });
        })(function(node, func) {
            node.DEFMETHOD("negate", function(compressor) {
                return func.call(this, compressor);
            });
        });
        // determine if expression has side effects
        (function(def) {
            def(AST_Node, function(compressor) {
                return true;
            });
            def(AST_EmptyStatement, function(compressor) {
                return false;
            });
            def(AST_Constant, function(compressor) {
                return false;
            });
            def(AST_This, function(compressor) {
                return false;
            });
            def(AST_Call, function(compressor) {
                var pure = compressor.option("pure_funcs");
                if (!pure) return true;
                return pure.indexOf(this.expression.print_to_string()) < 0;
            });
            def(AST_Block, function(compressor) {
                for (var i = this.body.length; --i >= 0; ) {
                    if (this.body[i].has_side_effects(compressor)) return true;
                }
                return false;
            });
            def(AST_SimpleStatement, function(compressor) {
                return this.body.has_side_effects(compressor);
            });
            def(AST_Defun, function(compressor) {
                return true;
            });
            def(AST_Function, function(compressor) {
                return false;
            });
            def(AST_Binary, function(compressor) {
                return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);
            });
            def(AST_Assign, function(compressor) {
                return true;
            });
            def(AST_Conditional, function(compressor) {
                return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
            });
            def(AST_Unary, function(compressor) {
                return this.operator == "delete" || this.operator == "++" || this.operator == "--" || this.expression.has_side_effects(compressor);
            });
            def(AST_SymbolRef, function(compressor) {
                return false;
            });
            def(AST_Object, function(compressor) {
                for (var i = this.properties.length; --i >= 0; ) if (this.properties[i].has_side_effects(compressor)) return true;
                return false;
            });
            def(AST_ObjectProperty, function(compressor) {
                return this.value.has_side_effects(compressor);
            });
            def(AST_Array, function(compressor) {
                for (var i = this.elements.length; --i >= 0; ) if (this.elements[i].has_side_effects(compressor)) return true;
                return false;
            });
            def(AST_Dot, function(compressor) {
                if (!compressor.option("pure_getters")) return true;
                return this.expression.has_side_effects(compressor);
            });
            def(AST_Sub, function(compressor) {
                if (!compressor.option("pure_getters")) return true;
                return this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor);
            });
            def(AST_PropAccess, function(compressor) {
                return !compressor.option("pure_getters");
            });
            def(AST_Seq, function(compressor) {
                return this.car.has_side_effects(compressor) || this.cdr.has_side_effects(compressor);
            });
        })(function(node, func) {
            node.DEFMETHOD("has_side_effects", func);
        });
        // tell me if a statement aborts
        function aborts(thing) {
            return thing && thing.aborts();
        }
        (function(def) {
            def(AST_Statement, function() {
                return null;
            });
            def(AST_Jump, function() {
                return this;
            });
            function block_aborts() {
                var n = this.body.length;
                return n > 0 && aborts(this.body[n - 1]);
            }
            def(AST_BlockStatement, block_aborts);
            def(AST_SwitchBranch, block_aborts);
            def(AST_If, function() {
                return this.alternative && aborts(this.body) && aborts(this.alternative);
            });
        })(function(node, func) {
            node.DEFMETHOD("aborts", func);
        });
        /* -----[ optimizers ]----- */
        OPT(AST_Directive, function(self, compressor) {
            if (self.scope.has_directive(self.value) !== self.scope) {
                return make_node(AST_EmptyStatement, self);
            }
            return self;
        });
        OPT(AST_Debugger, function(self, compressor) {
            if (compressor.option("drop_debugger")) return make_node(AST_EmptyStatement, self);
            return self;
        });
        OPT(AST_LabeledStatement, function(self, compressor) {
            if (self.body instanceof AST_Break && compressor.loopcontrol_target(self.body.label) === self.body) {
                return make_node(AST_EmptyStatement, self);
            }
            return self.label.references.length == 0 ? self.body : self;
        });
        OPT(AST_Block, function(self, compressor) {
            self.body = tighten_body(self.body, compressor);
            return self;
        });
        OPT(AST_BlockStatement, function(self, compressor) {
            self.body = tighten_body(self.body, compressor);
            switch (self.body.length) {
                case 1:
                    return self.body[0];

                case 0:
                    return make_node(AST_EmptyStatement, self);
            }
            return self;
        });
        AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
            var self = this;
            if (compressor.option("unused") && !(self instanceof AST_Toplevel) && !self.uses_eval) {
                var in_use = [];
                var initializations = new Dictionary();
                // pass 1: find out which symbols are directly used in
                // this scope (not in nested scopes).
                var scope = this;
                var tw = new TreeWalker(function(node, descend) {
                    if (node !== self) {
                        if (node instanceof AST_Defun) {
                            initializations.add(node.name.name, node);
                            return true;
                        }
                        if (node instanceof AST_Definitions && scope === self) {
                            node.definitions.forEach(function(def) {
                                if (def.value) {
                                    initializations.add(def.name.name, def.value);
                                    if (def.value.has_side_effects(compressor)) {
                                        def.value.walk(tw);
                                    }
                                }
                            });
                            return true;
                        }
                        if (node instanceof AST_SymbolRef) {
                            push_uniq(in_use, node.definition());
                            return true;
                        }
                        if (node instanceof AST_Scope) {
                            var save_scope = scope;
                            scope = node;
                            descend();
                            scope = save_scope;
                            return true;
                        }
                    }
                });
                self.walk(tw);
                // pass 2: for every used symbol we need to walk its
                // initialization code to figure out if it uses other
                // symbols (that may not be in_use).
                for (var i = 0; i < in_use.length; ++i) {
                    in_use[i].orig.forEach(function(decl) {
                        // undeclared globals will be instanceof AST_SymbolRef
                        var init = initializations.get(decl.name);
                        if (init) init.forEach(function(init) {
                            var tw = new TreeWalker(function(node) {
                                if (node instanceof AST_SymbolRef) {
                                    push_uniq(in_use, node.definition());
                                }
                            });
                            init.walk(tw);
                        });
                    });
                }
                // pass 3: we should drop declarations not in_use
                var tt = new TreeTransformer(function before(node, descend, in_list) {
                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
                        for (var a = node.argnames, i = a.length; --i >= 0; ) {
                            var sym = a[i];
                            if (sym.unreferenced()) {
                                a.pop();
                                compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                    name: sym.name,
                                    file: sym.start.file,
                                    line: sym.start.line,
                                    col: sym.start.col
                                });
                            } else break;
                        }
                    }
                    if (node instanceof AST_Defun && node !== self) {
                        if (!member(node.name.definition(), in_use)) {
                            compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                name: node.name.name,
                                file: node.name.start.file,
                                line: node.name.start.line,
                                col: node.name.start.col
                            });
                            return make_node(AST_EmptyStatement, node);
                        }
                        return node;
                    }
                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                        var def = node.definitions.filter(function(def) {
                            if (member(def.name.definition(), in_use)) return true;
                            var w = {
                                name: def.name.name,
                                file: def.name.start.file,
                                line: def.name.start.line,
                                col: def.name.start.col
                            };
                            if (def.value && def.value.has_side_effects(compressor)) {
                                def._unused_side_effects = true;
                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                return true;
                            }
                            compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                            return false;
                        });
                        // place uninitialized names at the start
                        def = mergeSort(def, function(a, b) {
                            if (!a.value && b.value) return -1;
                            if (!b.value && a.value) return 1;
                            return 0;
                        });
                        // for unused names whose initialization has
                        // side effects, we can cascade the init. code
                        // into the next one, or next statement.
                        var side_effects = [];
                        for (var i = 0; i < def.length; ) {
                            var x = def[i];
                            if (x._unused_side_effects) {
                                side_effects.push(x.value);
                                def.splice(i, 1);
                            } else {
                                if (side_effects.length > 0) {
                                    side_effects.push(x.value);
                                    x.value = AST_Seq.from_array(side_effects);
                                    side_effects = [];
                                }
                                ++i;
                            }
                        }
                        if (side_effects.length > 0) {
                            side_effects = make_node(AST_BlockStatement, node, {
                                body: [ make_node(AST_SimpleStatement, node, {
                                    body: AST_Seq.from_array(side_effects)
                                }) ]
                            });
                        } else {
                            side_effects = null;
                        }
                        if (def.length == 0 && !side_effects) {
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (def.length == 0) {
                            return side_effects;
                        }
                        node.definitions = def;
                        if (side_effects) {
                            side_effects.body.unshift(node);
                            node = side_effects;
                        }
                        return node;
                    }
                    if (node instanceof AST_For && node.init instanceof AST_BlockStatement) {
                        descend(node, this);
                        // certain combination of unused name + side effect leads to:
                        //    https://github.com/mishoo/UglifyJS2/issues/44
                        // that's an invalid AST.
                        // We fix it at this stage by moving the `var` outside the `for`.
                        var body = node.init.body.slice(0, -1);
                        node.init = node.init.body.slice(-1)[0].body;
                        body.push(node);
                        return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                            body: body
                        });
                    }
                    if (node instanceof AST_Scope && node !== self) return node;
                });
                self.transform(tt);
            }
        });
        AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
            var hoist_funs = compressor.option("hoist_funs");
            var hoist_vars = compressor.option("hoist_vars");
            var self = this;
            if (hoist_funs || hoist_vars) {
                var dirs = [];
                var hoisted = [];
                var vars = new Dictionary(), vars_found = 0, var_decl = 0;
                // let's count var_decl first, we seem to waste a lot of
                // space if we hoist `var` when there's only one.
                self.walk(new TreeWalker(function(node) {
                    if (node instanceof AST_Scope && node !== self) return true;
                    if (node instanceof AST_Var) {
                        ++var_decl;
                        return true;
                    }
                }));
                hoist_vars = hoist_vars && var_decl > 1;
                var tt = new TreeTransformer(function before(node) {
                    if (node !== self) {
                        if (node instanceof AST_Directive) {
                            dirs.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Defun && hoist_funs) {
                            hoisted.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Var && hoist_vars) {
                            node.definitions.forEach(function(def) {
                                vars.set(def.name.name, def);
                                ++vars_found;
                            });
                            var seq = node.to_assignments();
                            var p = tt.parent();
                            if (p instanceof AST_ForIn && p.init === node) {
                                if (seq == null) return node.definitions[0].name;
                                return seq;
                            }
                            if (p instanceof AST_For && p.init === node) {
                                return seq;
                            }
                            if (!seq) return make_node(AST_EmptyStatement, node);
                            return make_node(AST_SimpleStatement, node, {
                                body: seq
                            });
                        }
                        if (node instanceof AST_Scope) return node;
                    }
                });
                self = self.transform(tt);
                if (vars_found > 0) {
                    // collect only vars which don't show up in self's arguments list
                    var defs = [];
                    vars.each(function(def, name) {
                        if (self instanceof AST_Lambda && find_if(function(x) {
                                return x.name == def.name.name;
                            }, self.argnames)) {
                            vars.del(name);
                        } else {
                            def = def.clone();
                            def.value = null;
                            defs.push(def);
                            vars.set(name, def);
                        }
                    });
                    if (defs.length > 0) {
                        // try to merge in assignments
                        for (var i = 0; i < self.body.length; ) {
                            if (self.body[i] instanceof AST_SimpleStatement) {
                                var expr = self.body[i].body, sym, assign;
                                if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
                                    var def = vars.get(sym.name);
                                    if (def.value) break;
                                    def.value = expr.right;
                                    remove(defs, def);
                                    defs.push(def);
                                    self.body.splice(i, 1);
                                    continue;
                                }
                                if (expr instanceof AST_Seq && (assign = expr.car) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
                                    var def = vars.get(sym.name);
                                    if (def.value) break;
                                    def.value = assign.right;
                                    remove(defs, def);
                                    defs.push(def);
                                    self.body[i].body = expr.cdr;
                                    continue;
                                }
                            }
                            if (self.body[i] instanceof AST_EmptyStatement) {
                                self.body.splice(i, 1);
                                continue;
                            }
                            if (self.body[i] instanceof AST_BlockStatement) {
                                var tmp = [ i, 1 ].concat(self.body[i].body);
                                self.body.splice.apply(self.body, tmp);
                                continue;
                            }
                            break;
                        }
                        defs = make_node(AST_Var, self, {
                            definitions: defs
                        });
                        hoisted.push(defs);
                    }
                }
                self.body = dirs.concat(hoisted, self.body);
            }
            return self;
        });
        OPT(AST_SimpleStatement, function(self, compressor) {
            if (compressor.option("side_effects")) {
                if (!self.body.has_side_effects(compressor)) {
                    compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                    return make_node(AST_EmptyStatement, self);
                }
            }
            return self;
        });
        OPT(AST_DWLoop, function(self, compressor) {
            var cond = self.condition.evaluate(compressor);
            self.condition = cond[0];
            if (!compressor.option("loops")) return self;
            if (cond.length > 1) {
                if (cond[1]) {
                    return make_node(AST_For, self, {
                        body: self.body
                    });
                } else if (self instanceof AST_While) {
                    if (compressor.option("dead_code")) {
                        var a = [];
                        extract_declarations_from_unreachable_code(compressor, self.body, a);
                        return make_node(AST_BlockStatement, self, {
                            body: a
                        });
                    }
                }
            }
            return self;
        });
        function if_break_in_loop(self, compressor) {
            function drop_it(rest) {
                rest = as_statement_array(rest);
                if (self.body instanceof AST_BlockStatement) {
                    self.body = self.body.clone();
                    self.body.body = rest.concat(self.body.body.slice(1));
                    self.body = self.body.transform(compressor);
                } else {
                    self.body = make_node(AST_BlockStatement, self.body, {
                        body: rest
                    }).transform(compressor);
                }
                if_break_in_loop(self, compressor);
            }
            var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
            if (first instanceof AST_If) {
                if (first.body instanceof AST_Break && compressor.loopcontrol_target(first.body.label) === self) {
                    if (self.condition) {
                        self.condition = make_node(AST_Binary, self.condition, {
                            left: self.condition,
                            operator: "&&",
                            right: first.condition.negate(compressor)
                        });
                    } else {
                        self.condition = first.condition.negate(compressor);
                    }
                    drop_it(first.alternative);
                } else if (first.alternative instanceof AST_Break && compressor.loopcontrol_target(first.alternative.label) === self) {
                    if (self.condition) {
                        self.condition = make_node(AST_Binary, self.condition, {
                            left: self.condition,
                            operator: "&&",
                            right: first.condition
                        });
                    } else {
                        self.condition = first.condition;
                    }
                    drop_it(first.body);
                }
            }
        }
        OPT(AST_While, function(self, compressor) {
            if (!compressor.option("loops")) return self;
            self = AST_DWLoop.prototype.optimize.call(self, compressor);
            if (self instanceof AST_While) {
                if_break_in_loop(self, compressor);
                self = make_node(AST_For, self, self).transform(compressor);
            }
            return self;
        });
        OPT(AST_For, function(self, compressor) {
            var cond = self.condition;
            if (cond) {
                cond = cond.evaluate(compressor);
                self.condition = cond[0];
            }
            if (!compressor.option("loops")) return self;
            if (cond) {
                if (cond.length > 1 && !cond[1]) {
                    if (compressor.option("dead_code")) {
                        var a = [];
                        if (self.init instanceof AST_Statement) {
                            a.push(self.init);
                        } else if (self.init) {
                            a.push(make_node(AST_SimpleStatement, self.init, {
                                body: self.init
                            }));
                        }
                        extract_declarations_from_unreachable_code(compressor, self.body, a);
                        return make_node(AST_BlockStatement, self, {
                            body: a
                        });
                    }
                }
            }
            if_break_in_loop(self, compressor);
            return self;
        });
        OPT(AST_If, function(self, compressor) {
            if (!compressor.option("conditionals")) return self;
            // if condition can be statically determined, warn and drop
            // one of the blocks.  note, statically determined implies
            // “has no side effects”; also it doesn't work for cases like
            // `x && true`, though it probably should.
            var cond = self.condition.evaluate(compressor);
            self.condition = cond[0];
            if (cond.length > 1) {
                if (cond[1]) {
                    compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                    if (compressor.option("dead_code")) {
                        var a = [];
                        if (self.alternative) {
                            extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                        }
                        a.push(self.body);
                        return make_node(AST_BlockStatement, self, {
                            body: a
                        }).transform(compressor);
                    }
                } else {
                    compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                    if (compressor.option("dead_code")) {
                        var a = [];
                        extract_declarations_from_unreachable_code(compressor, self.body, a);
                        if (self.alternative) a.push(self.alternative);
                        return make_node(AST_BlockStatement, self, {
                            body: a
                        }).transform(compressor);
                    }
                }
            }
            if (is_empty(self.alternative)) self.alternative = null;
            var negated = self.condition.negate(compressor);
            var negated_is_best = best_of(self.condition, negated) === negated;
            if (self.alternative && negated_is_best) {
                negated_is_best = false;
                // because we already do the switch here.
                self.condition = negated;
                var tmp = self.body;
                self.body = self.alternative || make_node(AST_EmptyStatement);
                self.alternative = tmp;
            }
            if (is_empty(self.body) && is_empty(self.alternative)) {
                return make_node(AST_SimpleStatement, self.condition, {
                    body: self.condition
                }).transform(compressor);
            }
            if (self.body instanceof AST_SimpleStatement && self.alternative instanceof AST_SimpleStatement) {
                return make_node(AST_SimpleStatement, self, {
                    body: make_node(AST_Conditional, self, {
                        condition: self.condition,
                        consequent: self.body.body,
                        alternative: self.alternative.body
                    })
                }).transform(compressor);
            }
            if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
                if (negated_is_best) return make_node(AST_SimpleStatement, self, {
                    body: make_node(AST_Binary, self, {
                        operator: "||",
                        left: negated,
                        right: self.body.body
                    })
                }).transform(compressor);
                return make_node(AST_SimpleStatement, self, {
                    body: make_node(AST_Binary, self, {
                        operator: "&&",
                        left: self.condition,
                        right: self.body.body
                    })
                }).transform(compressor);
            }
            if (self.body instanceof AST_EmptyStatement && self.alternative && self.alternative instanceof AST_SimpleStatement) {
                return make_node(AST_SimpleStatement, self, {
                    body: make_node(AST_Binary, self, {
                        operator: "||",
                        left: self.condition,
                        right: self.alternative.body
                    })
                }).transform(compressor);
            }
            if (self.body instanceof AST_Exit && self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {
                return make_node(self.body.CTOR, self, {
                    value: make_node(AST_Conditional, self, {
                        condition: self.condition,
                        consequent: self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                        alternative: self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                    })
                }).transform(compressor);
            }
            if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {
                self.condition = make_node(AST_Binary, self.condition, {
                    operator: "&&",
                    left: self.condition,
                    right: self.body.condition
                }).transform(compressor);
                self.body = self.body.body;
            }
            if (aborts(self.body)) {
                if (self.alternative) {
                    var alt = self.alternative;
                    self.alternative = null;
                    return make_node(AST_BlockStatement, self, {
                        body: [ self, alt ]
                    }).transform(compressor);
                }
            }
            if (aborts(self.alternative)) {
                var body = self.body;
                self.body = self.alternative;
                self.condition = negated_is_best ? negated : self.condition.negate(compressor);
                self.alternative = null;
                return make_node(AST_BlockStatement, self, {
                    body: [ self, body ]
                }).transform(compressor);
            }
            return self;
        });
        OPT(AST_Switch, function(self, compressor) {
            if (self.body.length == 0 && compressor.option("conditionals")) {
                return make_node(AST_SimpleStatement, self, {
                    body: self.expression
                }).transform(compressor);
            }
            for (;;) {
                var last_branch = self.body[self.body.length - 1];
                if (last_branch) {
                    var stat = last_branch.body[last_branch.body.length - 1];
                    // last statement
                    if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self) last_branch.body.pop();
                    if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
                        self.body.pop();
                        continue;
                    }
                }
                break;
            }
            var exp = self.expression.evaluate(compressor);
            out: if (exp.length == 2) try {
                // constant expression
                self.expression = exp[0];
                if (!compressor.option("dead_code")) break out;
                var value = exp[1];
                var in_if = false;
                var in_block = false;
                var started = false;
                var stopped = false;
                var ruined = false;
                var tt = new TreeTransformer(function(node, descend, in_list) {
                    if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
                        // no need to descend these node types
                        return node;
                    } else if (node instanceof AST_Switch && node === self) {
                        node = node.clone();
                        descend(node, this);
                        return ruined ? node : make_node(AST_BlockStatement, node, {
                            body: node.body.reduce(function(a, branch) {
                                return a.concat(branch.body);
                            }, [])
                        }).transform(compressor);
                    } else if (node instanceof AST_If || node instanceof AST_Try) {
                        var save = in_if;
                        in_if = !in_block;
                        descend(node, this);
                        in_if = save;
                        return node;
                    } else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                        var save = in_block;
                        in_block = true;
                        descend(node, this);
                        in_block = save;
                        return node;
                    } else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
                        if (in_if) {
                            ruined = true;
                            return node;
                        }
                        if (in_block) return node;
                        stopped = true;
                        return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
                    } else if (node instanceof AST_SwitchBranch && this.parent() === self) {
                        if (stopped) return MAP.skip;
                        if (node instanceof AST_Case) {
                            var exp = node.expression.evaluate(compressor);
                            if (exp.length < 2) {
                                // got a case with non-constant expression, baling out
                                throw self;
                            }
                            if (exp[1] === value || started) {
                                started = true;
                                if (aborts(node)) stopped = true;
                                descend(node, this);
                                return node;
                            }
                            return MAP.skip;
                        }
                        descend(node, this);
                        return node;
                    }
                });
                tt.stack = compressor.stack.slice();
                // so that's able to see parent nodes
                self = self.transform(tt);
            } catch (ex) {
                if (ex !== self) throw ex;
            }
            return self;
        });
        OPT(AST_Case, function(self, compressor) {
            self.body = tighten_body(self.body, compressor);
            return self;
        });
        OPT(AST_Try, function(self, compressor) {
            self.body = tighten_body(self.body, compressor);
            return self;
        });
        AST_Definitions.DEFMETHOD("remove_initializers", function() {
            this.definitions.forEach(function(def) {
                def.value = null;
            });
        });
        AST_Definitions.DEFMETHOD("to_assignments", function() {
            var assignments = this.definitions.reduce(function(a, def) {
                if (def.value) {
                    var name = make_node(AST_SymbolRef, def.name, def.name);
                    a.push(make_node(AST_Assign, def, {
                        operator: "=",
                        left: name,
                        right: def.value
                    }));
                }
                return a;
            }, []);
            if (assignments.length == 0) return null;
            return AST_Seq.from_array(assignments);
        });
        OPT(AST_Definitions, function(self, compressor) {
            if (self.definitions.length == 0) return make_node(AST_EmptyStatement, self);
            return self;
        });
        OPT(AST_Function, function(self, compressor) {
            self = AST_Lambda.prototype.optimize.call(self, compressor);
            if (compressor.option("unused")) {
                if (self.name && self.name.unreferenced()) {
                    self.name = null;
                }
            }
            return self;
        });
        OPT(AST_Call, function(self, compressor) {
            if (compressor.option("unsafe")) {
                var exp = self.expression;
                if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                    switch (exp.name) {
                        case "Array":
                            if (self.args.length != 1) {
                                return make_node(AST_Array, self, {
                                    elements: self.args
                                });
                            }
                            break;

                        case "Object":
                            if (self.args.length == 0) {
                                return make_node(AST_Object, self, {
                                    properties: []
                                });
                            }
                            break;

                        case "String":
                            if (self.args.length == 0) return make_node(AST_String, self, {
                                value: ""
                            });
                            return make_node(AST_Binary, self, {
                                left: self.args[0],
                                operator: "+",
                                right: make_node(AST_String, self, {
                                    value: ""
                                })
                            });

                        case "Function":
                            if (all(self.args, function(x) {
                                    return x instanceof AST_String;
                                })) {
                                // quite a corner-case, but we can handle it:
                                //   https://github.com/mishoo/UglifyJS2/issues/203
                                // if the code argument is a constant, then we can minify it.
                                try {
                                    var code = "(function(" + self.args.slice(0, -1).map(function(arg) {
                                            return arg.value;
                                        }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
                                    var ast = parse(code);
                                    ast.figure_out_scope();
                                    var comp = new Compressor(compressor.options);
                                    ast = ast.transform(comp);
                                    ast.figure_out_scope();
                                    ast.mangle_names();
                                    var fun;
                                    try {
                                        ast.walk(new TreeWalker(function(node) {
                                            if (node instanceof AST_Lambda) {
                                                fun = node;
                                                throw ast;
                                            }
                                        }));
                                    } catch (ex) {
                                        if (ex !== ast) throw ex;
                                    }
                                    var args = fun.argnames.map(function(arg, i) {
                                        return make_node(AST_String, self.args[i], {
                                            value: arg.print_to_string()
                                        });
                                    });
                                    var code = OutputStream();
                                    AST_BlockStatement.prototype._codegen.call(fun, fun, code);
                                    code = code.toString().replace(/^\{|\}$/g, "");
                                    args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                        value: code
                                    }));
                                    self.args = args;
                                    return self;
                                } catch (ex) {
                                    if (ex instanceof JS_Parse_Error) {
                                        compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                        compressor.warn(ex.toString());
                                    } else {
                                        console.log(ex);
                                        throw ex;
                                    }
                                }
                            }
                            break;
                    }
                } else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
                    return make_node(AST_Binary, self, {
                        left: make_node(AST_String, self, {
                            value: ""
                        }),
                        operator: "+",
                        right: exp.expression
                    }).transform(compressor);
                } else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == "join") EXIT: {
                    var separator = self.args.length == 0 ? "," : self.args[0].evaluate(compressor)[1];
                    if (separator == null) break EXIT;
                    // not a constant
                    var elements = exp.expression.elements.reduce(function(a, el) {
                        el = el.evaluate(compressor);
                        if (a.length == 0 || el.length == 1) {
                            a.push(el);
                        } else {
                            var last = a[a.length - 1];
                            if (last.length == 2) {
                                // it's a constant
                                var val = "" + last[1] + separator + el[1];
                                a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                            } else {
                                a.push(el);
                            }
                        }
                        return a;
                    }, []);
                    if (elements.length == 0) return make_node(AST_String, self, {
                        value: ""
                    });
                    if (elements.length == 1) return elements[0][0];
                    if (separator == "") {
                        var first;
                        if (elements[0][0] instanceof AST_String || elements[1][0] instanceof AST_String) {
                            first = elements.shift()[0];
                        } else {
                            first = make_node(AST_String, self, {
                                value: ""
                            });
                        }
                        return elements.reduce(function(prev, el) {
                            return make_node(AST_Binary, el[0], {
                                operator: "+",
                                left: prev,
                                right: el[0]
                            });
                        }, first).transform(compressor);
                    }
                    // need this awkward cloning to not affect original element
                    // best_of will decide which one to get through.
                    var node = self.clone();
                    node.expression = node.expression.clone();
                    node.expression.expression = node.expression.expression.clone();
                    node.expression.expression.elements = elements.map(function(el) {
                        return el[0];
                    });
                    return best_of(self, node);
                }
            }
            if (compressor.option("side_effects")) {
                if (self.expression instanceof AST_Function && self.args.length == 0 && !AST_Block.prototype.has_side_effects.call(self.expression, compressor)) {
                    return make_node(AST_Undefined, self).transform(compressor);
                }
            }
            return self.evaluate(compressor)[0];
        });
        OPT(AST_New, function(self, compressor) {
            if (compressor.option("unsafe")) {
                var exp = self.expression;
                if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                    switch (exp.name) {
                        case "Object":
                        case "RegExp":
                        case "Function":
                        case "Error":
                        case "Array":
                            return make_node(AST_Call, self, self).transform(compressor);
                    }
                }
            }
            return self;
        });
        OPT(AST_Seq, function(self, compressor) {
            if (!compressor.option("side_effects")) return self;
            if (!self.car.has_side_effects(compressor)) {
                // we shouldn't compress (1,eval)(something) to
                // eval(something) because that changes the meaning of
                // eval (becomes lexical instead of global).
                var p;
                if (!(self.cdr instanceof AST_SymbolRef && self.cdr.name == "eval" && self.cdr.undeclared() && (p = compressor.parent()) instanceof AST_Call && p.expression === self)) {
                    return self.cdr;
                }
            }
            if (compressor.option("cascade")) {
                if (self.car instanceof AST_Assign && !self.car.left.has_side_effects(compressor) && self.car.left.equivalent_to(self.cdr)) {
                    return self.car;
                }
                if (!self.car.has_side_effects(compressor) && !self.cdr.has_side_effects(compressor) && self.car.equivalent_to(self.cdr)) {
                    return self.car;
                }
            }
            return self;
        });
        AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
            if (compressor.option("sequences")) {
                if (this.expression instanceof AST_Seq) {
                    var seq = this.expression;
                    var x = seq.to_array();
                    this.expression = x.pop();
                    x.push(this);
                    seq = AST_Seq.from_array(x).transform(compressor);
                    return seq;
                }
            }
            return this;
        });
        OPT(AST_UnaryPostfix, function(self, compressor) {
            return self.lift_sequences(compressor);
        });
        OPT(AST_UnaryPrefix, function(self, compressor) {
            self = self.lift_sequences(compressor);
            var e = self.expression;
            if (compressor.option("booleans") && compressor.in_boolean_context()) {
                switch (self.operator) {
                    case "!":
                        if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                            // !!foo ==> foo, if we're in boolean context
                            return e.expression;
                        }
                        break;

                    case "typeof":
                        // typeof always returns a non-empty string, thus it's
                        // always true in booleans
                        compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                        return make_node(AST_True, self);
                }
                if (e instanceof AST_Binary && self.operator == "!") {
                    self = best_of(self, e.negate(compressor));
                }
            }
            return self.evaluate(compressor)[0];
        });
        AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
            if (compressor.option("sequences")) {
                if (this.left instanceof AST_Seq) {
                    var seq = this.left;
                    var x = seq.to_array();
                    this.left = x.pop();
                    x.push(this);
                    seq = AST_Seq.from_array(x).transform(compressor);
                    return seq;
                }
                if (this.right instanceof AST_Seq && !(this.operator == "||" || this.operator == "&&") && !this.left.has_side_effects(compressor)) {
                    var seq = this.right;
                    var x = seq.to_array();
                    this.right = x.pop();
                    x.push(this);
                    seq = AST_Seq.from_array(x).transform(compressor);
                    return seq;
                }
            }
            return this;
        });
        var commutativeOperators = makePredicate("== === != !== * & | ^");
        OPT(AST_Binary, function(self, compressor) {
            var reverse = compressor.has_directive("use asm") ? noop : function(op, force) {
                if (force || !(self.left.has_side_effects(compressor) || self.right.has_side_effects(compressor))) {
                    if (op) self.operator = op;
                    var tmp = self.left;
                    self.left = self.right;
                    self.right = tmp;
                }
            };
            if (commutativeOperators(self.operator)) {
                if (self.right instanceof AST_Constant && !(self.left instanceof AST_Constant)) {
                    // if right is a constant, whatever side effects the
                    // left side might have could not influence the
                    // result.  hence, force switch.
                    reverse(null, true);
                }
                if (/^[!=]==?$/.test(self.operator)) {
                    if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {
                        if (self.right.consequent instanceof AST_SymbolRef && self.right.consequent.definition() === self.left.definition()) {
                            if (/^==/.test(self.operator)) return self.right.condition;
                            if (/^!=/.test(self.operator)) return self.right.condition.negate(compressor);
                        }
                        if (self.right.alternative instanceof AST_SymbolRef && self.right.alternative.definition() === self.left.definition()) {
                            if (/^==/.test(self.operator)) return self.right.condition.negate(compressor);
                            if (/^!=/.test(self.operator)) return self.right.condition;
                        }
                    }
                    if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {
                        if (self.left.consequent instanceof AST_SymbolRef && self.left.consequent.definition() === self.right.definition()) {
                            if (/^==/.test(self.operator)) return self.left.condition;
                            if (/^!=/.test(self.operator)) return self.left.condition.negate(compressor);
                        }
                        if (self.left.alternative instanceof AST_SymbolRef && self.left.alternative.definition() === self.right.definition()) {
                            if (/^==/.test(self.operator)) return self.left.condition.negate(compressor);
                            if (/^!=/.test(self.operator)) return self.left.condition;
                        }
                    }
                }
            }
            self = self.lift_sequences(compressor);
            if (compressor.option("comparisons")) switch (self.operator) {
                case "===":
                case "!==":
                    if (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_boolean() && self.right.is_boolean()) {
                        self.operator = self.operator.substr(0, 2);
                    }

                // XXX: intentionally falling down to the next case
                case "==":
                case "!=":
                    if (self.left instanceof AST_String && self.left.value == "undefined" && self.right instanceof AST_UnaryPrefix && self.right.operator == "typeof" && compressor.option("unsafe")) {
                        if (!(self.right.expression instanceof AST_SymbolRef) || !self.right.expression.undeclared()) {
                            self.right = self.right.expression;
                            self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                            if (self.operator.length == 2) self.operator += "=";
                        }
                    }
                    break;
            }
            if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
                case "&&":
                    var ll = self.left.evaluate(compressor);
                    var rr = self.right.evaluate(compressor);
                    if (ll.length > 1 && !ll[1] || rr.length > 1 && !rr[1]) {
                        compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                        return make_node(AST_False, self);
                    }
                    if (ll.length > 1 && ll[1]) {
                        return rr[0];
                    }
                    if (rr.length > 1 && rr[1]) {
                        return ll[0];
                    }
                    break;

                case "||":
                    var ll = self.left.evaluate(compressor);
                    var rr = self.right.evaluate(compressor);
                    if (ll.length > 1 && ll[1] || rr.length > 1 && rr[1]) {
                        compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                        return make_node(AST_True, self);
                    }
                    if (ll.length > 1 && !ll[1]) {
                        return rr[0];
                    }
                    if (rr.length > 1 && !rr[1]) {
                        return ll[0];
                    }
                    break;

                case "+":
                    var ll = self.left.evaluate(compressor);
                    var rr = self.right.evaluate(compressor);
                    if (ll.length > 1 && ll[0] instanceof AST_String && ll[1] || rr.length > 1 && rr[0] instanceof AST_String && rr[1]) {
                        compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                        return make_node(AST_True, self);
                    }
                    break;
            }
            if (compressor.option("comparisons")) {
                if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
                    var negated = make_node(AST_UnaryPrefix, self, {
                        operator: "!",
                        expression: self.negate(compressor)
                    });
                    self = best_of(self, negated);
                }
                switch (self.operator) {
                    case "<":
                        reverse(">");
                        break;

                    case "<=":
                        reverse(">=");
                        break;
                }
            }
            if (self.operator == "+" && self.right instanceof AST_String && self.right.getValue() === "" && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.is_string(compressor)) {
                return self.left;
            }
            if (compressor.option("evaluate")) {
                if (self.operator == "+") {
                    if (self.left instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == "+" && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {
                        self = make_node(AST_Binary, self, {
                            operator: "+",
                            left: make_node(AST_String, null, {
                                value: "" + self.left.getValue() + self.right.left.getValue(),
                                start: self.left.start,
                                end: self.right.left.end
                            }),
                            right: self.right.right
                        });
                    }
                    if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.right instanceof AST_Constant && self.left.is_string(compressor)) {
                        self = make_node(AST_Binary, self, {
                            operator: "+",
                            left: self.left.left,
                            right: make_node(AST_String, null, {
                                value: "" + self.left.right.getValue() + self.right.getValue(),
                                start: self.left.right.start,
                                end: self.right.end
                            })
                        });
                    }
                    if (self.left instanceof AST_Binary && self.left.operator == "+" && self.left.is_string(compressor) && self.left.right instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == "+" && self.right.left instanceof AST_Constant) {
                        self = make_node(AST_Binary, self, {
                            operator: "+",
                            left: make_node(AST_Binary, self.left, {
                                operator: "+",
                                left: self.left.left,
                                right: make_node(AST_String, null, {
                                    value: "" + self.left.right.getValue() + self.right.left.getValue(),
                                    start: self.left.right.start,
                                    end: self.right.left.end
                                })
                            }),
                            right: self.right.right
                        });
                    }
                }
            }
            return self.evaluate(compressor)[0];
        });
        OPT(AST_SymbolRef, function(self, compressor) {
            if (self.undeclared()) {
                var defines = compressor.option("global_defs");
                if (defines && defines.hasOwnProperty(self.name)) {
                    return make_node_from_constant(compressor, defines[self.name], self);
                }
                switch (self.name) {
                    case "undefined":
                        return make_node(AST_Undefined, self);

                    case "NaN":
                        return make_node(AST_NaN, self);

                    case "Infinity":
                        return make_node(AST_Infinity, self);
                }
            }
            return self;
        });
        OPT(AST_Undefined, function(self, compressor) {
            if (compressor.option("unsafe")) {
                var scope = compressor.find_parent(AST_Scope);
                var undef = scope.find_variable("undefined");
                if (undef) {
                    var ref = make_node(AST_SymbolRef, self, {
                        name: "undefined",
                        scope: scope,
                        thedef: undef
                    });
                    ref.reference();
                    return ref;
                }
            }
            return self;
        });
        var ASSIGN_OPS = [ "+", "-", "/", "*", "%", ">>", "<<", ">>>", "|", "^", "&" ];
        OPT(AST_Assign, function(self, compressor) {
            self = self.lift_sequences(compressor);
            if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary && self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && member(self.right.operator, ASSIGN_OPS)) {
                self.operator = self.right.operator + "=";
                self.right = self.right.right;
            }
            return self;
        });
        OPT(AST_Conditional, function(self, compressor) {
            if (!compressor.option("conditionals")) return self;
            if (self.condition instanceof AST_Seq) {
                var car = self.condition.car;
                self.condition = self.condition.cdr;
                return AST_Seq.cons(car, self);
            }
            var cond = self.condition.evaluate(compressor);
            if (cond.length > 1) {
                if (cond[1]) {
                    compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                    return self.consequent;
                } else {
                    compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                    return self.alternative;
                }
            }
            var negated = cond[0].negate(compressor);
            if (best_of(cond[0], negated) === negated) {
                self = make_node(AST_Conditional, self, {
                    condition: negated,
                    consequent: self.alternative,
                    alternative: self.consequent
                });
            }
            var consequent = self.consequent;
            var alternative = self.alternative;
            if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator == alternative.operator && consequent.left.equivalent_to(alternative.left)) {
                /*
                 * Stuff like this:
                 * if (foo) exp = something; else exp = something_else;
                 * ==>
                 * exp = foo ? something : something_else;
                 */
                self = make_node(AST_Assign, self, {
                    operator: consequent.operator,
                    left: consequent.left,
                    right: make_node(AST_Conditional, self, {
                        condition: self.condition,
                        consequent: consequent.right,
                        alternative: alternative.right
                    })
                });
            }
            return self;
        });
        OPT(AST_Boolean, function(self, compressor) {
            if (compressor.option("booleans")) {
                var p = compressor.parent();
                if (p instanceof AST_Binary && (p.operator == "==" || p.operator == "!=")) {
                    compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                        operator: p.operator,
                        value: self.value,
                        file: p.start.file,
                        line: p.start.line,
                        col: p.start.col
                    });
                    return make_node(AST_Number, self, {
                        value: +self.value
                    });
                }
                return make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: make_node(AST_Number, self, {
                        value: 1 - self.value
                    })
                });
            }
            return self;
        });
        OPT(AST_Sub, function(self, compressor) {
            var prop = self.property;
            if (prop instanceof AST_String && compressor.option("properties")) {
                prop = prop.getValue();
                if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
                    return make_node(AST_Dot, self, {
                        expression: self.expression,
                        property: prop
                    });
                }
            }
            return self;
        });
        function literals_in_boolean_context(self, compressor) {
            if (compressor.option("booleans") && compressor.in_boolean_context()) {
                return make_node(AST_True, self);
            }
            return self;
        }
        OPT(AST_Array, literals_in_boolean_context);
        OPT(AST_Object, literals_in_boolean_context);
        OPT(AST_RegExp, literals_in_boolean_context);
    })();
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    // a small wrapper around fitzgen's source-map library
    function SourceMap(options) {
        options = defaults(options, {
            file: null,
            root: null,
            orig: null
        });
        var generator = new MOZ_SourceMap.SourceMapGenerator({
            file: options.file,
            sourceRoot: options.root
        });
        var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
        function add(source, gen_line, gen_col, orig_line, orig_col, name) {
            if (orig_map) {
                var info = orig_map.originalPositionFor({
                    line: orig_line,
                    column: orig_col
                });
                source = info.source;
                orig_line = info.line;
                orig_col = info.column;
                name = info.name;
            }
            generator.addMapping({
                generated: {
                    line: gen_line,
                    column: gen_col
                },
                original: {
                    line: orig_line,
                    column: orig_col
                },
                source: source,
                name: name
            });
        }
        return {
            add: add,
            get: function() {
                return generator;
            },
            toString: function() {
                return generator.toString();
            }
        };
    }
    /***********************************************************************

     A JavaScript tokenizer / parser / beautifier / compressor.
     https://github.com/mishoo/UglifyJS2

     -------------------------------- (C) ---------------------------------

     Author: Mihai Bazon
     <mihai.bazon@gmail.com>
     http://mihai.bazon.net/blog

     Distributed under the BSD license:

     Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above
     copyright notice, this list of conditions and the following
     disclaimer.

     * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials
     provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
     OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.

     ***********************************************************************/
    "use strict";
    (function() {
        var MOZ_TO_ME = {
            TryStatement: function(M) {
                return new AST_Try({
                    start: my_start_token(M),
                    end: my_end_token(M),
                    body: from_moz(M.block).body,
                    bcatch: from_moz(M.handlers[0]),
                    bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
                });
            },
            CatchClause: function(M) {
                return new AST_Catch({
                    start: my_start_token(M),
                    end: my_end_token(M),
                    argname: from_moz(M.param),
                    body: from_moz(M.body).body
                });
            },
            ObjectExpression: function(M) {
                return new AST_Object({
                    start: my_start_token(M),
                    end: my_end_token(M),
                    properties: M.properties.map(function(prop) {
                        var key = prop.key;
                        var name = key.type == "Identifier" ? key.name : key.value;
                        var args = {
                            start: my_start_token(key),
                            end: my_end_token(prop.value),
                            key: name,
                            value: from_moz(prop.value)
                        };
                        switch (prop.kind) {
                            case "init":
                                return new AST_ObjectKeyVal(args);

                            case "set":
                                args.value.name = from_moz(key);
                                return new AST_ObjectSetter(args);

                            case "get":
                                args.value.name = from_moz(key);
                                return new AST_ObjectGetter(args);
                        }
                    })
                });
            },
            SequenceExpression: function(M) {
                return AST_Seq.from_array(M.expressions.map(from_moz));
            },
            MemberExpression: function(M) {
                return new (M.computed ? AST_Sub : AST_Dot)({
                    start: my_start_token(M),
                    end: my_end_token(M),
                    property: M.computed ? from_moz(M.property) : M.property.name,
                    expression: from_moz(M.object)
                });
            },
            SwitchCase: function(M) {
                return new (M.test ? AST_Case : AST_Default)({
                    start: my_start_token(M),
                    end: my_end_token(M),
                    expression: from_moz(M.test),
                    body: M.consequent.map(from_moz)
                });
            },
            Literal: function(M) {
                var val = M.value, args = {
                    start: my_start_token(M),
                    end: my_end_token(M)
                };
                if (val === null) return new AST_Null(args);
                switch (typeof val) {
                    case "string":
                        args.value = val;
                        return new AST_String(args);

                    case "number":
                        args.value = val;
                        return new AST_Number(args);

                    case "boolean":
                        return new (val ? AST_True : AST_False)(args);

                    default:
                        args.value = val;
                        return new AST_RegExp(args);
                }
            },
            UnaryExpression: From_Moz_Unary,
            UpdateExpression: From_Moz_Unary,
            Identifier: function(M) {
                var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
                return new (M.name == "this" ? AST_This : p.type == "LabeledStatement" ? AST_Label : p.type == "VariableDeclarator" && p.id === M ? p.kind == "const" ? AST_SymbolConst : AST_SymbolVar : p.type == "FunctionExpression" ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : p.type == "FunctionDeclaration" ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : p.type == "CatchClause" ? AST_SymbolCatch : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef : AST_SymbolRef)({
                    start: my_start_token(M),
                    end: my_end_token(M),
                    name: M.name
                });
            }
        };
        function From_Moz_Unary(M) {
            var prefix = "prefix" in M ? M.prefix : M.type == "UnaryExpression" ? true : false;
            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
                start: my_start_token(M),
                end: my_end_token(M),
                operator: M.operator,
                expression: from_moz(M.argument)
            });
        }
        var ME_TO_MOZ = {};
        map("Node", AST_Node);
        map("Program", AST_Toplevel, "body@body");
        map("Function", AST_Function, "id>name, params@argnames, body%body");
        map("EmptyStatement", AST_EmptyStatement);
        map("BlockStatement", AST_BlockStatement, "body@body");
        map("ExpressionStatement", AST_SimpleStatement, "expression>body");
        map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
        map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
        map("BreakStatement", AST_Break, "label>label");
        map("ContinueStatement", AST_Continue, "label>label");
        map("WithStatement", AST_With, "object>expression, body>body");
        map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
        map("ReturnStatement", AST_Return, "argument>value");
        map("ThrowStatement", AST_Throw, "argument>value");
        map("WhileStatement", AST_While, "test>condition, body>body");
        map("DoWhileStatement", AST_Do, "test>condition, body>body");
        map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
        map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
        map("DebuggerStatement", AST_Debugger);
        map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
        map("VariableDeclaration", AST_Var, "declarations@definitions");
        map("VariableDeclarator", AST_VarDef, "id>name, init>value");
        map("ThisExpression", AST_This);
        map("ArrayExpression", AST_Array, "elements@elements");
        map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
        map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
        map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
        map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
        map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
        map("NewExpression", AST_New, "callee>expression, arguments@args");
        map("CallExpression", AST_Call, "callee>expression, arguments@args");
        /* -----[ tools ]----- */
        function my_start_token(moznode) {
            return new AST_Token({
                file: moznode.loc && moznode.loc.source,
                line: moznode.loc && moznode.loc.start.line,
                col: moznode.loc && moznode.loc.start.column,
                pos: moznode.start,
                endpos: moznode.start
            });
        }
        function my_end_token(moznode) {
            return new AST_Token({
                file: moznode.loc && moznode.loc.source,
                line: moznode.loc && moznode.loc.end.line,
                col: moznode.loc && moznode.loc.end.column,
                pos: moznode.end,
                endpos: moznode.end
            });
        }
        function map(moztype, mytype, propmap) {
            var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
            moz_to_me += "return new mytype({\n" + "start: my_start_token(M),\n" + "end: my_end_token(M)";
            if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop) {
                var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
                if (!m) throw new Error("Can't understand property map: " + prop);
                var moz = "M." + m[1], how = m[2], my = m[3];
                moz_to_me += ",\n" + my + ": ";
                if (how == "@") {
                    moz_to_me += moz + ".map(from_moz)";
                } else if (how == ">") {
                    moz_to_me += "from_moz(" + moz + ")";
                } else if (how == "=") {
                    moz_to_me += moz;
                } else if (how == "%") {
                    moz_to_me += "from_moz(" + moz + ").body";
                } else throw new Error("Can't understand operator in propmap: " + prop);
            });
            moz_to_me += "\n})}";
            // moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
            // console.log(moz_to_me);
            moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(mytype, my_start_token, my_end_token, from_moz);
            return MOZ_TO_ME[moztype] = moz_to_me;
        }
        var FROM_MOZ_STACK = null;
        function from_moz(node) {
            FROM_MOZ_STACK.push(node);
            var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
            FROM_MOZ_STACK.pop();
            return ret;
        }
        AST_Node.from_mozilla_ast = function(node) {
            var save_stack = FROM_MOZ_STACK;
            FROM_MOZ_STACK = [];
            var ast = from_moz(node);
            FROM_MOZ_STACK = save_stack;
            return ast;
        };
    })();
    exports["array_to_hash"] = array_to_hash;
    exports["slice"] = slice;
    exports["characters"] = characters;
    exports["member"] = member;
    exports["find_if"] = find_if;
    exports["repeat_string"] = repeat_string;
    exports["DefaultsError"] = DefaultsError;
    exports["defaults"] = defaults;
    exports["merge"] = merge;
    exports["noop"] = noop;
    exports["MAP"] = MAP;
    exports["push_uniq"] = push_uniq;
    exports["string_template"] = string_template;
    exports["remove"] = remove;
    exports["mergeSort"] = mergeSort;
    exports["set_difference"] = set_difference;
    exports["set_intersection"] = set_intersection;
    exports["makePredicate"] = makePredicate;
    exports["all"] = all;
    exports["Dictionary"] = Dictionary;
    exports["DEFNODE"] = DEFNODE;
    exports["AST_Token"] = AST_Token;
    exports["AST_Node"] = AST_Node;
    exports["AST_Statement"] = AST_Statement;
    exports["AST_Debugger"] = AST_Debugger;
    exports["AST_Directive"] = AST_Directive;
    exports["AST_SimpleStatement"] = AST_SimpleStatement;
    exports["walk_body"] = walk_body;
    exports["AST_Block"] = AST_Block;
    exports["AST_BlockStatement"] = AST_BlockStatement;
    exports["AST_EmptyStatement"] = AST_EmptyStatement;
    exports["AST_StatementWithBody"] = AST_StatementWithBody;
    exports["AST_LabeledStatement"] = AST_LabeledStatement;
    exports["AST_IterationStatement"] = AST_IterationStatement;
    exports["AST_DWLoop"] = AST_DWLoop;
    exports["AST_Do"] = AST_Do;
    exports["AST_While"] = AST_While;
    exports["AST_For"] = AST_For;
    exports["AST_ForIn"] = AST_ForIn;
    exports["AST_With"] = AST_With;
    exports["AST_Scope"] = AST_Scope;
    exports["AST_Toplevel"] = AST_Toplevel;
    exports["AST_Lambda"] = AST_Lambda;
    exports["AST_Accessor"] = AST_Accessor;
    exports["AST_Function"] = AST_Function;
    exports["AST_Defun"] = AST_Defun;
    exports["AST_Jump"] = AST_Jump;
    exports["AST_Exit"] = AST_Exit;
    exports["AST_Return"] = AST_Return;
    exports["AST_Throw"] = AST_Throw;
    exports["AST_LoopControl"] = AST_LoopControl;
    exports["AST_Break"] = AST_Break;
    exports["AST_Continue"] = AST_Continue;
    exports["AST_If"] = AST_If;
    exports["AST_Switch"] = AST_Switch;
    exports["AST_SwitchBranch"] = AST_SwitchBranch;
    exports["AST_Default"] = AST_Default;
    exports["AST_Case"] = AST_Case;
    exports["AST_Try"] = AST_Try;
    exports["AST_Catch"] = AST_Catch;
    exports["AST_Finally"] = AST_Finally;
    exports["AST_Definitions"] = AST_Definitions;
    exports["AST_Var"] = AST_Var;
    exports["AST_Const"] = AST_Const;
    exports["AST_VarDef"] = AST_VarDef;
    exports["AST_Call"] = AST_Call;
    exports["AST_New"] = AST_New;
    exports["AST_Seq"] = AST_Seq;
    exports["AST_PropAccess"] = AST_PropAccess;
    exports["AST_Dot"] = AST_Dot;
    exports["AST_Sub"] = AST_Sub;
    exports["AST_Unary"] = AST_Unary;
    exports["AST_UnaryPrefix"] = AST_UnaryPrefix;
    exports["AST_UnaryPostfix"] = AST_UnaryPostfix;
    exports["AST_Binary"] = AST_Binary;
    exports["AST_Conditional"] = AST_Conditional;
    exports["AST_Assign"] = AST_Assign;
    exports["AST_Array"] = AST_Array;
    exports["AST_Object"] = AST_Object;
    exports["AST_ObjectProperty"] = AST_ObjectProperty;
    exports["AST_ObjectKeyVal"] = AST_ObjectKeyVal;
    exports["AST_ObjectSetter"] = AST_ObjectSetter;
    exports["AST_ObjectGetter"] = AST_ObjectGetter;
    exports["AST_Symbol"] = AST_Symbol;
    exports["AST_SymbolAccessor"] = AST_SymbolAccessor;
    exports["AST_SymbolDeclaration"] = AST_SymbolDeclaration;
    exports["AST_SymbolVar"] = AST_SymbolVar;
    exports["AST_SymbolConst"] = AST_SymbolConst;
    exports["AST_SymbolFunarg"] = AST_SymbolFunarg;
    exports["AST_SymbolDefun"] = AST_SymbolDefun;
    exports["AST_SymbolLambda"] = AST_SymbolLambda;
    exports["AST_SymbolCatch"] = AST_SymbolCatch;
    exports["AST_Label"] = AST_Label;
    exports["AST_SymbolRef"] = AST_SymbolRef;
    exports["AST_LabelRef"] = AST_LabelRef;
    exports["AST_This"] = AST_This;
    exports["AST_Constant"] = AST_Constant;
    exports["AST_String"] = AST_String;
    exports["AST_Number"] = AST_Number;
    exports["AST_RegExp"] = AST_RegExp;
    exports["AST_Atom"] = AST_Atom;
    exports["AST_Null"] = AST_Null;
    exports["AST_NaN"] = AST_NaN;
    exports["AST_Undefined"] = AST_Undefined;
    exports["AST_Hole"] = AST_Hole;
    exports["AST_Infinity"] = AST_Infinity;
    exports["AST_Boolean"] = AST_Boolean;
    exports["AST_False"] = AST_False;
    exports["AST_True"] = AST_True;
    exports["TreeWalker"] = TreeWalker;
    exports["KEYWORDS"] = KEYWORDS;
    exports["KEYWORDS_ATOM"] = KEYWORDS_ATOM;
    exports["RESERVED_WORDS"] = RESERVED_WORDS;
    exports["KEYWORDS_BEFORE_EXPRESSION"] = KEYWORDS_BEFORE_EXPRESSION;
    exports["OPERATOR_CHARS"] = OPERATOR_CHARS;
    exports["RE_HEX_NUMBER"] = RE_HEX_NUMBER;
    exports["RE_OCT_NUMBER"] = RE_OCT_NUMBER;
    exports["RE_DEC_NUMBER"] = RE_DEC_NUMBER;
    exports["OPERATORS"] = OPERATORS;
    exports["WHITESPACE_CHARS"] = WHITESPACE_CHARS;
    exports["PUNC_BEFORE_EXPRESSION"] = PUNC_BEFORE_EXPRESSION;
    exports["PUNC_CHARS"] = PUNC_CHARS;
    exports["REGEXP_MODIFIERS"] = REGEXP_MODIFIERS;
    exports["UNICODE"] = UNICODE;
    exports["is_letter"] = is_letter;
    exports["is_digit"] = is_digit;
    exports["is_alphanumeric_char"] = is_alphanumeric_char;
    exports["is_unicode_combining_mark"] = is_unicode_combining_mark;
    exports["is_unicode_connector_punctuation"] = is_unicode_connector_punctuation;
    exports["is_identifier"] = is_identifier;
    exports["is_identifier_start"] = is_identifier_start;
    exports["is_identifier_char"] = is_identifier_char;
    exports["is_identifier_string"] = is_identifier_string;
    exports["parse_js_number"] = parse_js_number;
    exports["JS_Parse_Error"] = JS_Parse_Error;
    exports["js_error"] = js_error;
    exports["is_token"] = is_token;
    exports["EX_EOF"] = EX_EOF;
    exports["tokenizer"] = tokenizer;
    exports["UNARY_PREFIX"] = UNARY_PREFIX;
    exports["UNARY_POSTFIX"] = UNARY_POSTFIX;
    exports["ASSIGNMENT"] = ASSIGNMENT;
    exports["PRECEDENCE"] = PRECEDENCE;
    exports["STATEMENTS_WITH_LABELS"] = STATEMENTS_WITH_LABELS;
    exports["ATOMIC_START_TOKEN"] = ATOMIC_START_TOKEN;
    exports["parse"] = parse;
    exports["TreeTransformer"] = TreeTransformer;
    exports["SymbolDef"] = SymbolDef;
    exports["base54"] = base54;
    exports["OutputStream"] = OutputStream;
    exports["Compressor"] = Compressor;
    exports["SourceMap"] = SourceMap;
})({}, function() {
    return this;
}());















module('users.timfelgentreff.babelsberg.src_transform').requires(
    'cop.Layers',
    'lively.morphic.Halos',
    'lively.ide.CodeEditor').
toRun(function() {
    JSLoader.loadJs(module('users.timfelgentreff.babelsberg.uglify').uri());

    Object.subclass('BabelsbergSrcTransform', {
        isAlways: function(node) {
            return ((node instanceof UglifyJS.AST_LabeledStatement) &&
            (node.label.name === 'always') &&
            (node.body instanceof UglifyJS.AST_BlockStatement));
        },

        isRule: function(node) {
            if ((node instanceof UglifyJS.AST_Label) &&
                node.name === 'rule') {
                this.__ruleLabelSeen = node;
                return true;
            } else if (this.__ruleLabelSeen &&
                node instanceof UglifyJS.AST_String) {
                return true;
            } else if ((node instanceof UglifyJS.AST_LabeledStatement) &&
                (node.label.name === 'rule') &&
                (node.body instanceof UglifyJS.AST_BlockStatement)) {
                return true;
            } else if ((node instanceof UglifyJS.AST_LabeledStatement) &&
                (node.body.body instanceof UglifyJS.AST_SimpleStatement) &&
                (node.body.body.body instanceof UglifyJS.AST_Call) &&
                (node.body.body.body.expression instanceof UglifyJS.AST_Dot) &&
                (node.body.body.body.expression.property === 'rule') &&
                (node.body.body.body.expression.expression.name === 'bbb')) {
                // rule label with string that was transformed... remove the label
                this.__ruleLabelRemove = true;
                return true;
            }
            this.__ruleLabelSeen = null;
            return false;
        },

        isOnce: function(node) {
            return ((node instanceof UglifyJS.AST_LabeledStatement) &&
            (node.label.name === 'once') &&
            (node.body instanceof UglifyJS.AST_BlockStatement));
        },

        isTrigger: function(node) {
            var isTrigger = ((node instanceof UglifyJS.AST_Call) &&
            (node.expression instanceof UglifyJS.AST_SymbolRef) &&
            (node.expression.name === 'when'));
            if(isTrigger) { debugger; }

            return isTrigger;
        },

        ensureThisToSelfIn: function(ast) {
            var tr = new UglifyJS.TreeTransformer(function(node) {
                if (node instanceof UglifyJS.AST_This) {
                    return new UglifyJS.AST_SymbolRef({
                        start: node.start,
                        end: node.end,
                        name: '_$_self'
                    });
                }
            }, null);
            ast.transform(tr);
        },

        hasContextInArgs: function(constraintNode) {
            if (constraintNode.args.length == 2) {
                if (!constraintNode.args[0] instanceof UglifyJS.AST_Object) {
                    throw new SyntaxError(
                        "first argument of call to `always' must be an object"
                    );
                }
                return constraintNode.args[0].properties.any(function(ea) {
                    return ea.key === 'ctx';
                });
            } else {
                return false;
            }
        },

        createContextFor: function(ast, constraintNode) {
            var enclosed = ast.enclosed,
                self = this;
            if (constraintNode.args.last() instanceof UglifyJS.AST_Function) {
                enclosed = constraintNode.args.last().enclosed || [];
                enclosed = enclosed.reject(function(ea) {
                    // reject all that
                    //   1. are not declared (var) BEFORE the always
                    //   2. are first referenced (globals, specials, etc) AFTER the always
                    return (ea.init && (ea.init.start.pos > constraintNode.start.pos)) ||
                        (ea.orig && ea.orig[0] &&
                        (ea.orig[0].start.pos > constraintNode.end.pos));
                });
                enclosed.push({name: '_$_self'}); // always include this
            }
            var ctx = new UglifyJS.AST_Object({
                start: constraintNode.start,
                end: constraintNode.end,
                properties: enclosed.collect(function(ea) {
                    return new UglifyJS.AST_ObjectKeyVal({
                        start: constraintNode.start,
                        end: constraintNode.end,
                        key: ea.name,
                        value: self.contextMap(ea.name)
                    });
                })
            });

            var ctxkeyval = new UglifyJS.AST_ObjectKeyVal({
                start: constraintNode.start,
                end: constraintNode.end,
                key: 'ctx',
                value: ctx
            });
            if (constraintNode.args.length == 2) {
                constraintNode.args[0].properties.push(ctxkeyval);
            } else {
                constraintNode.args.unshift(new UglifyJS.AST_Object({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    properties: [ctxkeyval]
                }));
            }
        },

        ensureContextFor: function(ast, constraintNode) {
            if (!this.hasContextInArgs(constraintNode)) {
                this.createContextFor(ast, constraintNode);
            }
        },

        getContextTransformerFor: function(ast) {
            var self = this;
            return new UglifyJS.TreeTransformer(null, function(node) {
                if (self.isAlways(node)) {
                    return self.transformConstraint(ast, node, 'always');
                } else if (self.isOnce(node)) {
                    return self.transformConstraint(ast, node, 'once');
                } else if (self.isTrigger(node)) {
                    return self.transformConstraint(ast, node, 'when');
                } else if (self.isRule(node)) {
                    var node = self.createRuleFor(node);
                    self.isTransformed = true;
                    return node;
                }
            });
        },

        transformConstraint: function(ast, node, name) {
            var node = this.createCallFor(ast, node, name);
            this.isTransformed = true;
            return node;
        },

        transform: function(code) {
            var ast = UglifyJS.parse(code);
            ast.figure_out_scope();
            var transformedAst = ast.transform(this.getContextTransformerFor(ast)),
                stream = UglifyJS.OutputStream({beautify: true, comments: true});
            if (this.isTransformed) {
                transformedAst.print(stream);
                return stream.toString();
            } else {
                return code;
            }
        },
        transformAddScript: function(code) {
            var ast = UglifyJS.parse(code);
            ast.figure_out_scope(),
                transformed = false;
            var transformedAst = ast.transform(new UglifyJS.TreeTransformer(
                null,
                function(node) {
                    if (node instanceof UglifyJS.AST_Call &&
                        node.expression instanceof UglifyJS.AST_Dot &&
                        node.expression.property === 'addScript' &&
                        node.expression.expression instanceof UglifyJS.AST_This) {
                        assert(node.args.length === 1);
                        node.args.push(new UglifyJS.AST_String({
                            value: code.slice(node.args[0].start.pos, node.args[0].end.endpos)
                        }));
                        transformed = true;
                        return node;
                    }
                })),
                stream = UglifyJS.OutputStream({beautify: true, comments: true});
            if (transformed) {
                transformedAst.print(stream);
                return stream.toString();
            } else {
                return code;
            }
        },

        ensureReturnIn: function(body) {
            var lastStatement = body.last();
            if (!(lastStatement.body instanceof UglifyJS.AST_Return)) {
                body[body.length - 1] = new UglifyJS.AST_Return({
                    start: lastStatement.start,
                    end: lastStatement.end,
                    value: lastStatement
                });
            }
        },

        extractArgumentsFrom: function(constraintNode) {
            var body = constraintNode.body.body,
                newBody = [],
                args = [],
                extraArgs = [],
                store;
            newBody = body.select(function(ea) {
                if (ea instanceof UglifyJS.AST_LabeledStatement) {
                    if (!(ea.body instanceof UglifyJS.AST_SimpleStatement)) {
                        throw new SyntaxError(
                            "Labeled arguments in `always:' have to be simple statements"
                        );
                    }
                    if (ea.label.name == 'store' || ea.label.name == 'name') {
                        store = new UglifyJS.AST_Assign({
                            start: ea.start,
                            end: ea.end,
                            right: undefined /* filled later */,
                            operator: '=',
                            left: ea.body.body
                        });
                    } else {
                        extraArgs.push(new UglifyJS.AST_ObjectKeyVal({
                            start: ea.start,
                            end: ea.end,
                            key: ea.label.name,
                            value: ea.body.body
                        }));
                    }
                    return false;
                } else {
                    return true;
                }
            });
            if (extraArgs) {
                args.push(new UglifyJS.AST_Object({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    properties: extraArgs
                }));
            }
            return {body: newBody, args: args, store: store};
        },

        createCallFor: function(ast, constraintNode, methodName) {
            var body, args, store, enclosed,
                self = this;
            if (constraintNode instanceof UglifyJS.AST_LabeledStatement) {
                var splitBodyAndArgs = this.extractArgumentsFrom(constraintNode);
                body = splitBodyAndArgs.body;
                args = splitBodyAndArgs.args;
                store = splitBodyAndArgs.store;
                enclosed = constraintNode.label.scope.enclosed;
            } else if (constraintNode instanceof UglifyJS.AST_Call) {
                var nodeArgs = constraintNode.args,
                    funcArg = nodeArgs[nodeArgs.length - 1];
                if (!(funcArg instanceof UglifyJS.AST_Function)) {
                    throw new SyntaxError(
                        'Last argument to ' +
                        constraintNode.expression.name +
                        ' must be a function'
                    );
                }
                body = funcArg.body;
                args = nodeArgs.slice(0, nodeArgs.length - 1);
                enclosed = funcArg.enclosed;
            } else {
                throw SyntaxError("Don't know what to do with " + constraintNode);
            }

            this.ensureReturnIn(body);
            body.each(function(ea) {
                self.ensureThisToSelfIn(ea);
            });

            var call = new UglifyJS.AST_Call({
                start: constraintNode.start,
                end: constraintNode.end,
                expression: new UglifyJS.AST_Dot({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    property: methodName,
                    expression: new UglifyJS.AST_SymbolRef({
                        start: constraintNode.start,
                        end: constraintNode.end,
                        name: 'bbb'
                    })
                }),
                args: args.concat([new UglifyJS.AST_Function({
                    start: body.start,
                    end: body.end,
                    body: body,
                    enclosed: enclosed,
                    argnames: []
                })])
            });

            this.ensureContextFor(ast, call);

            var newBody;
            if (store) {
                store.right = call;
                newBody = store;
            } else {
                newBody = call;
            }
            if (constraintNode instanceof UglifyJS.AST_Statement) {
                return new UglifyJS.AST_SimpleStatement({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    body: newBody
                });
            } else {
                return newBody;
            }
        },

        createRuleFor: function(ruleNode) {
            // remove label
            if (ruleNode instanceof UglifyJS.AST_Label) return ruleNode;

            var stringNode;
            if (ruleNode instanceof UglifyJS.AST_String) {
                stringNode = ruleNode;
                stringNode.value = stringNode.value.replace(/\|\s*-/mg, ':-');
                ruleNode = this.__ruleLabelSeen;
                delete this.__ruleLabelSeen;
            } else if (this.__ruleLabelRemove) {
                delete this.__ruleLabelRemove;
                return ruleNode.body.body;
            } else {
                // ruleNode instanceof UglifyJS.AST_LabeledStatement
                var stream = UglifyJS.OutputStream({beautify: true, comments: true});
                ruleNode.body.print(stream);
                stringNode = new UglifyJS.AST_String({
                    start: ruleNode.body.start,
                    end: ruleNode.body.end,
                    value: stream.toString().
                    replace(/\|\s*-/mg, ':-').
                    replace(/^{\s*/, '').
                    replace(/\s*}\s*$/, '').
                    replace(/\s*;\s*$/, '')
                });
            }

            return new UglifyJS.AST_SimpleStatement({
                start: ruleNode.start,
                end: ruleNode.end,
                body: new UglifyJS.AST_Call({
                    start: ruleNode.start,
                    end: ruleNode.end,
                    expression: new UglifyJS.AST_Dot({
                        start: ruleNode.start,
                        end: ruleNode.end,
                        property: 'rule',
                        expression: new UglifyJS.AST_SymbolRef({
                            start: ruleNode.start,
                            end: ruleNode.end,
                            name: 'bbb'
                        })
                    }),
                    args: [stringNode]
                })
            });
        },

        contextMap: function(name) {
            // map some custom shortnames to bbb functions
            if (name === '_$_self') {
                return new UglifyJS.AST_Binary({
                    operator: '||',
                    left: new UglifyJS.AST_Dot({
                        expression: new UglifyJS.AST_This({}),
                        property: 'doitContext'
                    }),
                    right: new UglifyJS.AST_This({})
                });
            }

            if (name === 'ro') {
                name = 'bbb.readonly';
            }
            if (name === 'system') {
                name = 'bbb.system()';
            }
            return new UglifyJS.AST_SymbolRef({name: name});
        }

    });

    if (!(lively && lively.morphic && lively.morphic.Morph && lively.morphic.CodeEditor))
        return;


    cop.create('AddScriptWithFakeOriginalLayer').refineClass(lively.morphic.Morph, {
        addScript: function(funcOrString, origSource) {
            var originalFunction;
            originalFunction = cop.proceed.apply(this, [origSource]);
            var result = cop.proceed.apply(this, [funcOrString]);
            result.getOriginal().setProperty('originalFunction', originalFunction);
            return result;
        }
    });

    cop.create('ConstraintSyntaxLayer').refineClass(lively.morphic.CodeEditor, {
        doSave: function() {
            if (this.owner instanceof lively.ide.BrowserPanel) {
                // XXX: Ad-hoc fragment search
                var matchData = this.textString.match(/[^"](always:|once:)/),
                    t = new BabelsbergSrcTransform(),
                    idx = (matchData && matchData.index) || -1,
                    endIdx = this.textString.indexOf('}', idx + 1),
                    fragments = [],
                    offset = 0,
                    lines = this.textString.split('\n').map(function(line) {
                        return [line, offset += line.length + 1];
                    });
                while (idx !== -1 && endIdx !== -1) {
                    try {
                        var str = t.transform(this.textString.slice(idx, endIdx + 1));
                        var line;
                        lines.some(function(ary) {
                            line = ary[0]; return ary[1] > idx;
                        });
                        var indent = new Array(line.match(/always:|once:/).index + 1).
                        join(' ');
                        str = str.split('\n').inject('', function(acc, line) {
                            return acc + '\n' + indent + line;
                        }).slice('\n'.length + indent.length);
                        // remove first newline+indent
                        fragments.push([idx + 1, endIdx, str]);
                        matchData = this.textString.slice(idx + 1).
                        match(/[^"](always:|once:)/);
                        idx = (matchData && (matchData.index + idx + 1)) || -1;
                        endIdx = this.textString.indexOf('}', idx + 2);
                    } catch (e) {
                        // parsing exception
                        endIdx = this.textString.indexOf('}', endIdx + 1);
                    }
                }

                if (fragments.length !== 0) {
                    var textPos = 0;
                    var newTextString = fragments.inject(
                        '',
                        function(memo, fragment) {
                            var r = this.textString.slice(
                                    textPos,
                                    fragment[0]
                                ) + fragment[2];
                            textPos = fragment[1] + 1;
                            return memo + r;
                        }.bind(this));
                    newTextString += this.textString.slice(textPos);
                    this.textString = newTextString;
                }
                return cop.withoutLayers([ConstraintSyntaxLayer], function() {
                    return cop.proceed();
                });
            } else {
                return cop.proceed();
            }
        },

        boundEval: function(code) {
            var t = new BabelsbergSrcTransform(),
                addScriptWithOrigCode = t.transformAddScript(code),
                constraintCode = t.transform(addScriptWithOrigCode);
            if (addScriptWithOrigCode === constraintCode) {
                // no constraints in code
                return cop.proceed.apply(this, [code]);
            } else {
                return cop.withLayers([AddScriptWithFakeOriginalLayer], function() {
                    // If this layer is not global but only on the
                    // morph, make sure we use it here
                    return cop.proceed.apply(this, [constraintCode]);
                });
            }
        }
    });
    ConstraintSyntaxLayer.beGlobal();

}); // end of module















/**
 * BabelsbergScript is a way to describe constraints in a convenient syntax.
 * @name BabelsbergScript
 * @tutorial babelsbergscript-tutorial
 */
(function() {
    var Http = {
        request: function(method, url, callback) {
            var xhr = new (window.ActiveXObject || XMLHttpRequest)(
                'Microsoft.XMLHTTP');
            xhr.open(method.toUpperCase(), url, true);
            if ('overrideMimeType' in xhr)
                xhr.overrideMimeType('text/plain');
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    var status = xhr.status;
                    if (status === 0 || status === 200) {
                        callback.call(xhr, xhr.responseText);
                    } else {
                        throw new Error(
                            'Could not load ' + url + ' (Error ' +
                            status + ')'
                        );
                    }
                }
            };
            return xhr.send(null);
        }
    };

    /**
     * Transforms the given {@link BabelsbergScript} source code as regular JavaScript.
     * @function Babelsberg.compile
     * @public
     * @param {string} code The source code that should be transformed.
     * @return {string} A transformed version of the given source code.
     */
    Babelsberg.compile = function(code) {
        var t = new BabelsbergSrcTransform();
        return t.transform(code);
    };

    /**
     * Transforms and executes the given {@link BabelsbergScript} source code.
     * @function Babelsberg.execute
     * @public
     * @param {string} code The source code that should be executed.
     * @param {Object} scope The scope in which the given code is executed.
     */
    Babelsberg.execute = function(code, scope) {
        var params = [],
            args = [],
            func;
        code = Babelsberg.compile(code);
        var firefox = window.InstallTrigger;
        if (firefox || window.chrome) {
            var script = document.createElement('script'),
                head = document.head;
            if (firefox)
                code = '\n' + code;
            script.appendChild(document.createTextNode(
                'bbb._execute = function(' + params + ') {' + code + '\n}'
            ));
            head.appendChild(script);
            func = bbb._execute;
            delete bbb._execute;
            head.removeChild(script);
        } else {
            func = Function(params, code);
        }
        var res = func.apply(scope, args) || {};
    };

    function load() {
        var numScripts = 0,
            fired = false;

        function checkForFinish() {
            if (numScripts === 0 && !fired) {
                if (document.createEvent) {
                    var event = document.createEvent('CustomEvent');
                    if (event.initCustomEvent) {
                        event.initCustomEvent(
                            'babelsbergready',
                            true, // bubbles
                            true, // cancellable
                            {message: 'Babelsberg Scripts loaded', time: new Date()}
                        );
                        fired = true;
                        document.dispatchEvent(event);
                        return;
                    }
                }
                // No custom event support
                console.warn('Custom Events not supported on this platform');
            }
        }

        function checkScript(script) {
            if (/^text\/(?:x-|)babelsbergscript$/.test(script.type) &&
                !script.getAttribute('babelsberg-ignore')) {
                var src = script.src;
                if (src) {
                    numScripts += 1;
                    Http.request('get', src, function(code) {
                        Babelsberg.execute(code);
                        numScripts -= 1;
                        checkForFinish();
                    });
                } else {
                    Babelsberg.execute(script.innerHTML);
                }
                script.setAttribute('babelsberg-ignore', true);
            }
        };

        var scripts = document.getElementsByTagName('script');
        for (var i = 0; i < scripts.length; i++)
            checkScript(scripts[i]);
        checkForFinish();
    }

    if (document.readyState === 'complete') {
        setTimeout(load);
    } else {
        contentLoaded(window, load);
    }
})();












module('ac_transform').requires(
    'cop.Layers').
toRun(function() {
    JSLoader.loadJs(module('users.timfelgentreff.babelsberg.uglify').uri());

    ACSrcTransform = Object.subclass('ACSrcTransform', {
        isAlways: function(node) {
            return ((node instanceof UglifyJS.AST_LabeledStatement) &&
            (node.label.name === 'always') &&
            (node.body instanceof UglifyJS.AST_BlockStatement));
        },

        isRule: function(node) {
            if ((node instanceof UglifyJS.AST_Label) &&
                node.name === 'rule') {
                this.__ruleLabelSeen = node;
                return true;
            } else if (this.__ruleLabelSeen &&
                node instanceof UglifyJS.AST_String) {
                return true;
            } else if ((node instanceof UglifyJS.AST_LabeledStatement) &&
                (node.label.name === 'rule') &&
                (node.body instanceof UglifyJS.AST_BlockStatement)) {
                return true;
            } else if ((node instanceof UglifyJS.AST_LabeledStatement) &&
                (node.body.body instanceof UglifyJS.AST_SimpleStatement) &&
                (node.body.body.body instanceof UglifyJS.AST_Call) &&
                (node.body.body.body.expression instanceof UglifyJS.AST_Dot) &&
                (node.body.body.body.expression.property === 'rule') &&
                (node.body.body.body.expression.expression.name === 'bbb')) {
                // rule label with string that was transformed... remove the label
                this.__ruleLabelRemove = true;
                return true;
            }
            this.__ruleLabelSeen = null;
            return false;
        },

        isOnce: function(node) {
            return ((node instanceof UglifyJS.AST_LabeledStatement) &&
            (node.label.name === 'once') &&
            (node.body instanceof UglifyJS.AST_BlockStatement));
        },

        isTrigger: function(node) {
            return ((node instanceof UglifyJS.AST_Call) &&
            (node.expression instanceof UglifyJS.AST_SymbolRef) &&
            (node.expression.name === 'when'));
        },

        // FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        // FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        // FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        isSelect: function(node) {
            return ((node instanceof UglifyJS.AST_Call) &&
            (node.expression instanceof UglifyJS.AST_SymbolRef) &&
            (node.expression.name === 'select'));
        },

        isFilter: function(node) {
            return (node instanceof UglifyJS.AST_Call) &&
                // expression is an access to a property named 'filter'
                (node.expression instanceof UglifyJS.AST_Dot) &&
                (node.expression.property === 'filter') &&
                // first parameter is a function
                (node.args && node.args.length === 1) &&
                (node.args[0] instanceof UglifyJS.AST_Function);
        },

        ensureThisToSelfIn: function(ast) {
            var tr = new UglifyJS.TreeTransformer(function(node) {
                if (node instanceof UglifyJS.AST_This) {
                    return new UglifyJS.AST_SymbolRef({
                        start: node.start,
                        end: node.end,
                        name: '_$_self'
                    });
                }
            }, null);
            ast.transform(tr);
        },

        hasContextInArgs: function(constraintNode) {
            return false;
            /*
             if (constraintNode.args.length == 2) {
             if (!constraintNode.args[0] instanceof UglifyJS.AST_Object) {
             throw new SyntaxError(
             "first argument of call to `always' must be an object"
             );
             }
             return constraintNode.args[0].properties.any(function(ea) {
             return ea.key === 'ctx';
             });
             } else {
             return false;
             }
             */
        },

        createContextFor: function(ast, constraintNode) {
            var enclosed = ast.enclosed,
                self = this,
                func = constraintNode.args.last();

            if (func instanceof UglifyJS.AST_Function) {
                enclosed = func.enclosed || [];
                enclosed = enclosed.reject(function(ea) {
                    return func.argnames.any(function(argname) {
                        return argname.name === ea.name;
                    });
                });
            }
            var ctx = new UglifyJS.AST_Object({
                start: constraintNode.start,
                end: constraintNode.end,
                properties: enclosed.collect(function(ea) {
                    return new UglifyJS.AST_ObjectKeyVal({
                        start: constraintNode.start,
                        end: constraintNode.end,
                        key: ea.name,
                        value: self.contextMap(ea.name)
                    });
                })
            });

            constraintNode.args.push(ctx);
        },

        ensureContextFor: function(ast, constraintNode) {
            if (!this.hasContextInArgs(constraintNode)) {
                this.createContextFor(ast, constraintNode);
            }
        },

        getContextTransformerFor: function(ast) {
            var self = this;
            return new UglifyJS.TreeTransformer(null, function(node) {
                if (self.isSelect(node)) {
                    console.log(node);
                    return self.transformConstraint(ast, node, 'select');
                } else if (self.isFilter(node)) {
                    return self.transformConstraint(ast, node, 'filter');
                } else if (self.isOnce(node)) {
                    return self.transformConstraint(ast, node, 'once');
                } else if (self.isTrigger(node)) {
                    return self.transformConstraint(ast, node, 'when');
                } else if (self.isAlways(node)) {
                    return self.transformConstraint(ast, node, 'always');
                }  else if (self.isRule(node)) {
                    var node = self.createRuleFor(node);
                    self.isTransformed = true;
                    return node;
                }
            });
        },

        transformConstraint: function(ast, node, name) {
            var node = this.createCallFor(ast, node, name);
            this.isTransformed = true;
            return node;
        },

        transform: function(code) {
            var ast = UglifyJS.parse(code);
            ast.figure_out_scope();
            var transformedAst = ast.transform(this.getContextTransformerFor(ast)),
                stream = UglifyJS.OutputStream({beautify: true, comments: true});
            if (this.isTransformed) {
                transformedAst.print(stream);
                return stream.toString();
            } else {
                return code;
            }
        },
        transformAddScript: function(code) {
            var ast = UglifyJS.parse(code);
            ast.figure_out_scope(),
                transformed = false;
            var transformedAst = ast.transform(new UglifyJS.TreeTransformer(
                null,
                function(node) {
                    if (node instanceof UglifyJS.AST_Call &&
                        node.expression instanceof UglifyJS.AST_Dot &&
                        node.expression.property === 'addScript' &&
                        node.expression.expression instanceof UglifyJS.AST_This) {
                        assert(node.args.length === 1);
                        node.args.push(new UglifyJS.AST_String({
                            value: code.slice(node.args[0].start.pos, node.args[0].end.endpos)
                        }));
                        transformed = true;
                        return node;
                    }
                })),
                stream = UglifyJS.OutputStream({beautify: true, comments: true});
            if (transformed) {
                transformedAst.print(stream);
                return stream.toString();
            } else {
                return code;
            }
        },

        ensureReturnIn: function(body) {
            var lastStatement = body.last();
            if (!(lastStatement.body instanceof UglifyJS.AST_Return)) {
                body[body.length - 1] = new UglifyJS.AST_Return({
                    start: lastStatement.start,
                    end: lastStatement.end,
                    value: lastStatement
                });
            }
        },

        extractArgumentsFrom: function(constraintNode) {
            var body = constraintNode.body.body,
                newBody = [],
                args = [],
                extraArgs = [],
                store;
            newBody = body.select(function(ea) {
                if (ea instanceof UglifyJS.AST_LabeledStatement) {
                    if (!(ea.body instanceof UglifyJS.AST_SimpleStatement)) {
                        throw new SyntaxError(
                            "Labeled arguments in `always:' have to be simple statements"
                        );
                    }
                    if (ea.label.name == 'store' || ea.label.name == 'name') {
                        store = new UglifyJS.AST_Assign({
                            start: ea.start,
                            end: ea.end,
                            right: undefined /* filled later */,
                            operator: '=',
                            left: ea.body.body
                        });
                    } else {
                        extraArgs.push(new UglifyJS.AST_ObjectKeyVal({
                            start: ea.start,
                            end: ea.end,
                            key: ea.label.name,
                            value: ea.body.body
                        }));
                    }
                    return false;
                } else {
                    return true;
                }
            });
            if (extraArgs) {
                args.push(new UglifyJS.AST_Object({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    properties: extraArgs
                }));
            }
            return {body: newBody, args: args, store: store};
        },

        // FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        // FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        // FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        createCallFor: function(ast, constraintNode, methodName) {
            this.ensureContextFor(ast, constraintNode);

            return constraintNode;



            /*
             var self = this;

             if (constraintNode instanceof UglifyJS.AST_LabeledStatement) {
             var splitBodyAndArgs = this.extractArgumentsFrom(constraintNode);
             body = splitBodyAndArgs.body;
             args = splitBodyAndArgs.args;
             store = splitBodyAndArgs.store;
             enclosed = constraintNode.label.scope.enclosed;
             } else

             if (!constraintNode instanceof UglifyJS.AST_Call) {
             throw SyntaxError("'select' is not a call: " + constraintNode);
             }

             var nodeArgs = constraintNode.args,
             funcArg = nodeArgs[nodeArgs.length - 1];
             if (!(funcArg instanceof UglifyJS.AST_Function)) {
             throw new SyntaxError(
             'Last argument to ' +
             constraintNode.expression.name +
             ' must be a function'
             );
             }
             var body = funcArg.body;
             var args = nodeArgs.slice(0, nodeArgs.length - 1);
             var enclosed = funcArg.enclosed;

             this.ensureReturnIn(body);
             body.each(function(ea) {
             this.ensureThisToSelfIn(ea);
             }, this);

             var call = new UglifyJS.AST_Call({
             start: constraintNode.start,
             end: constraintNode.end,
             expression: new UglifyJS.AST_Dot({
             start: constraintNode.start,
             end: constraintNode.end,
             property: methodName,
             expression: new UglifyJS.AST_SymbolRef({
             start: constraintNode.start,
             end: constraintNode.end,
             name: 'bbb'
             })
             }),
             args: args.concat([new UglifyJS.AST_Function({
             start: body.start,
             end: body.end,
             body: body,
             enclosed: enclosed,
             argnames: []
             })])
             });

             this.ensureContextFor(ast, call);

             var newBody = call;

             if (constraintNode instanceof UglifyJS.AST_Statement) {
             return new UglifyJS.AST_SimpleStatement({
             start: constraintNode.start,
             end: constraintNode.end,
             body: newBody
             });
             } else {
             return newBody;
             }
             */
        },

        createRuleFor: function(ruleNode) {
            // remove label
            if (ruleNode instanceof UglifyJS.AST_Label) return ruleNode;

            var stringNode;
            if (ruleNode instanceof UglifyJS.AST_String) {
                stringNode = ruleNode;
                stringNode.value = stringNode.value.replace(/\|\s*-/mg, ':-');
                ruleNode = this.__ruleLabelSeen;
                delete this.__ruleLabelSeen;
            } else if (this.__ruleLabelRemove) {
                delete this.__ruleLabelRemove;
                return ruleNode.body.body;
            } else {
                // ruleNode instanceof UglifyJS.AST_LabeledStatement
                var stream = UglifyJS.OutputStream({beautify: true, comments: true});
                ruleNode.body.print(stream);
                stringNode = new UglifyJS.AST_String({
                    start: ruleNode.body.start,
                    end: ruleNode.body.end,
                    value: stream.toString().
                    replace(/\|\s*-/mg, ':-').
                    replace(/^{\s*/, '').
                    replace(/\s*}\s*$/, '').
                    replace(/\s*;\s*$/, '')
                });
            }

            return new UglifyJS.AST_SimpleStatement({
                start: ruleNode.start,
                end: ruleNode.end,
                body: new UglifyJS.AST_Call({
                    start: ruleNode.start,
                    end: ruleNode.end,
                    expression: new UglifyJS.AST_Dot({
                        start: ruleNode.start,
                        end: ruleNode.end,
                        property: 'rule',
                        expression: new UglifyJS.AST_SymbolRef({
                            start: ruleNode.start,
                            end: ruleNode.end,
                            name: 'bbb'
                        })
                    }),
                    args: [stringNode]
                })
            });
        },

        contextMap: function(name) {
            // map some custom shortnames to bbb functions
            if (name === '_$_self') {
                return new UglifyJS.AST_Binary({
                    operator: '||',
                    left: new UglifyJS.AST_Dot({
                        expression: new UglifyJS.AST_This({}),
                        property: 'doitContext'
                    }),
                    right: new UglifyJS.AST_This({})
                });
            }

            if (name === 'ro') {
                name = 'bbb.readonly';
            }
            if (name === 'system') {
                name = 'bbb.system()';
            }
            return new UglifyJS.AST_SymbolRef({name: name});
        }

    });

    if (!(lively && lively.morphic && lively.morphic.Morph && lively.morphic.CodeEditor))
        return;


    cop.create('AddScriptWithFakeOriginalLayer').refineClass(lively.morphic.Morph, {
        addScript: function(funcOrString, origSource) {
            var originalFunction;
            originalFunction = cop.proceed.apply(this, [origSource]);
            var result = cop.proceed.apply(this, [funcOrString]);
            result.getOriginal().setProperty('originalFunction', originalFunction);
            return result;
        }
    });

    cop.create('ConstraintSyntaxLayer').refineClass(lively.morphic.CodeEditor, {
        doSave: function() {
            if (this.owner instanceof lively.ide.BrowserPanel) {
                // XXX: Ad-hoc fragment search
                var matchData = this.textString.match(/[^"](always:|once:)/),
                    t = new BabelsbergSrcTransform(),
                    idx = (matchData && matchData.index) || -1,
                    endIdx = this.textString.indexOf('}', idx + 1),
                    fragments = [],
                    offset = 0,
                    lines = this.textString.split('\n').map(function(line) {
                        return [line, offset += line.length + 1];
                    });
                while (idx !== -1 && endIdx !== -1) {
                    try {
                        var str = t.transform(this.textString.slice(idx, endIdx + 1));
                        var line;
                        lines.some(function(ary) {
                            line = ary[0]; return ary[1] > idx;
                        });
                        var indent = new Array(line.match(/always:|once:/).index + 1).
                        join(' ');
                        str = str.split('\n').inject('', function(acc, line) {
                            return acc + '\n' + indent + line;
                        }).slice('\n'.length + indent.length);
                        // remove first newline+indent
                        fragments.push([idx + 1, endIdx, str]);
                        matchData = this.textString.slice(idx + 1).
                        match(/[^"](always:|once:)/);
                        idx = (matchData && (matchData.index + idx + 1)) || -1;
                        endIdx = this.textString.indexOf('}', idx + 2);
                    } catch (e) {
                        // parsing exception
                        endIdx = this.textString.indexOf('}', endIdx + 1);
                    }
                }

                if (fragments.length !== 0) {
                    var textPos = 0;
                    var newTextString = fragments.inject(
                        '',
                        function(memo, fragment) {
                            var r = this.textString.slice(
                                    textPos,
                                    fragment[0]
                                ) + fragment[2];
                            textPos = fragment[1] + 1;
                            return memo + r;
                        }.bind(this));
                    newTextString += this.textString.slice(textPos);
                    this.textString = newTextString;
                }
                return cop.withoutLayers([ConstraintSyntaxLayer], function() {
                    return cop.proceed();
                });
            } else {
                return cop.proceed();
            }
        },

        boundEval: function(code) {
            var t = new BabelsbergSrcTransform(),
                addScriptWithOrigCode = t.transformAddScript(code),
                constraintCode = t.transform(addScriptWithOrigCode);
            if (addScriptWithOrigCode === constraintCode) {
                // no constraints in code
                return cop.proceed.apply(this, [code]);
            } else {
                return cop.withLayers([AddScriptWithFakeOriginalLayer], function() {
                    // If this layer is not global but only on the
                    // morph, make sure we use it here
                    return cop.proceed.apply(this, [constraintCode]);
                });
            }
        }
    });
    ConstraintSyntaxLayer.beGlobal();

}); // end of module














